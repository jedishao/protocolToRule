C:\Users\Shao\AppData\Local\Programs\Python\Python37\python.exe C:/python/protocolToRule/NLP/simpleRules.py
https://eips.ethereum.org/EIPS/eip-1
EIP stands for Ethereum Improvement Proposal. An EIP is a design document providing information to the Ethereum community, or describing a new feature for Ethereum or its processes or environment. The EIP should provide a concise technical specification of the feature and a rationale for the feature. The EIP author is responsible for building consensus within the community and documenting dissenting opinions.
If a Core EIP mentions or proposes changes to the EVM (Ethereum Virtual Machine), it should refer to the instructions by their mnemonics and define the opcodes of those mnemonics at least once. A preferred way is the following:
Before you begin writing a formal EIP, you should vet your idea. Ask the Ethereum community first if an idea is original to avoid wasting time on something that will be rejected based on prior research. It is thus recommended to open a discussion thread on the Ethereum Magicians forum to do this.
Once the idea has been vetted, your next responsibility will be to present (by means of an EIP) the idea to the reviewers and all interested parties, invite editors, developers, and the community to give feedback on the aforementioned channels. You should try and gauge whether the interest in your EIP is commensurate with both the work involved in implementing it and how many parties will have to conform to it. For example, the work required for implementing a Core EIP will be much greater than for an ERC and the EIP will need sufficient interest from the Ethereum client teams. Negative community feedback will be taken into consideration and may prevent your EIP from moving past the Draft stage.
These calls generally result in a “rough consensus” around what EIPs should be implemented. This “rough consensus” rests on the assumptions that EIPs are not contentious enough to cause a network split and that they are technically sound.
Final - This EIP represents the final standard. A Final EIP exists in a state of finality and should only be updated to correct errata and add non-normative clarifications.
Each EIP should have the following parts:
EIPs should be written in markdown format. There is a template to follow.
The created header records the date that the EIP was assigned a number. Both headers should be in yyyy-mm-dd format, e.g. 2001-08-14.
References to other EIPs should follow the format EIP-N where N is the EIP number you are referring to. Each EIP that is referenced in an EIP MUST be accompanied by a relative markdown link the first time it is referenced, and MAY be accompanied by a link on subsequent references. The link MUST always be done via relative paths so that the links work in this GitHub repository, forks of this repository, the main EIPs site, mirrors of the main EIP site, etc. For example, you would link to this EIP with [EIP-1](/EIPS/eip-1).
Images, diagrams and auxiliary files should be included in a subdirectory of the assets folder for that EIP as follows: assets/eip-N (where N is to be replaced with the EIP number). When linking to an image in the EIP, use relative links such as ../assets/eip-1/image.png.
When referring to an EIP by number, it should be written in the hyphenated form EIP-X where X is the EIP’s assigned number.
This document was derived heavily from Bitcoin’s BIP-0001 written by Amir Taaki which in turn was derived from Python’s PEP-0001. In many places text was simply copied and modified. Although the PEP-0001 text was written by Barry Warsaw, Jeremy Hylton, and David Goodger, they are not responsible for its use in the Ethereum Improvement Process, and should not be bothered with technical questions specific to Ethereum or the EIP. Please direct all comments to the EIP editors.
https://eips.ethereum.org/EIPS/eip-2
https://eips.ethereum.org/EIPS/eip-3
The opcode CALLDEPTH should return the remaining call stack depth. A value of 0 means that the call stack is exhausted, and no further calls can be made.
The actual call stack depth, as well as the call stack depth limit, are present in the EVM during execution, but just not available within the EVM. The implementation should be fairly simple and would provide a cheap and way to protect against call stack attacks.
https://eips.ethereum.org/EIPS/eip-4
https://eips.ethereum.org/EIPS/eip-5
After the call, the MSIZE opcode should return the size the memory was actually grown to.
At an earlier stage, it was proposed to also add the size of the returned data on the stack,
but the MSIZE mechanism described above should be sufficient and is much better
backwards compatible.
VM implementers should take care not to grow the memory until the end of the call and after a check that sufficient
gas is still available. Typical uses of the EIP include “reserving” 2**256-1 bytes of memory for the output.
https://eips.ethereum.org/EIPS/eip-6
The primary reason for us to change the term suicide is to show that people matter more than code and Ethereum is a mature enough of a project to recognize the need for a change. Suicide is a heavy subject and we should make every effort possible to not affect those in our development community who suffer from depression or who have recently lost someone to suicide. Ethereum is a young platform and it will cause less headaches if we implement this change early on in its life.
https://eips.ethereum.org/EIPS/eip-7
https://eips.ethereum.org/EIPS/eip-8
Implementations of the devp2p Wire Protocol should ignore the version number of hello
packets. When sending the hello packet, the version element should be set to the highest
devp2p version supported. Implementations should also ignore any additional list elements
at the end of the hello packet.
Implementations of the devp2p Wire Protocol should ignore the version number of hello
packets. When sending the hello packet, the version element should be set to the highest
devp2p version supported. Implementations should also ignore any additional list elements
at the end of the hello packet.
Implementations of the devp2p Wire Protocol should ignore the version number of hello
packets. When sending the hello packet, the version element should be set to the highest
devp2p version supported. Implementations should also ignore any additional list elements
at the end of the hello packet.
Similarly, implementations of the RLPx Discovery Protocol should not validate the
version number of the ping packet, ignore any additional list elements in any packet, and
ignore any data after the first RLP value in any packet. Discovery packets with unknown
packet type should be discarded silently. The maximum size of any discovery packet is
still 1280 bytes.
Similarly, implementations of the RLPx Discovery Protocol should not validate the
version number of the ping packet, ignore any additional list elements in any packet, and
ignore any data after the first RLP value in any packet. Discovery packets with unknown
packet type should be discarded silently. The maximum size of any discovery packet is
still 1280 bytes.
Finally, implementations of the RLPx TCP Transport protocol should accept a new
encoding for the encrypted key establishment handshake packets. If an EIP-8 style RLPx
auth-packet is received, the corresponding ack-packet should be sent using the rules
below.
Finally, implementations of the RLPx TCP Transport protocol should accept a new
encoding for the encrypted key establishment handshake packets. If an EIP-8 style RLPx
auth-packet is received, the corresponding ack-packet should be sent using the rules
below.
Decoding the RLP data in auth-body and ack-body should ignore mismatches of auth-vsn
and ack-vsn, any additional list elements and any trailing data after the list. During
the transitioning period (i.e. until the old format has been retired), implementations
should pad auth-body with at least 100 bytes of junk data. Adding a random amount in
range [100, 300] is recommended to vary the size of the packet.
Decoding the RLP data in auth-body and ack-body should ignore mismatches of auth-vsn
and ack-vsn, any additional list elements and any trailing data after the list. During
the transitioning period (i.e. until the old format has been retired), implementations
should pad auth-body with at least 100 bytes of junk data. Adding a random amount in
range [100, 300] is recommended to vary the size of the packet.
Implementations should accept the following encoded discovery packets as valid.
The packets are signed using the secp256k1 node key
https://eips.ethereum.org/EIPS/eip-20
NOTE: To prevent attack vectors like the one described here and discussed here,
clients SHOULD make sure to create user interfaces in such a way that they set the allowance first to 0 before setting it to another value for the same spender.
THOUGH The contract itself shouldn’t enforce it, to allow backwards compatibility with contracts deployed before
https://eips.ethereum.org/EIPS/eip-55
https://eips.ethereum.org/EIPS/eip-67
The proposal goes beyond address, and also includes optional bytecode and value. Of course this would make the link longer, but it should not be something visible to the user. Instead it should be shown as a visual code (QR or otherwise), a link, or some other way to pass the information.
The proposal goes beyond address, and also includes optional bytecode and value. Of course this would make the link longer, but it should not be something visible to the user. Instead it should be shown as a visual code (QR or otherwise), a link, or some other way to pass the information.
If properly implemented in all wallets, this should make execution of contracts directly from wallets much simpler as the wallet client only needs to put the bytecode obtained by reading the QR code.
Other data could be added, but ideally the client should take them from elsewhere in the blockchain, so instead of having a label or a message to be displayed to the users, these should be read from an identity system or metadata on the transaction itself.
Other data could be added, but ideally the client should take them from elsewhere in the blockchain, so instead of having a label or a message to be displayed to the users, these should be read from an identity system or metadata on the transaction itself.
https://eips.ethereum.org/EIPS/eip-86
https://eips.ethereum.org/EIPS/eip-100
Changing the denominator from 10 to 9 ensures that the block time remains roughly the same (in fact, it should decrease by ~3% given the current uncle rate of 7%).
https://eips.ethereum.org/EIPS/eip-101
https://eips.ethereum.org/EIPS/eip-107
https://eips.ethereum.org/EIPS/eip-137
The normative parts of this document does not specify an implementation of the proposed system; its purpose is to document a protocol that different resolver implementations can adhere to in order to facilitate consistent name resolution. An appendix provides sample implementations of resolver contracts and libraries, which should be treated as illustrative examples only.
Likewise, this document does not attempt to specify how domains should be registered or updated, or how systems can find the owner responsible for a given domain. Registration is the responsibility of registrars, and is a governance matter that will necessarily vary between top-level domains.
Implementations should conform to the following test vectors for namehash:
Similar to the resolver above, this contract only supports the contract address profile, but uses the ENS registry to determine who should be allowed to update entries:
https://eips.ethereum.org/EIPS/eip-140
should:
https://eips.ethereum.org/EIPS/eip-141
https://eips.ethereum.org/EIPS/eip-145
https://eips.ethereum.org/EIPS/eip-150
https://eips.ethereum.org/EIPS/eip-152
The precompile should compute the F function as specified in the RFC and return the updated state vector h with unchanged encoding (little-endian).
From this and other conversations with teams in the space, we believe we should focus first on the F precompile as a strictly necessary piece for interoperability projects. A BLAKE2b precompile is a nice-to-have, and we support any efforts to add one– but it’s unclear whether complete requirements and a flexible API can be found in time for Istanbul.
There is very little risk of breaking backwards-compatibility with this EIP, the sole issue being if someone were to build a contract relying on the address at 0x09 being empty. The likelihood of this is low, and should specific instances arise, the address could be chosen to be any arbitrary value with negligible risk of collision.
An average gas price of F precompile call with 12 rounds compared to ecRecover should have been 6.74153 and it gives 0.5618 gas per round.
An average gas price of F precompile call with 1200 rounds compared to ecRecover should have been 436.1288 and it gives 0.3634 gas per round.
An average gas price of F precompile call with 1 round compared to ecRecover should have been 2.431701. However, in this scenario the call cost would totally overshadow the dynamic cost anyway.
https://eips.ethereum.org/EIPS/eip-155
https://eips.ethereum.org/EIPS/eip-158
https://eips.ethereum.org/EIPS/eip-160
https://eips.ethereum.org/EIPS/eip-161
In the present Ethereum protocol, it should be noted that very few state changes can ultimately result in accounts that are empty following the execution of the transaction. In fact there are only four contexts that current implementations need track:
https://eips.ethereum.org/EIPS/eip-162
In order to maximize utility and adoption of a new namespace, the registrar should mitigate speculation and “name squatting”, however the best approach for mitigation is unclear. Thus an “initial” registrar is proposed, which implements a simple approach to name allocation. During the initial period, the available namespace will be significantly restricted to the .eth top level domain, and subdomain shorter than 7 characters in length disallowed. This specification largely describes @alexvandesande and @arachnid’s hash registrar implementation in order to facilitate discussion.
The following factors should be considered in order to optimize for adoption of the ENS, and good governance of the Initial Registrar’s namespace.
Upgradability: The Initial Registrar should be safely upgradeable, so that knowledge gained during its deployment can be used to replace it with an improved and permanent registrar.
Achieving an effective allocation may or may not require human intervention for dispute resolution and other forms of curation. The Initial Registrar should not aim to create to most effective possible allocation, but instead limit the cost of misallocation in the long term.
Simplicity: The ENS specification itself emphasizes a separation of concerns, allowing the most essential element, the registry to be as simple as possible. The interim registrar in turn should be as simple as possible while still meeting its other design goals.
Adoption: Successful standards become more successful due to network effects. The registrar should consider what strategies will encourage the adoption of the ENS in general, and the namespace it controls in particular.
The Initial Registrar is expected to be in service for approximately two years, prior to upgrading. This should be sufficient time to learn, observe, and design an updated system.
This restriction is enforced by the owner of the ENS root node who should not assign any nodes other than .eth to the Initial Registrar. The ENS’s root node should be controlled by multiple parties using a multisig contract.
This restriction is enforced by the owner of the ENS root node who should not assign any nodes other than .eth to the Initial Registrar. The ENS’s root node should be controlled by multiple parties using a multisig contract.
For example, in order to register abcdefg.eth, one should submit sha3('abcdefg'), not sha3(sha3(0, 'eth'), 'abcdefg').
The Initial Registrar requires the ENS’s address as a constructor, and should be deployed after the ENS. The multisig account owning the root node in the ENS should then set the Initial Registrar’s address as owner of the eth node.
The Initial Registrar requires the ENS’s address as a constructor, and should be deployed after the ENS. The multisig account owning the root node in the ENS should then set the Initial Registrar’s address as owner of the eth node.
The Initial Registrar is expected to be replaced by a Permanent Registrar approximately 2 years after deployment. The following process should be used for the upgrade:
https://eips.ethereum.org/EIPS/eip-165
The mechanism described above (with 0xffffffff) should work with most of the contracts previous to this standard to determine that they do not implement ERC-165.
https://eips.ethereum.org/EIPS/eip-170
https://eips.ethereum.org/EIPS/eip-173
Many smart contracts require that they be owned or controlled in some way. For example to withdraw funds or perform administrative actions. It is so common that the contract interface used to handle contract ownership should be standardized to allow compatibility with user interfaces and contracts that manage contracts.
Every ERC-173 compliant contract must implement the ERC173 interface. Contracts should also implement ERC165 for the ERC-173 interface.
The OwnershipTransferred event should be emitted when a contract is created.
https://eips.ethereum.org/EIPS/eip-181
https://eips.ethereum.org/EIPS/eip-190
A packaging standard should have the following positive effects on the ecosystem:
Smart contract packaging should also have a direct positive effect on the end user. Wallet software will be able to consume a released package and generate an interface for interacting with any deployed contracts included within that package. With the advent of ENS all of the pieces will be in place for a wallet to take a human readable name and present the user with an interface for interacting with the underlying application.
https://eips.ethereum.org/EIPS/eip-191
https://eips.ethereum.org/EIPS/eip-196
Note that while fixing these parameters might look like limiting the use-cases for zkSNARKs, the primitives are so basic that they can be combined in ways that are flexible enough so that it should even be possible to allow future advances in zkSNARK research without the need for a further hard fork.
https://eips.ethereum.org/EIPS/eip-197
https://eips.ethereum.org/EIPS/eip-198
https://eips.ethereum.org/EIPS/eip-205
When attempting to fetch an ABI based on an ENS name, implementers should first attempt an ABI lookup on the name itself. If that lookup returns no results, they should attempt a reverse lookup on the Ethereum address the name resolves to.
When attempting to fetch an ABI based on an ENS name, implementers should first attempt an ABI lookup on the name itself. If that lookup returns no results, they should attempt a reverse lookup on the Ethereum address the name resolves to.
Implementers should support as many of the ABI encoding formats as practical.
https://eips.ethereum.org/EIPS/eip-210
The EVM bytecode that the contract code should be set to is:
https://eips.ethereum.org/EIPS/eip-211
In some situations, it is vital for a function to be able to return data whose length cannot be anticipated before the call. In principle, this can be solved without alterations to the EVM, for example by splitting the call into two calls where the first is used to compute only the size. All of these mechanisms, though, are very expensive in at least some situations. A very useful example of such a worst-case situation is a generic forwarding contract; a contract that takes call data, potentially makes some checks and then forwards it as is to another contract. The return data should of course be transferred in a similar way to the original caller. Since the contract is generic and does not know about the contract it calls, there is no way to determine the size of the output without adapting the called contract accordingly or trying a logarithmic number of calls.
Note that the EVM implementation needs to keep the return data until the next call or the return from the current call. Since this resource was already paid for as part of the memory of the callee, it should not be a problem. Implementations may either choose to keep the full memory of the callee alive until the next call or copy only the return data to a special memory area.
https://eips.ethereum.org/EIPS/eip-214
https://eips.ethereum.org/EIPS/eip-225
Parity’s solution although not perfect, is nonetheless workable. I’d like to propose a longer term alternative solution, which is more involved, yet should be simple enough to allow rolling out in a reasonable amount of time.
The main design goals of the PoA protocol described here is that it should be very simple to implement and embed into any existing Ethereum client, while at the same time allow using existing sync technologies (fast, light, warp) without needing client developers to add custom logic to critical software.
Every epoch transition (genesis block included) acts as a stateless checkpoint, from which capable clients should be able to sync without requiring any previous state. This means epoch headers must not contain votes, all non settled votes are discarded, and tallying starts from scratch.
This list may be expired after a certain number of blocks / epochs, but it’s important to realize that “seeing” a proposal pass doesn’t mean it won’t get reorged, so it should not be immediately dropped when the proposal passes.
https://eips.ethereum.org/EIPS/eip-233
A Meta EIP should be created and merged as a Draft as soon as a new hard fork is planned.
This EIP should contain:
Once a timeline with key dates is agreed upon for other crucial dates. The basic outline of a hardfork timeline should include:
Anyone that wishes to propose a Core EIP for the hard fork should make a PR against the Meta EIP representing the hard fork. The EIP must be published as at least Draft. It enters the Proposed EIPs section, along with at least one person who is a point of contact for wanting to include the EIP.
The Meta EIP representing the hard fork should move in to the Accepted state once the changes are frozen (i.e. all referenced EIPs are in the Accepted state) and in to the Final state once the hard fork has been activated.
A meta EIP for coordinating the hard fork should help in visibility and traceability of the scope of changes as well as provide a simple name and/or number for referring to the proposed fork.
https://eips.ethereum.org/EIPS/eip-234
Add an option to JSON-RPC filter options (used by eth_newFilter and eth_getLogs) that allows specifying the block hash that should be included in the results. This option would be an alternative to fromBlock/toBlock options.
The only potential issue here is the fromBlock and toBlock fields. It wouldn’t make sense to include both the hash and the number so it seems like fromBlock/toBlock should be mutually exclusive with blockHash.
{ "jsonrpc": "2.0", "id": 1, "method": "eth_getLogs", params: [{"blockHash": "0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c"}] } should return all of the logs for the block with hash 0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c. If a topics field is added to the filter options then a filtered set of logs for that block should be returned. If no block exists with that hash then an error should be returned with a code of -32000, a message of "Block not found." and a data of "0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c".
{ "jsonrpc": "2.0", "id": 1, "method": "eth_getLogs", params: [{"blockHash": "0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c"}] } should return all of the logs for the block with hash 0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c. If a topics field is added to the filter options then a filtered set of logs for that block should be returned. If no block exists with that hash then an error should be returned with a code of -32000, a message of "Block not found." and a data of "0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c".
{ "jsonrpc": "2.0", "id": 1, "method": "eth_getLogs", params: [{"blockHash": "0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c"}] } should return all of the logs for the block with hash 0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c. If a topics field is added to the filter options then a filtered set of logs for that block should be returned. If no block exists with that hash then an error should be returned with a code of -32000, a message of "Block not found." and a data of "0xbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0cbl0c".
https://eips.ethereum.org/EIPS/eip-600
https://eips.ethereum.org/EIPS/eip-601
Software should prevent a creation of an account if a previous account does not have a transaction history (meaning its address has not been used before).
https://eips.ethereum.org/EIPS/eip-606
https://eips.ethereum.org/EIPS/eip-607
https://eips.ethereum.org/EIPS/eip-608
https://eips.ethereum.org/EIPS/eip-609
https://eips.ethereum.org/EIPS/eip-615
All of the instructions are O(1) with a small constant, requiring just a few machine operations each, whereas a JUMP or JUMPI typically does an O(log n) binary search of an array of JUMPDEST offsets before every jump. With the cost of JUMPI being high and the cost of JUMP being mid, we suggest the cost of JUMPV and JUMPSUBV should be mid, JUMPSUB and JUMPIF should be low, andJUMPTO and the rest should be verylow. Measurement will tell.
All of the instructions are O(1) with a small constant, requiring just a few machine operations each, whereas a JUMP or JUMPI typically does an O(log n) binary search of an array of JUMPDEST offsets before every jump. With the cost of JUMPI being high and the cost of JUMP being mid, we suggest the cost of JUMPV and JUMPSUBV should be mid, JUMPSUB and JUMPIF should be low, andJUMPTO and the rest should be verylow. Measurement will tell.
All of the instructions are O(1) with a small constant, requiring just a few machine operations each, whereas a JUMP or JUMPI typically does an O(log n) binary search of an array of JUMPDEST offsets before every jump. With the cost of JUMPI being high and the cost of JUMP being mid, we suggest the cost of JUMPV and JUMPSUBV should be mid, JUMPSUB and JUMPIF should be low, andJUMPTO and the rest should be verylow. Measurement will tell.
https://eips.ethereum.org/EIPS/eip-616
https://eips.ethereum.org/EIPS/eip-627
This EIP describes the format of Whisper messages within the ÐΞVp2p Wire Protocol.
This EIP should substitute the existing specification.
More detailed documentation on Whisper could be found here.
All Whisper messages sent as ÐΞVp2p Wire Protocol packets should be RLP-encoded arrays of data containing two objects: integer packet code followed by another object (whose type depends on the packet code).
If Whisper node does not support a particular packet code, it should just ignore the packet without generating any error.
The Whisper sub-protocol should support the following packet codes:
Status message should be sent after the initial handshake and prior to any other messages.
This packet is used by Whisper nodes for dynamic adjustment of their individual PoW requirements. Recipient of this message should no longer deliver the sender messages with PoW lower than specified in this message.
Those unable to decrypt the message data are also unable to access the signature. The signature, if provided, is the ECDSA signature of the Keccak-256 hash of the unencrypted data using the secret key of the originator identity. The signature is serialised as the concatenation of the R, S and V parameters of the SECP-256k1 ECDSA signature, in that order. R and S are both big-endian encoded, fixed-width 256-bit unsigned. V is an 8-bit big-endian encoded, non-normalised and should be either 27 or 28.
The padding field was introduced in order to align the message size, since message size alone might reveal important metainformation. Padding can be arbitrary size. However, it is recommended that the size of Data Field (excuding the Salt) before encryption (i.e. plain text) should be factor of 256 bytes.
This EIP is compatible with Whisper version 6. Any client which does not implement certain packet codes should gracefully ignore the packets with those codes. This will ensure the forward compatibility.
https://eips.ethereum.org/EIPS/eip-634
https://eips.ethereum.org/EIPS/eip-649
The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another one and a half years. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards. The difficulty bomb has been known about for a long time and now it’s going to stop from happening. In order to maintain stability of the system, a block reward reduction that offsets the ice age delay would leave the system in the same general state as before. Reducing the reward also decreases the likelihood of a miner driven chain split as Ethereum approaches proof-of-stake.
This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It’s suggested to include this EIP in the first of the two Metropolis hard-forks, the Byzantium fork.
https://eips.ethereum.org/EIPS/eip-658
https://eips.ethereum.org/EIPS/eip-663
https://eips.ethereum.org/EIPS/eip-665
ECRECOVER has a gas cost of 3000. Since Ed25519 is computationally cheaper, the gas price should be less.
As the proposed precompiled contract is deployed at a reserved (<255) and previously unused address, an implementation of the proposal should not introduce any backward compatibility issues.
https://eips.ethereum.org/EIPS/eip-681
If using ENS names instead of hexadecimal addresses, the resolution is up to the payer, at any time between receiving the URL and sending the transaction. Hexadecimal addresses always take precedence over ENS names, i. e. even if there exists a matching ENS name consisting of 0x followed by 40 hexadecimal digits, it should never be resolved. Instead, the hexadecimal address should be used directly.
If using ENS names instead of hexadecimal addresses, the resolution is up to the payer, at any time between receiving the URL and sending the transaction. Hexadecimal addresses always take precedence over ENS names, i. e. even if there exists a matching ENS name consisting of 0x followed by 40 hexadecimal digits, it should never be resolved. Instead, the hexadecimal address should be used directly.
Note that the indicated amount is only a suggestion (as are all the supplied arguments) which the user is free to change. With no indicated amount, the user should be prompted to enter the amount to be paid.
The proposed format is chosen to resemble bitcoin: URLs as closely as possible, as both users and application programmers are already familiar with that format. In particular, this motivated the omission of the unit, which is often used in Ethereum ecosystem. Handling different orders of magnitude is facilitated by the exponent so that amount values can be expressed in their nominal units, just like in the case of bitcoin:. The use of scientific notation is strongly encouraged when expressing monetary value in ether or ERC-20 tokens. For better human readability, the exponent should be the decimal value of the nominal unit: 18 for ether or the value returned by decimals() of the token contract for ERC-20 tokens. Additional parameters may be added, if popular use cases requiring them emerge in practice.
Since irreversible transactions can be initiated with parameters from such URLs, the integrity and authenticity of these URLs are of great importance.
In particular, changing either the recipient address or the amount transferred can be a profitable attack. Users should only use URLs received from authenticated sources with adequate integrity protection.
In order to make sure that the amount transacted is the same as the amount intended, the amount communicated to the human user should be easily verifiable by inspection, including the order of magnitude. In case of ERC-20 token payments, if the payer client has access to the blockchain or some other trusted source of information about the token contract, the interface should display the amount in the units specified in the token contract. Otherwise, it should be displayed as expressed in the URL, possibly alerting the user to the uncertainty of the nominal unit. To facilitate human inspection of the amount, the use of scientific notation with an exponent corresponding to the nominal unit of the transacted token (e.g. 18 in case of ether) is advisable.
In order to make sure that the amount transacted is the same as the amount intended, the amount communicated to the human user should be easily verifiable by inspection, including the order of magnitude. In case of ERC-20 token payments, if the payer client has access to the blockchain or some other trusted source of information about the token contract, the interface should display the amount in the units specified in the token contract. Otherwise, it should be displayed as expressed in the URL, possibly alerting the user to the uncertainty of the nominal unit. To facilitate human inspection of the amount, the use of scientific notation with an exponent corresponding to the nominal unit of the transacted token (e.g. 18 in case of ether) is advisable.
In order to make sure that the amount transacted is the same as the amount intended, the amount communicated to the human user should be easily verifiable by inspection, including the order of magnitude. In case of ERC-20 token payments, if the payer client has access to the blockchain or some other trusted source of information about the token contract, the interface should display the amount in the units specified in the token contract. Otherwise, it should be displayed as expressed in the URL, possibly alerting the user to the uncertainty of the nominal unit. To facilitate human inspection of the amount, the use of scientific notation with an exponent corresponding to the nominal unit of the transacted token (e.g. 18 in case of ether) is advisable.
https://eips.ethereum.org/EIPS/eip-689
https://eips.ethereum.org/EIPS/eip-695
The eth_chainId method should return a single STRING result
for an integer value in hexadecimal format, describing the
currently configured CHAIN_ID value used for signing replay-protected transactions,
introduced by EIP-155.
The chain ID returned should always correspond to the information in the current known
head block. This ensures that caller of this RPC method can always use the retrieved
information to sign transactions built on top of the head.
If the current known head block does not specify a chain ID, the client should treat any
calls to eth_chainId as though the method were not supported, and return a suitable
error.
Consumers should prefer eth_chainId over net_version, so that they can reliably identify chain they are communicating with.
Implementers should take care to implement eth_chainId correctly and promote its use, since the chain ID is critical in replay attack prevention as described in EIP-155, and consumers will rely on it to identify the chain they are communicating with.
https://eips.ethereum.org/EIPS/eip-698
After block n all clients should process opcode 0x46 as follows:
Implementation should occur as part of a coordinated hardfork.
https://eips.ethereum.org/EIPS/eip-706
This proposal is fully backward compatible. Clients upgrading to the proposed DEVp2p protocol version 5 should still support skipping the compression step for connections that only advertise version 4 of the DEVp2p protocol.
There is more than one valid encoding of any given input, and there is more than one good internal compression algorithm within Snappy when trading off throughput for output size. As such, different implementations might produce slight variations in the compressed form, but all should be cross compatible between each other.
https://eips.ethereum.org/EIPS/eip-712
A good hashing algorithm should satisfy security properties such as determinism, second pre-image resistance and collision resistance. The keccak256 function satisfies the above criteria when applied to bytestrings. If we want to apply it to other sets we first need to map this set to bytestrings. It is critically important that this encoding function is deterministic and injective. If it is not deterministic then the hash might differ from the moment of signing to the moment of verifying, causing the signature to incorrectly be rejected. If it is not injective then there are two different elements in our input set that hash to the same value, causing a signature to be valid for a different unrelated message.
Future extensions to this standard can add new fields with new user-agent behaviour constraints. User-agents are free to use the provided information to inform/warn users or refuse signing. Dapp implementers should not add private fields, new fields should be proposed through the EIP process.
Future extensions to this standard can add new fields with new user-agent behaviour constraints. User-agents are free to use the provided information to inform/warn users or refuse signing. Dapp implementers should not add private fields, new fields should be proposed through the EIP process.
The EIP712Domain fields should be the order as above, skipping any absent fields. Future field additions must be in alphabetical order and come after the above fields. User-agents should accept fields in any order as specified by the EIPT712Domain type.
The EIP712Domain fields should be the order as above, skipping any absent fields. Future field additions must be in alphabetical order and come after the above fields. User-agents should accept fields in any order as specified by the EIPT712Domain type.
There also should be a corresponding personal_signTypedData method which accepts the password for an account as the last argument.
The domain separator prevents collision of otherwise identical structures. It is possible that two DApps come up with an identical structure like Transfer(address from,address to,uint256 amount) that should not be compatible. By introducing a domain separator the DApp developers are guaranteed that there can be no signature collision.
Alternative 3: ABIv2 function signatures modified to be 256-bit. While this captures type info, it does not capture any of the semantics other than the function. This is already causing a practical collision between EIP-20’s and EIP-721’s transfer(address,uint256), where in the former the uint256 refers to an amount and the latter to a unique id. In general ABIv2 favors compatibility where a hashing standard should prefer incompatibility.
Alternative 7: ABIv2 encoding. Especially with the upcoming abi.encode it should be easy to use abi.encode as the encodeData function. The ABIv2 standard by itself fails the determinism security criteria. There are several valid ABIv2 encodings of the same data. ABIv2 does not allow in-place computation.
The RPC calls, web3 methods and SomeStruct.typeHash parameter are currently undefined. Defining them should not affect the behaviour of existing DApps.
The Solidity expression keccak256(someInstance) for an instance someInstance of a struct type SomeStruct is valid syntax. It currently evaluates to the keccak256 hash of the memory address of the instance. This behaviour should be considered dangerous. In some scenarios it will appear to work correctly but in others it will fail determinism and/or injectiveness. DApps that depend on the current behaviour should be considered dangerously broken.
The Solidity expression keccak256(someInstance) for an instance someInstance of a struct type SomeStruct is valid syntax. It currently evaluates to the keccak256 hash of the memory address of the instance. This behaviour should be considered dangerous. In some scenarios it will appear to work correctly but in others it will fail determinism and/or injectiveness. DApps that depend on the current behaviour should be considered dangerously broken.
This standard is only about signing messages and verifying signatures. In many practical applications, signed messages are used to authorize an action, for example an exchange of tokens. It is very important that implementers make sure the application behaves correctly when it sees the same signed message twice. For example, the repeated message should be rejected or the authorized action should be idempotent. How this is implemented is specific to the application and out of scope for this standard.
This standard is only about signing messages and verifying signatures. In many practical applications, signed messages are used to authorize an action, for example an exchange of tokens. It is very important that implementers make sure the application behaves correctly when it sees the same signed message twice. For example, the repeated message should be rejected or the authorized action should be idempotent. How this is implemented is specific to the application and out of scope for this standard.
The mechanism for reliably broadcasting a signature is application-specific and out of scope for this standard. When the signature is broadcast to a blockchain for use in a contract, the application has to be secure against frontrunning attacks. In this kind of attack, an attacker intercepts the signature and submits it to the contract before the original intended use takes place. The application should behave correctly when the signature is submitted first by an attacker, for example by rejecting it or simply producing exactly the same effect as intended by the signer.
https://eips.ethereum.org/EIPS/eip-721
https://eips.ethereum.org/EIPS/eip-725
This contract is controlled by an owner. The owner can be a smart contract or an external account.
This standard requires ERC173 and should implement the functions:
Data keys, should be the keccak256 hash of a type name.
e.g. keccak256('ERCXXXMyNewKeyType') is 0x6935a24ea384927f250ee0b954ed498cd9203fc5d2bf95c735e52e6ca675e047
The ERC725JSONSchema standard defines how keys should be named and generated.
This JSON schema can be used to auto decode ERC725Y values from smart contracts for application and smart contract interactions.
https://eips.ethereum.org/EIPS/eip-747
The meaning of “added to the user’s wallet” is dependent on the wallet implementation.
A successful call to wallet_watchAsset should indicate that the specified asset became (or already was) included in some list of assets in the user’s wallet, that the user can view and possibly interact with in the wallet UI.
The only strictly required fields are type, options, and options.address.
This interface can and should be extended depending on the asset type.
The type string should be the commonly accepted name of the interface implemented by the asset’s contract, e.g. ERC20.
The image string should be a URL to a common image format (e.g. png, jpg, or svg) or a Base64 image.
The image itself should be no larger than 512x512 pixels, and no larger than 256kb.
Implementers may edit these limits as necessary.
The image string should be a URL to a common image format (e.g. png, jpg, or svg) or a Base64 image.
The image itself should be no larger than 512x512 pixels, and no larger than 256kb.
Implementers may edit these limits as necessary.
As there are several types of different assets, this method has to provide support for each of them in a separate way.
If it doesn’t, it should give a response according to that.
Upon calling this request, the user should be prompted with the opportunity to add this token to their wallet:
Upon calling this request, the user should be prompted with the opportunity to add this token to their wallet:
If the user adds this token, it should appear somewhere in their wallet’s UI, with its balance, etc.
As a result of the addition or not of the asset a Promise should be returned, indicating if the user added the asset or an error if some parameter is not valid.
If the wallet does not support the specified asset type, the error should indicate this with the message:
https://eips.ethereum.org/EIPS/eip-758
When a new transaction is submitted successfully to an Ethereum node, the node responds with the transaction’s hash. If the transaction involved the execution of a contract function that returns data, the data is discarded. If the return data is state-dependent, which is common, there is no straightforward way for the caller to access or compute the return data. This EIP proposes that callers should be able to subscribe to (or poll for) completed transactions. The Ethereum node sends the return data to the caller when the transactions are sealed.
https://eips.ethereum.org/EIPS/eip-777
https://eips.ethereum.org/EIPS/eip-778
Another goal of the new format is to provide authoritative updates of connectivity
information. If a node changes its endpoint and publishes a new record, other nodes should
be able to determine which record is newer.
All keys except id are optional, including IP addresses and ports. A record without
endpoint information is still valid as long as its signature is valid. If no tcp6 /
udp6 port is provided, the tcp / udp port applies to both IP addresses. Declaring
the same port number in both tcp, tcp6 or udp, udp6 should be avoided but doesn’t
render the record invalid.
The canonical encoding of a node record is an RLP list of [signature, seq, k, v, ...].
The maximum encoded size of a node record is 300 bytes. Implementations should reject
records larger than this size.
The textual form of a node record is the base64 encoding of its RLP representation,
prefixed by enr:. Implementations should use the URL-safe base64 alphabet
and omit padding characters.
https://eips.ethereum.org/EIPS/eip-779
https://eips.ethereum.org/EIPS/eip-801
https://eips.ethereum.org/EIPS/eip-820
If the interface is part of an approved ERC, it MUST be named ERC###XXXXX where ### is the number of the ERC and XXXXX should be the name of the interface in CamelCase. The meaning of this interface SHOULD be defined in the specified ERC.
https://eips.ethereum.org/EIPS/eip-823
This function is called by the intermediate exchange service contract. This function should add _amount tokens of the target contract to the exchangers address for exchange to be completed successfully.
This function is called by the intermediate exchange service contract. This function should add _amount tokens of the target contract to the exchangers address and transfer it to the _to address for the exchange and expenditure to be completed successfully.
This proposal is fully backward compatible. Tokens extended by this proposal should also be following ERC20 standard. The functionality of ERC20 standard should not be affected by this proposal but will provide additional functionality to it.
This proposal is fully backward compatible. Tokens extended by this proposal should also be following ERC20 standard. The functionality of ERC20 standard should not be affected by this proposal but will provide additional functionality to it.
https://eips.ethereum.org/EIPS/eip-831
The need for this ERC emerged when refining EIP-681. We need a container that does not carry the weight of the use-cases. EIP-67 was the first attempt on defining Ethereum-URIs. This ERC tries to keep backward compatibility and not break existing things. This means EIP-67 URIs should still be valid and readable. Only if the prefix feature is used, EIP-67 parsers might break. No way was seen to avoid this and innovate on the same time. This is also the reason this open prefix approach was chosen to being able to adopt to future use-cases and not block the whole “ethereum:” scheme for a limited set of use-cases that existed at the time of writing this.
https://eips.ethereum.org/EIPS/eip-858
The current public Ethereum network has a hashrate of 296 TH/s. This hashrate corresponds to a power usage of roughly 1 TW and yearly energy consumption of 8.8 TWh (roughly 0.04% of total global electricity consumption). A future switch to full Proof of Stake will solve this issue entirely. Yet that switch remains enough in the future that action should be taken in the interim to limit excess harmful side affects of the present network.
https://eips.ethereum.org/EIPS/eip-867
Each ERP should contain the following items:
Considerable example (concise, includes supporting evidence, no negative impact):
A crowdsale run by XYZ incorrectly published the testnet address of their crowdsale contract to their public website at the start of their crowdsale on Jan 19, 2018. 501 ETH was sent by 328 users on the mainnet to the incorrect address between block 4,235,987 and 4,236,050. See here for the testnet contract, and see here for the transactions to the same address on the mainnet. See here for a statement made by XYZ on their website. Because there is a contract at this address on the testnet and the corresponding nonce for the creator address has already been used on the mainnet, it is considered effectively impossible that anyone coincidentally holds the private key. We have verified that all transactions came from addresses with no associated code, so there should be no issue returning eth to the senders.
A machine-readable script that outputs a single State Change Object. This script should be implemented so that it is easily audited by a reviewer. Verification scripts should be javascript files that may use the web3.js library.
A machine-readable script that outputs a single State Change Object. This script should be implemented so that it is easily audited by a reviewer. Verification scripts should be javascript files that may use the web3.js library.
The purpose of the ERP Verification script is to unambiguously specify (through code) the criteria used to compute the set of State Change Actions. The script’s output, as described above, will be the input used by all Ethereum clients. Client teams should avoid manually pre-processing the artifact or using the artifact to simply guide changes in the code. Instead, the artifact should be bundled with the client and processed directly by the client at the specified block. This will minimize the amount of client effort required for each ERP and help to ensure compatibility between clients. We anticipate that some ERP Verification scripts may be trivial, but we recommend their inclusion for consistency.
The purpose of the ERP Verification script is to unambiguously specify (through code) the criteria used to compute the set of State Change Actions. The script’s output, as described above, will be the input used by all Ethereum clients. Client teams should avoid manually pre-processing the artifact or using the artifact to simply guide changes in the code. Instead, the artifact should be bundled with the client and processed directly by the client at the specified block. This will minimize the amount of client effort required for each ERP and help to ensure compatibility between clients. We anticipate that some ERP Verification scripts may be trivial, but we recommend their inclusion for consistency.
A State Change action is a JSON object that includes a “type” field and a set of “data” fields, where the contents of the data fields are dependent on the type and must follow the schema defined for that type. This allows clients to support a limited set of operations initially and add more based on a subsequent EIP if needed. Support for the following action types should be implemented by clients upon adoption of this EIP:
For the storeCode operation, it should include the proposed contract source (e.g. Solidity) as well as the other details required such that a reviewer can compile the source and generate the same bytecode. It should also include the source that was originally stored at that address, if possible/applicable. If the two contracts are not identical, changes should be noted. If they are identical, the author should indicate why no changes are necessary (this is unlikely). Additionally, any relevant reviews, audits, and test cases should be included to the extent that they address the issues encountered with the original contract.
For the storeCode operation, it should include the proposed contract source (e.g. Solidity) as well as the other details required such that a reviewer can compile the source and generate the same bytecode. It should also include the source that was originally stored at that address, if possible/applicable. If the two contracts are not identical, changes should be noted. If they are identical, the author should indicate why no changes are necessary (this is unlikely). Additionally, any relevant reviews, audits, and test cases should be included to the extent that they address the issues encountered with the original contract.
For the storeCode operation, it should include the proposed contract source (e.g. Solidity) as well as the other details required such that a reviewer can compile the source and generate the same bytecode. It should also include the source that was originally stored at that address, if possible/applicable. If the two contracts are not identical, changes should be noted. If they are identical, the author should indicate why no changes are necessary (this is unlikely). Additionally, any relevant reviews, audits, and test cases should be included to the extent that they address the issues encountered with the original contract.
For the storeCode operation, it should include the proposed contract source (e.g. Solidity) as well as the other details required such that a reviewer can compile the source and generate the same bytecode. It should also include the source that was originally stored at that address, if possible/applicable. If the two contracts are not identical, changes should be noted. If they are identical, the author should indicate why no changes are necessary (this is unlikely). Additionally, any relevant reviews, audits, and test cases should be included to the extent that they address the issues encountered with the original contract.
For the storeCode operation, it should include the proposed contract source (e.g. Solidity) as well as the other details required such that a reviewer can compile the source and generate the same bytecode. It should also include the source that was originally stored at that address, if possible/applicable. If the two contracts are not identical, changes should be noted. If they are identical, the author should indicate why no changes are necessary (this is unlikely). Additionally, any relevant reviews, audits, and test cases should be included to the extent that they address the issues encountered with the original contract.
Clients that choose to adopt the proposal outlined in this EIP will implement a module that scans a designated directory for SCO files (each time the client process launches) to construct a mapping between target blocks and SCO file names. When starting work on a new block, clients should first consult the set of SCO target blocks discovered and determine if there are any recovery actions required for the current block.
The applyRecoveryActions method must apply the recovery actions in the same order as they are stored in the SCO file. Clients are responsible for ensuring that no State Change Action will result in an account transferring an amount that is greater than its current balance. The toAddress for both weiTransfer and storeCode should always be a valid address (i.e. never 0x0).
Additionally, each block affected by an ERP should include extra data to indicate that the state change occurred. The extra data included in the block should be the erpId found in the SCO file, converted to hex (i.e. hexStringToBytes(asciiToHex(erpId))). Clients should also validate that the expected header appears in the target block if the block is received from a peer.
Additionally, each block affected by an ERP should include extra data to indicate that the state change occurred. The extra data included in the block should be the erpId found in the SCO file, converted to hex (i.e. hexStringToBytes(asciiToHex(erpId))). Clients should also validate that the expected header appears in the target block if the block is received from a peer.
Additionally, each block affected by an ERP should include extra data to indicate that the state change occurred. The extra data included in the block should be the erpId found in the SCO file, converted to hex (i.e. hexStringToBytes(asciiToHex(erpId))). Clients should also validate that the expected header appears in the target block if the block is received from a peer.
The ERP should link to pull requests for each client repository, and these pull requests should link back to the ERP and also contain its EIP preamble and summary.
The ERP should link to pull requests for each client repository, and these pull requests should link back to the ERP and also contain its EIP preamble and summary.
Each PR associated with an ERP should consist of a single file (the SCO file) added to the client’s designated SCO directory. No additional client code should be required.
Each PR associated with an ERP should consist of a single file (the SCO file) added to the client’s designated SCO directory. No additional client code should be required.
https://eips.ethereum.org/EIPS/eip-868
Implementations of Node Discovery Protocol v4 should support two new packet types, a
request and reply of the node record. The existing ping and pong packets are extended with
a new field containing the sequence number of the ENR.
When a packet of this type is received, the node should reply with an ENRResponse packet
containing the current version of its record.
To guard against amplification attacks, the sender of ENRRequest should have replied to a
ping packet recently (just like for FindNode). The expiration field, a UNIX timestamp,
should be handled as for all other existing packets i.e. no reply should be sent if it
refers to a time in the past.
To guard against amplification attacks, the sender of ENRRequest should have replied to a
ping packet recently (just like for FindNode). The expiration field, a UNIX timestamp,
should be handled as for all other existing packets i.e. no reply should be sent if it
refers to a time in the past.
To guard against amplification attacks, the sender of ENRRequest should have replied to a
ping packet recently (just like for FindNode). The expiration field, a UNIX timestamp,
should be handled as for all other existing packets i.e. no reply should be sent if it
refers to a time in the past.
The recipient of the packet should verify that the node record is signed by node who sent
ENRResponse.
https://eips.ethereum.org/EIPS/eip-875
Returns a short string of the symbol of the in-fungible token, this should be short and generic as each token is non-fungible.
Returns the total amount of tokens in the given contract, this should be optional as assets might be allocated and issued on the fly. This means that supply is not always fixed.
Returns the owner of a particular token, I think this should be optional as not every token contract will need to track the owner of a unique token and it costs gas to loop and map the token id owners each time the balances change.
This opens up the gates for a p2p atomic swap but should be optional to this standard as some may not have use for it.
https://eips.ethereum.org/EIPS/eip-884
Implementers should maintain an off-chain private database that records the owner’s name, residential address, and Ethereum address. The implementer must then be able to extract the name and address for any address, and hash the name + address data and compare that hash to the hash recorded in the contract using the hasHash function. The specific details of this system are left to the implementer.
https://eips.ethereum.org/EIPS/eip-897
https://eips.ethereum.org/EIPS/eip-900
https://eips.ethereum.org/EIPS/eip-902
https://eips.ethereum.org/EIPS/eip-908
Implementing this as a layer 2 solution may not ensure the sustainability of the protocol, since not everyone would use it; if the protocol doesn’t have any cost for full nodes to validate transactions, then people will take advantage of that and not use the layer 2 solution. It seems that you should at least have the part where the reward is provided in protocol, but then that and the user agent signature doesn’t really add anything else to the protocol, so doing some part in-protocol and some part e.g. the verification or a verification-game off-protocol could be done, but it’s already done in protocol. Note also that some computationally expensive tasks are too challenging to feasibly do in protocol, e.g. due to not fitting in the gas limit, could be done with Truebit, where verifiers have an incentive.
A miner could create a client and fill their block with transactions that only contain the PREV_BLOCK_VERIF opcode (or alternatively, arbitrarily complex transactions, still with the opcode), with previous blockhashes that they have validated and the address of their client. To prevent this, state would have to store a list containing lists, with each sublist listing the blockhashes up to 400 blocks ago that correspond to a miner, then a miner (or a proposer under Casper CBC) could have to put down a deposit, and be slashed if the proposer inserts such a transaction (that contains a blockhash which they have already proposed, not just in a block but at any time previously). Updating the state to remove blockhashes more than 400 blocks ago would add additional overhead, although you could add an extra window for older blocks, say 120,000 blocks (roughly every 3 weeks), still ignore blocks that are older than 400 blocks ago, and remove these older 120,000 blocks every 120,000 blocks. An attacker could bribe a miner/proposer to include transactions like above that contain an address of a client in the access list which they own. However, the above slashing condition should disincentivize this.
Additionally, it should help with being only able to read the client’s address from the client, and the whole transaction could revert if the address is not in the access list. You could provide the index of the address in the access list, and then you could assert that the address found at that index matches that which can be read by the client (where the latter would be a read-only address).
As of May 4 2018, there are 16428 nodes. Assume that an annual cost for an average client developer organisation is $1 million per annum. Projecting forward (and noting that the number of nodes should increase substantially if this EIP was implemented, thus aiding Ethereum’s goal of decentralizing everything) assume that there are 10 clients. Thus let us assume that the number of nodes doubles to 30000 nodes within 5 years (this assumption is probably conservative, even if it is forward looking). Assume for simplicity that the costs of a client are entirely covered by this block reward.
And as for the absolute amounts, this will require data analysis, but clearly a full node should receive much less than a miner for processing a transaction in a block, since there are many transactions in a block, and there are many confirmations of a block. Data analysis could involve calculating the average number of full nodes verifying transactions in a block. Macroeconomic analysis could entail the economic security benefit that full nodes provide to the network.
Note that while further quantitative analysis to specify fees should be done, some level of experimentation after implementing this method on-chain may be necessary.
All of the below struck out information should be prevented via using an access list and verifying that the read-only address provided by the client matches with an address in the access list, as well as using a layer 2 solution such as a PoA network for censhorship resistance and minimization of centralization in the access list.
https://eips.ethereum.org/EIPS/eip-918
The current mining difficulty which should be adjusted via the _adjustDifficulty minting phase
The ERC918 Mineable Mint Packet Metadata should be prepared using following schema:
https://eips.ethereum.org/EIPS/eip-926
https://eips.ethereum.org/EIPS/eip-927
https://eips.ethereum.org/EIPS/eip-969
fnv as utilized in DAG-item creation should remain unchanged.
Due to compatibility concerns with implementations that already add additional
parameters to GetWork, it is desired to add BlockNumber as an explicit 4th parameter
as suggested in https://github.com/ethereum/go-ethereum/issues/2333. Algorithm
should then be returned as either "ethash" or "ethashV2" according to the
block.number >= ASIC_MITIGATION_FORK_BLKNUM criteria.
Our approach should balance the inherent security risks involved with changing
the mining algorithm with the risk that the change we make does not break existing
ASIC miners. This EIP leans towards minimizing the security risks by making minimal
changes to the algorithm, accepting the risk that the change may not break dedicated
hardware miners that utilize partially- or fully-configurable logic.
Typical ASIC synthesis tools would optimize multiplication of a constant
in the FNV algorithm, while reducing the area needed for the multiplier according
to the hamming weight of the constant. To reduce the chance of ASIC adaptation
through minor mask changes, we propose choosing new constants with a larger
hamming weight, however care should be taken not to choose constants with too
large of a weight.
https://eips.ethereum.org/EIPS/eip-998
But understand that the real call to rootOwnerOfChild should be made with assembly so that the code can check if the call failed and so that the staticcall opcode is used to ensure that no state is modified.
https://eips.ethereum.org/EIPS/eip-999
https://eips.ethereum.org/EIPS/eip-1010
https://eips.ethereum.org/EIPS/eip-1011
The EVM bytecode that the contract should be set to is:
The EVM bytecode that the contract should be set to is:
The EVM bytecode that the contract should be set to is:
Clients should be implemented with the following configurable settings:
This setting should ship as default disabled in client versions during the initial casper fork. This setting should ship as default enabled in subsequent client versions.
This setting should ship as default disabled in client versions during the initial casper fork. This setting should ship as default enabled in subsequent client versions.
The suggested default value that clients should ship with is at least 2e23 wei (200K ETH).
The setting should default to disabled.
The casper contract also provides a helper method slashable(vote_msg_1, vote_msg_2) to check if two votes violate a slashing condition. Clients should use the above pseudocode in combination with casper.slashable() as a final check when deciding whether to submit a slash to the contract.
This setting is to be used by new clients that are syncing the network for the first time. Due to weak subjectivity, a blockhash should be supplied to successfully sync the network when initially starting a node.
This setting is suggested default disabled because the block producer will almost certainly frontrun anyone else submitting a slash transaction. To prevent every client on the network from submitting a slash transaction in the event of a slashing condition, this setting should only be enabled by block producers and those clients who explicitly choose to monitor votes.
This EIP is not forward compatible and introduces backwards incompatibilities in the state, fork choice rule, block reward, transaction validity, and gas calculations on certain transactions. Therefore, all changes should be included in a scheduled hardfork at HYBRID_CASPER_FORK_BLKNUM.
https://eips.ethereum.org/EIPS/eip-1013
https://eips.ethereum.org/EIPS/eip-1014
It should also be noted that SELFDESTRUCT (0xff) has no immediate effect on nonce or code, thus a contract cannot be destroyed and recreated within one transaction.
https://eips.ethereum.org/EIPS/eip-1015
This EIP changes the block reward step by instead of setting it to be hard coded on the clients and to be given to the miner/validator etherbase, it should instead go to an address decided by an on-chain contract, with hard limits on how it would be issued (six month lock-in; issuance can only decrease or be maintained, but not increase;). A decision method is suggested but not essential to the notion of this EIP. This would not be a generic governance solution, which is a much broader and harder topic, would not affect technical upgrade decisions or other hard forks, but seen as a forum to attempt to prevent contentious hard forks that can be solved with the issuance.
It’s not meant to be a general governance contract. The contract should NOT be used to to decide software updates, to freeze funds, change contracts balances or anything on the consensus layer other than the strict definition of where block rewards go. It should be seen as a platform to settle disputes to avoid the implementation of contentious hard forks, not as a mean to remove the power of users and developers to execute them.
It’s not meant to be a general governance contract. The contract should NOT be used to to decide software updates, to freeze funds, change contracts balances or anything on the consensus layer other than the strict definition of where block rewards go. It should be seen as a platform to settle disputes to avoid the implementation of contentious hard forks, not as a mean to remove the power of users and developers to execute them.
There’s a single target contract that should ether issued to. At each new block, that contract would have the default function called so it would forward to the intended addresses.
The decision would be made by multiple signalling contracts, each one implemented by separate groups and representing one aspect of the community or one sort of measurement. Each signaling process would have a int bound in which they could vote and they would have their own internal process to decide that. As new governance methods are tested and debated, new signalling contracts should be added and removed. Suggested signalling contracts:
https://eips.ethereum.org/EIPS/eip-1046
The token’s name() and symbol() getters should be preferred over the name and/or symbol properties in the tokenURI JSON.
https://eips.ethereum.org/EIPS/eip-1051
https://eips.ethereum.org/EIPS/eip-1052
https://eips.ethereum.org/EIPS/eip-1056
As we have been developing identity systems for the last couple of years at uPort it has become apparent that the cost of identity creation is a large issue. The previous Identity proposal ERC-725 faces this exact issue. Our requirements when creating this ERC is that identity creation should be free, and should be possible to do in an offline environment (e.g. refugee scenario). However it must also be possible to rotate keys without changing the primary identifier of the identity. The identity system should be fit to use off-chain as well as on-chain.
As we have been developing identity systems for the last couple of years at uPort it has become apparent that the cost of identity creation is a large issue. The previous Identity proposal ERC-725 faces this exact issue. Our requirements when creating this ERC is that identity creation should be free, and should be possible to do in an offline environment (e.g. refugee scenario). However it must also be possible to rotate keys without changing the primary identifier of the identity. The identity system should be fit to use off-chain as well as on-chain.
As we have been developing identity systems for the last couple of years at uPort it has become apparent that the cost of identity creation is a large issue. The previous Identity proposal ERC-725 faces this exact issue. Our requirements when creating this ERC is that identity creation should be free, and should be possible to do in an offline environment (e.g. refugee scenario). However it must also be possible to rotate keys without changing the primary identifier of the identity. The identity system should be fit to use off-chain as well as on-chain.
The primary owner key should be looked up using identityOwner(identity). This should be the first of the publicKeys listed. Iterate through the DIDDelegateChanged events to build a list of additional keys and authentication sections as needed. The list of delegateTypes to include is still to be determined. Iterate through DIDAttributeChanged events for service entries, encryption public keys and other public names. The attribute names are still to be determined.
The primary owner key should be looked up using identityOwner(identity). This should be the first of the publicKeys listed. Iterate through the DIDDelegateChanged events to build a list of additional keys and authentication sections as needed. The list of delegateTypes to include is still to be determined. Iterate through DIDAttributeChanged events for service entries, encryption public keys and other public names. The attribute names are still to be determined.
https://eips.ethereum.org/EIPS/eip-1057
The design goal of ProgPoW is to have the algorithm’s requirements match what is available on commodity GPUs: If the algorithm were to be implemented on a custom ASIC there should be little opportunity for efficiency gains compared to a commodity GPU.
Sample code is written in C++, this should be kept in mind when evaluating the code in the specification.
All numerics are computed using unsigned 32 bit integers. Any overflows are trimmed off before proceeding to the next computation. Languages that use numerics not fixed to bit lengths (such as Python and JavaScript) or that only use signed integers (such as Java) will need to keep their languages’ quirks in mind. The extensive use of 32 bit data values aligns with modern GPUs internal data architectures.
https://eips.ethereum.org/EIPS/eip-1062
https://eips.ethereum.org/EIPS/eip-1066
Developers should not be required to memorize 256 codes. However, they break nicely into a table. Cognitive load is lowered by organizing the table into categories and reasons. 0x10 and 0x11 belong to the same category, and 0x04 shares a reason with 0x24
https://eips.ethereum.org/EIPS/eip-1077
If multiple signatures are required, then all signatures should then be ordered by account and the account contract should implement signatures checks locally (JUMP) on EIP-1271 interface which might forward (STATIC_CALL) the EIP-1271 signature check to owner contract.
If multiple signatures are required, then all signatures should then be ordered by account and the account contract should implement signatures checks locally (JUMP) on EIP-1271 interface which might forward (STATIC_CALL) the EIP-1271 signature check to owner contract.
If the executed transaction fails internally, nonces should still be updated and gas needs to be paid.
Deployers of transactions (relayers) should be able to call untrusted contracts, which provides no guarantees that the contract they are interacting with correctly implements the standard and they will be reimbursed for gas. To prevent being fooled by bad implementations, relayers must estimate the outcome of a transaction, and only include/sign transactions which have a desired outcome.
https://eips.ethereum.org/EIPS/eip-1078
The unique identifier of the user is a contract which implements both Identity and the Executable Signed Messages ERCs. The user should not need provide this address directly, only a ens name pointing to it. These types of contracts are indirectly controlled by private keys that can sign messages indicating intents, which are then deployed to the contract by a third party (or a decentralized network of deployers).
The first step of the process is to request from the user the ENS name that points to their identity. If the user doesn’t have a login set up, the app should–if they have an integrated identity manager–provide an option to provide a subdomain or a name they own.
UX Note: there are many ways to provide this interface, the app can ask if they want to signup/login before hand or simply directly ask them to type the name. Note that since it’s trivial to verify if a username exists, your app should adapt to it gracefully and not require the user to type their name twice. If they ask to signup and provide a name that exists then ask them if they want to login using that name, or similarly if they ask to connect to an existing name but type a non-existent name show them a nice alert and ask them if they want to create that name now. Don’t force them to type the same name twice in two different fields.
If the user doesn’t have an identity, the app should provide the option to create one for them. Each app must have one or more domains they control which they can create immediate subdomains on demand. The app therefore will make these actions on the background:
The user shouldn’t be forced to wait for transaction confirmation times. Instead, have an indicator somewhere on the app the shows the progress and then allow the user to interact with your app normally. It’s unlikely that they’ll need the identity in the first few minutes and if something goes wrong (username gets registered at the same time), you can then ask the user for an action.
Implementation note: in order to save gas, some of these steps can be done in advance. The app can automatically deploy a small number of contracts when the gas price is low, and set up all their main variables to be 0xFFFFFF…FFFFF. These should be considered ‘vacant’ and when the user registers one, they will get a gas discount for freeing up space on the chain. This has the added benefit of allowing the user a choice in contract address/icon.
Manager the higher level, allows the key to initiate or sign transactions that change the identity itself, like adding or removing keys. An app should only require this level if it integrates an identity manager. Depending on how the identity is set up, it might require signature from more keys before these transactions can be deployed.
Action this level allows the key to initiate or sign transactions on address other than itself. It can move funds, ether, assets etc. An app should only require this level of privilege if it’s a general purpose wallet or browser for sending ethereum transactions. Depending on how the identity is set up, it might require signature from more keys before these transactions can be deployed.
Encryption the lower level has no right to initiate any transactions, but it can be used to represent the user in specific instances or off-chain signed messages. It’s the ideal level of privilege for games, chat or social media apps, as they can be used to sign moves, send messages, etc. If a game requires actual funds (say, to start a game with funds in stake) then it should still use the encryption level, and then require the main wallet/browser of the user to sign messages using the ethereum URI standard.
If adding the new key requires multiple signatures, or if the app receiving that request exclusiveky deals with executable signed messages and has no ether on itself, then it should follow the steps in the next section on how to request transactions.
As before, the user shouldn’t be forced to wait for transaction confirmation times. Instead, have an indicator somewhere on the app the shows the progress and then allow the user to interact with your app normally.
After step 2, the end result should be that your app should have the identity address of the user, their main ens name and a private key, whose public account is listed on the identity as one of their keys, with roles being either manager, action or encryption. Now it can start using that information to sign and execute transactions.
After step 2, the end result should be that your app should have the identity address of the user, their main ens name and a private key, whose public account is listed on the identity as one of their keys, with roles being either manager, action or encryption. Now it can start using that information to sign and execute transactions.
Not all transactions need to be on chain, actually most common uses of signed messages should be off chain. If you have a chat app, for instance, you can use the local key for signing messages and sending it to the other parties, and they can just query the identity contract to see if that key actually comes from the user. If you have a game with funds at stake, only the first transaction moving funds and setting up the initial game needs to be executed by the identity: at each turn the players can sign a hash of the current state of the board and at the end, the last two plays can be used to determine the winner. Notice that keys can be revoked at any time, so your app should take that in consideration, for instance saving all keys at the start of the game. Keys that only need this lower level of privilege, should be set at level 4 (encryption).
Not all transactions need to be on chain, actually most common uses of signed messages should be off chain. If you have a chat app, for instance, you can use the local key for signing messages and sending it to the other parties, and they can just query the identity contract to see if that key actually comes from the user. If you have a game with funds at stake, only the first transaction moving funds and setting up the initial game needs to be executed by the identity: at each turn the players can sign a hash of the current state of the board and at the end, the last two plays can be used to determine the winner. Notice that keys can be revoked at any time, so your app should take that in consideration, for instance saving all keys at the start of the game. Keys that only need this lower level of privilege, should be set at level 4 (encryption).
Not all transactions need to be on chain, actually most common uses of signed messages should be off chain. If you have a chat app, for instance, you can use the local key for signing messages and sending it to the other parties, and they can just query the identity contract to see if that key actually comes from the user. If you have a game with funds at stake, only the first transaction moving funds and setting up the initial game needs to be executed by the identity: at each turn the players can sign a hash of the current state of the board and at the end, the last two plays can be used to determine the winner. Notice that keys can be revoked at any time, so your app should take that in consideration, for instance saving all keys at the start of the game. Keys that only need this lower level of privilege, should be set at level 4 (encryption).
If the transaction need to collect more signatures or the app doesn’t have a deployable server, the app should follow these steps:
https://eips.ethereum.org/EIPS/eip-1080
To mitigate the effects of reasonably provable token or asset loss or theft and to help resolve other conflicts. Ethereum’s protocol should not be modified because of loss, theft, or conflicts, but it is possible to solve these problems in the smart contract layer.
https://eips.ethereum.org/EIPS/eip-1081
https://eips.ethereum.org/EIPS/eip-1087
No contract should see an increase in gas cost for this change, and many will see decreased gas consumption, so no contract-layer backwards compatibility issues are anticipated.
https://eips.ethereum.org/EIPS/eip-1102
The pattern of automatic account exposure followed by the previous generation of Ethereum-enabled DOM environments fails to protect user privacy and fails to maintain safe user experience: untrusted websites can both view detailed account information and arbitrarily initiate transactions on a user’s behalf. Even though most users may reject unsolicited transactions on untrusted websites, a protocol for account access should make such unsolicited requests impossible.
https://eips.ethereum.org/EIPS/eip-1108
Faster operations on Ethereum clients should be reflected in reduced gas costs.
https://eips.ethereum.org/EIPS/eip-1109
https://eips.ethereum.org/EIPS/eip-1123
This document defines the specification for an EthPM package manifest. A
package manifest provides metadata about a Package, and
in most cases should provide sufficient information about the packaged
contracts and its dependencies to do bytecode verification of its
contracts.
A prefixed hexadecimal value begins with 0x.
Unprefixed values have no prefix. Unless otherwise
specified, all hexadecimal values should be represented with the
0x prefix.
The following fields are defined for the package. Custom fields may
be included. Custom fields should be prefixed with x- to prevent
name collisions with future versions of the specification.
The meta field defines a location for metadata about the package which
is not integral in nature for package installation, but may be important
or convenient to have on-hand for other reasons. This field should
be included in all Packages.
The version field declares the version number of this release. This
value must be included in all Packages. This value should
conform to the semver version
numbering specification.
The sources field defines a source tree that should comprise the
full source tree necessary to recompile the contracts contained in this
release. Sources are declared in a key/value mapping.
When the value is a source string the key should be interpreted as a
file path.
The contract_types field holds the Contract
Types which have been included in this release.
Packages should only include contract types that
can be found in the source files for this package. Packages should
not include contract types from dependencies. Packages should not
include abstract contracts in the contract types section of a release.
The contract_types field holds the Contract
Types which have been included in this release.
Packages should only include contract types that
can be found in the source files for this package. Packages should
not include contract types from dependencies. Packages should not
include abstract contracts in the contract types section of a release.
The contract_types field holds the Contract
Types which have been included in this release.
Packages should only include contract types that
can be found in the source files for this package. Packages should
not include contract types from dependencies. Packages should not
include abstract contracts in the contract types section of a release.
Definitions for different objects used within the Package. All objects
allow custom fields to be included. Custom fields should be prefixed
with x- to prevent name collisions with future versions of the
specification.
The name field is a string which must be a valid
Identifier. Any link references which should be
linked with the same link value should be given the same name.
The name field is a string which must be a valid
Identifier. Any link references which should be
linked with the same link value should be given the same name.
The value field defines the value which should be written when
linking the corresponding bytecode.
To reference the address of a Contract
Instance from the current package the value
should be the name of that contract instance.
The license field declares the license under which this package is
released. This value should conform to the
SPDX
format. Packages should include this field.
The license field declares the license under which this package is
released. This value should conform to the
SPDX
format. Packages should include this field.
The links field provides URIs to relevant resources associated with
this package. When possible, authors should use the following keys
for the following common resources.
The compiler field defines the compiler information that was used
during compilation of this Contract Instance.
This field should be present in all Contract
Types which include bytecode or
runtime_bytecode.
The compiler field defines the compiler information that was used
during compilation of this Contract Instance.
This field should be present in all contract instances that locally
declare runtime_bytecode.
The version field defines the version of the compiler. The field
should be OS agnostic (OS not included in the string) and take the
form of either the stable version in
semver format or if built on a
nightly should be denoted in the form of <semver>-<commit-hash> ex:
0.4.8-commit.60cc1668.
The version field defines the version of the compiler. The field
should be OS agnostic (OS not included in the string) and take the
form of either the stable version in
semver format or if built on a
nightly should be denoted in the form of <semver>-<commit-hash> ex:
0.4.8-commit.60cc1668.
The settings field defines any settings or configuration that was used
in compilation. For the "solc" compiler, this should conform to
the Compiler Input and Output
Description.
The <genesis hash> represents the blockhash of the first block on the
chain, and <latest confirmed block hash> represents the hash of the
latest block that’s been reliably confirmed (package managers should be
free to choose their desired level of confirmations).
The set of EVM instructions as produced by a compiler. Unless otherwise
specified this should be assumed to be hexadecimal encoded, representing
a whole number of bytes, and prefixed with 0x.
In cases where there is a single deployed instance of a given Contract
Type, package managers should use the
Contract Alias for that contract type for this
name.
In cases where there are multiple deployed instances of a given contract
type, package managers should use a name which provides some added
semantic information as to help differentiate the two deployed instances
in a meaningful way.
These efforts should be considered separate, warranting future
dependent EIP submssions.
https://eips.ethereum.org/EIPS/eip-1129
Every time there is a new announcement it should be advertised in this event. It holds the information about author author and the announcement istelf message.
Every time an announcement is removed it should be advertised in this event. It holds the information about author author, the announcement itself message, the reason for removal or explanation of the solution reason and the address of the entity that removed the announcement remover.
https://eips.ethereum.org/EIPS/eip-1132
In Nexus Mutual, claim assessors are required to lock their tokens before passing a vote for claims assessment. This is important as it ensures assessors’ skin in the game. The need here was that once a claim assessor locks his tokens for ‘n’ days, he should be able to cast multiple votes during that period of ‘n’ days, which is not feasible with staking mechanism. There are other scenarios like skills/identity verification or participation in gamified token curated registries where time-locked tokens are required as well.
https://eips.ethereum.org/EIPS/eip-1153
Because the transient storage must behave identically to storage within the context of a single transaction with regards to revert behavior, it is necessary to be able to revert to a previous state of transient storage within a transaction. At the same time reverts are exceptional cases and loads, stores and returns should be cheap.
https://eips.ethereum.org/EIPS/eip-1154
Ultimately, the value in different oracle systems comes from their underlying resolution mechanics, and points where these systems are virtually identical should be standardized.
In both cases, an additional transaction would have to be performed, so the choice to go with push or pull should be based on the dominant use case for these oracles.
https://eips.ethereum.org/EIPS/eip-1155
Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains a localization attribute, its content MAY be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three attributes: uri, default and locales. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.
Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains a localization attribute, its content MAY be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three attributes: uri, default and locales. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.
An owner SHOULD be assumed to always be able to operate on their own tokens regardless of approval status, so should SHOULD NOT have to call setApprovalForAll to approve themselves as an operator before they can operate on them.
There have been requirements during the design discussions to have this standard be compatible with existing standards when sending to contract addresses, specifically ERC-721 at time of writing.
To cater for this scenario, there is some leeway with the revert logic should a contract not implement the ERC1155TokenReceiver as per “Safe Transfer Rules” section above, specifically “Scenario#3 : The receiver does not implement the necessary ERC1155TokenReceiver interface function(s)”.
https://eips.ethereum.org/EIPS/eip-1167
https://eips.ethereum.org/EIPS/eip-1175
https://eips.ethereum.org/EIPS/eip-1178
Allows an individual to fill an existing bid (see above function) and complete the exchange of their tokens of one class for another. In the sample implementation, this function call should fail unless the callee has already approved the contract to transfer their tokens. Of course, it is possible to create an implementation where calling this function implicitly assumes approval and the transfer is completed in one step.
https://eips.ethereum.org/EIPS/eip-1185
https://eips.ethereum.org/EIPS/eip-1186
As Part of the eth-Module, an additional Method called eth_getProof should be defined as follows:
https://eips.ethereum.org/EIPS/eip-1191
https://eips.ethereum.org/EIPS/eip-1193
The return value of eth_accounts is ultimately controlled by the Wallet or Client.
In order to protect user privacy, the authors recommend not exposing any accounts by default.
Instead, Providers should support RPC methods for explicitly requesting account access, such as eth_requestAccounts (see EIP-1102) or wallet_requestPermissions (see EIP-2255).
https://eips.ethereum.org/EIPS/eip-1202
https://eips.ethereum.org/EIPS/eip-1203
This EIP is fully compatible with the mandatory methods of ERC20 Token Standard so long as the implementation includes a “lowest common denominator” class, which may be class B common/gold coin/money in the abstract/virtual/physical examples above respectively. Where it is not possible to implement such class, then the implementation should specify a default class for tracking or transferring unless otherwise specified, e.g. US dollar is transferred unless other currency is explicitly specified.
https://eips.ethereum.org/EIPS/eip-1207
https://eips.ethereum.org/EIPS/eip-1227
Given the controversy surrounding the directly relevant EIP #649, the issuance should also be reset to pre-Byzantium levels. It may be reduced again at a later time via a new hard-fork, only this time users would actually have a meaningful choice in accepting the change or not. Note: the issuance reduction is not the focus of this proposal, and is optional; the defusing of the difficulty bomb is of primary concern.
This will permanently, without further changes, disable the “ice age.” It will also reset the block reward to pre-Byzantium levels. Both of these changes are specified similarly to EIP #649, so they should require only minimal changes from client developers.
This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. However, it may be controversial in nature among different sections of the userbase—the very problem this EIP is made to address. Therefore, it should not be included in a scheduled hardfork at a certain block number. It is suggested to implement this EIP in an isolated hard-fork before the second of the two Metropolis hard-forks.
https://eips.ethereum.org/EIPS/eip-1234
The Casper development and switch to proof-of-stake is delayed, the Ethash proof-of-work should be feasible for miners and allow sealing new blocks every 15 seconds on average for another 12 months. With the delay of the ice age, there is a desire to not suddenly also increase miner rewards. The difficulty bomb has been known about for a long time and now it’s going to stop from happening. In order to maintain stability of the system, a block reward reduction that offsets the ice age delay would leave the system in the same general state as before. Reducing the reward also decreases the likelihood of a miner driven chain split as Ethereum approaches proof-of-stake.
This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It’s suggested to include this EIP in the second Metropolis hard-fork, Constantinople.
https://eips.ethereum.org/EIPS/eip-1240
With the difficulty bomb removed, when Casper is released it will be up to economic participants to decide whether they want the features that Casper enables or not. If they do not want Casper, they are free to continue running unpatched clients and participating in the Ethereum network as it exists today. This freedom of choice is the cornerstone of DLTs and making it hard for people to make that choice (by creating an artificial pressure) does not work towards that goal of freedom of choice. If the development team is not confident that economic participants will want Casper, then they should re-evaluate their priorities rather than trying to force Casper onto users.
This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation. Therefore, it should be included in a scheduled hardfork at a certain block number.
https://eips.ethereum.org/EIPS/eip-1261
Attributes are a huge part of ERC-1261 which help to store identifiable information regarding its members. Polls can make use of attributes to calculate the voterbase.
E.g: Users should belong to USA entity and not belong to Washington state attribute to be a part of a poll.
https://eips.ethereum.org/EIPS/eip-1271
This function should be implemented by contracts which desire to sign messages (e.g. smart contract wallets, DAOs, multisignature wallets, etc.) Applications wanting to support contract signatures should call this method if the signer is a contract.
This function should be implemented by contracts which desire to sign messages (e.g. smart contract wallets, DAOs, multisignature wallets, etc.) Applications wanting to support contract signatures should call this method if the signer is a contract.
isValidSignature() should not be able to modify states in order to prevent GasToken minting or similar attack vectors. Again, this is to simplify the implementation surface of the function for better standardization and to allow off-chain contract queries.
https://eips.ethereum.org/EIPS/eip-1276
This EIP-1276 opposes directly the intent of EIP-1234 which should be also considered in discussions.
This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It’s suggested to include this EIP in the second Metropolis hard-fork, Constantinople.
https://eips.ethereum.org/EIPS/eip-1283
https://eips.ethereum.org/EIPS/eip-1285
Currently, the CALL opcode forwards a stipend of 2,300 gas units for a non zero value CALL operations where a contract is called. This stipend is given to the contract to allow execution of its fallback function. The stipend given is intentionally small in order to prevent the called contract from spending the call gas or performing an attack (like re-entrancy).
While the stipend is small it should still give the sufficient gas required for some cheap opcodes like LOG, but it’s not enough for some more complex and modern logics to be implemented.
This EIP proposes to increase the given stipend from 2,300 to 3,500 to increase the usability of the fallback function.
https://eips.ethereum.org/EIPS/eip-1295
The security layer of the Ethereum network is and should remain robust. Incentives for continued operation of the security of the growing ecosystem are paramount.
The security layer of the Ethereum network is and should remain robust. Incentives for continued operation of the growing ecosystem’s security are paramount.
Reducing the issuance of ETH in rewarding Uncle blocks (forked blocks caused by latency in propagation, a multi-faceted problem) should directly incentivize the investment in technologies and efficiencies to reduce block propagation latency which may lead to a reduction in Network wide Uncle rates, reducing ancillary issuance further.
The Nephew reward structure should be entirely eliminated.
With a reduction to the Uncle and removal of the Nephew reward, ancillary ETH issuance should drop (under normal market conditions, i.e. 22.49% uncle rate) by over 75pct and total ETH issuance from the successful sealing and mining of valid blocks should drop over 10pct.
With a reduction to the Uncle and removal of the Nephew reward, ancillary ETH issuance should drop (under normal market conditions, i.e. 22.49% uncle rate) by over 75pct and total ETH issuance from the successful sealing and mining of valid blocks should drop over 10pct.
This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation, as well as the block, uncle and nephew reward structure. Therefore, it should be included in a scheduled hardfork at a certain block number. It’s suggested to include this EIP in the second Metropolis hard-fork, Constantinople.
https://eips.ethereum.org/EIPS/eip-1319
getAllPackageIds and getAllReleaseIds support paginated requests because it’s possible that the return values for these methods could become quite large. The methods should return a pointer that points to the next available item in a list of all items such that a caller can use it to pick up from where the previous request left off. (See here for a discussion of the merits and demerits of various pagination strategies.) The limit parameter defines the maximum number of items a registry should return per request.
getAllPackageIds and getAllReleaseIds support paginated requests because it’s possible that the return values for these methods could become quite large. The methods should return a pointer that points to the next available item in a list of all items such that a caller can use it to pick up from where the previous request left off. (See here for a discussion of the merits and demerits of various pagination strategies.) The limit parameter defines the maximum number of items a registry should return per request.
https://eips.ethereum.org/EIPS/eip-1328
URIs should be shared between user devices or applications and no sensitive data is shared within the URI that could compromise the communication or would allow control of the user’s private keys.
https://eips.ethereum.org/EIPS/eip-1337
EIP-1337 Contracts should be compiled with a contract that references all the enumerations that are required for operation
https://eips.ethereum.org/EIPS/eip-1344
The value of the current chain ID is obtained from the chain ID configuration, which should match the EIP-155 unique identifier a client will accept from incoming transactions. Please note that per EIP-155, it is not required that a transaction have an EIP-155 unique identifier, but in that scenario this opcode will still return the configured chain ID and not a default.
In order to mitigate this situation, users of the proposed CHAINID opcode must ensure that their application can handle a potential update to the value of chain ID during their usage of their application in case this does occur, if required for the continued use of the application. A Trustless Oracle that logs the timestamp when a change is made to chain ID can be implemented either as an application-level feature inside the application contract system, or referenced as a globally standard contract. Failure to provide a mitigation for this scenario could lead to a sudden loss of legitimacy of previously signed off-chain messages, which could be an issue during settlement periods and other longer-term verification events for these types of messages. Not all applications of this opcode may need mitigations to handle this scenario, but developers should provide reasoning on a case-by-case basis.
https://eips.ethereum.org/EIPS/eip-1352
Due to the extremely low probability (and lack of adequate testing possibilities) no explicit checks should be added to ensure that external transaction signing or
the invoking of the CREATE instruction can result in a precompile address.
No contracts on the main network have been created at the specified addresses. As a result it should pose no backwards compatibility problems.
https://eips.ethereum.org/EIPS/eip-1355
https://eips.ethereum.org/EIPS/eip-1363
https://eips.ethereum.org/EIPS/eip-1380
This should pose no risk to backwards compatibility. Currently existing contracts should not notice the difference, just see cheaper execution.
With EIP150 contract (and language) developers had a lesson that relying on strict gas costs is not feasible as costs may change.
The impact of this EIP is even less that of EIP150 because the costs are changing downwards and not upwards.
This should pose no risk to backwards compatibility. Currently existing contracts should not notice the difference, just see cheaper execution.
With EIP150 contract (and language) developers had a lesson that relying on strict gas costs is not feasible as costs may change.
The impact of this EIP is even less that of EIP150 because the costs are changing downwards and not upwards.
https://eips.ethereum.org/EIPS/eip-1386
https://eips.ethereum.org/EIPS/eip-1387
https://eips.ethereum.org/EIPS/eip-1388
https://eips.ethereum.org/EIPS/eip-1417
https://eips.ethereum.org/EIPS/eip-1418
// TODO: I’m not sure if that should be > or >=
The specification gives responsibility for eviction to the consensus clients. This is the most predictable behavior because it happens exactly when it should. Also there need not be any incentive mechanism (refund gas, bounty) for outside participants (off chain) to monitor accounts and request removal.
Ether converted to rent cannot be converted back. Anybody that works in accounting and knows about gifts cards should tell you this is a good idea. It makes reasoning about the system much easier.
Because anybody/everybody can contribute to the rent account. If you depend on a contract, you should contribute to its rent.
https://eips.ethereum.org/EIPS/eip-1438
https://eips.ethereum.org/EIPS/eip-1444
Rather the dispersing several LocalizationPreferences for different use cases and codes, one could imagine a global “registry of registries”. While this approach allows for a unified lookups of all translations in all use cases, it is antithetical to the spirit of decentralization and freedom. Such a system also increases the lookup complexity, places an onus on getting the code right the first time (or adding the overhead of an upgradable contract), and need to account for use case conflicts with a “unified” or centralized numbering system. Further, lookups should be lightweight (especially in cases like looking up revert text).
https://eips.ethereum.org/EIPS/eip-1450
ERC-1450 manages securities ownership during issuance and trading. The Issuer is the only role that should create a ERC-1450 and assign the RTA. The RTA is the only role that is allowed to execute ERC-1450’s mint, burnFrom, and transferFrom functions. No role is allowed to execute ERC-1450’s transfer function.
There are currently no token standards that expressly facilitate conformity to securities law and related regulations. ERC-20 tokens do not support the regulated roles of Funding Portal, Broker Dealer, RTA, and Investor and do not support the Bank Secrecy Act/USA Patriot Act KYC and AML requirements. Other improvements (notably EIP-1404 (Simple Restricted Token Standard) have tried to tackle KYC and AML regulatory requirement. This approach is novel because the RTA is solely responsible for performing KYC and AML and should be solely responsible for transferFrom, mint, and burnFrom.
ERC-1450 requires that only the Issuer can create a token representing the security that only the RTA manages. Instantiating the ERC-1450 requires the Owned and IssuerControlled modifiers, and only the Issuer should execute the ERC-1450 constructor for a compliant token. ERC-1450 extends the general Ownable modifier to describe a specific subset of owners that automate and decentralize compliance through the contract modifiers Owned and IssuerControlled and the function modifiers onlyOwner and onlyIssuerTransferAgent. The Owned contract modifier instantiates the onlyOwner modifier for functions. The IssuerControlled modifier instantiates the onlyIssuerTransferAgent modifier for functions.
https://eips.ethereum.org/EIPS/eip-1459
No particular ordering or structure is defined for the tree. Whenever the tree
is updated, its sequence number should increase. The content of any TXT record
should be small enough to fit into the 512 byte limit imposed on UDP DNS
packets. This limits the number of hashes that can be placed into an
enrtree-branch entry.
No particular ordering or structure is defined for the tree. Whenever the tree
is updated, its sequence number should increase. The content of any TXT record
should be small enough to fit into the 512 byte limit imposed on UDP DNS
packets. This limits the number of hashes that can be placed into an
enrtree-branch entry.
Client implementations should avoid downloading the entire tree at once during
normal operation. It’s much better to request entries via DNS when-needed, i.e.
at the time when the client is looking for peers.
https://eips.ethereum.org/EIPS/eip-1462
What we propose in this EIP is a simple and very modular solution for creating a base security token for the widest possible scope of applications, so it can be used by other issuers to build upon. The issuers should be able to add more restrictions and policies to the token, using the functions and implementation proposed below, but they must not be limited in any way while using this ERC.
We introduce four new functions that should be used to check that the actions are allowed for the provided inputs. The implementation details of each function are left for the token issuer, it is the issuer’s responsibility to add all necessary checks that will validate an operation in accordance with KYC/AML policies and legal requirements set for a specific token asset.
We also introduce two new functions that should be used for document management purposes. Function attachDocument adds a reference pointing to an off-chain document, with specified name, URI and contents hash. The hashing algorithm is not specified within this standard, but the resulting hash must not be longer than 32 bytes. Function lookupDocument gets the referenced document by its name.
We require two different transfer validation functions: checkTransferAllowed and checkTransferFromAllowed since the corresponding transfer and transferFrom are usually called in different contexts. Some token standards such as ERC-1450 explicitly disallow use of transfer, while allowing only transferFrom. There might be also different complex scenarios, where transfer and transferFrom should be treated differently. ERC-777 is relying on its own send for transferring tokens, so it is reasonable to switch between checker functions based on its call context. We decided to omit the checkApprove function since it would be used in exactly the same context as checkTransferFromAllowed. In many cases it is required not only regulate securities transfers, but also restrict burn and mint operations, and additional checker functions have been added for that.
https://eips.ethereum.org/EIPS/eip-1470
https://eips.ethereum.org/EIPS/eip-1474
This proposal defines a standard set of remote procedure call methods that an Ethereum node should implement.
If the block is not found, the callee SHOULD raise a JSON-RPC error (the recommended error code is -32001: Resource not found. If the tag is blockHash and requireCanonical is true, the callee SHOULD additionally raise a JSON-RPC error if the block is not in the canonical chain (the recommended error code is -32000: Invalid input and in any case should be different than the error code for the block not found case so that the caller can distinguish the cases). The block-not-found check SHOULD take precedence over the block-is-canonical check, so that if the block is not found the callee raises block-not-found rather than block-not-canonical.
Note: Client developers should refer to EIP-712 for complete semantics around encoding and signing data. Dapp developers should refer to EIP-712 for the expected structure of RPC method input parameters.
Note: Client developers should refer to EIP-712 for complete semantics around encoding and signing data. Dapp developers should refer to EIP-712 for the expected structure of RPC method input parameters.
Note: This should only be called if a filter and its notifications are no longer needed. This will also be called automatically on a filter if its notifications are not retrieved using eth_getFilterChanges for a period of time.
https://eips.ethereum.org/EIPS/eip-1482
On the basis that both Geth and Parity implement the same timestamp validation requirements, this should be written into the reference specification.
The yellow paper should define a timestamp as:
Both Geth and Parity reject blocks with timestamp more than 15 seconds in the future. This establishes a defacto standard, which should be made explicit in the reference specification.
https://eips.ethereum.org/EIPS/eip-1484
Alternative 1: Nuclear Option
This approach would allow any Associated Address to destroy an Identity whenever another Associated Address is compromised. While this may seem severe, we strongly considered it because this ERC is an identity protocol, not an identity application. This means that though a user’s compromised Identity is destroyed, they should still have recourse to whatever restoration mechanisms are available in each of their actual identities at the Resolver and/or Provider level. We ultimately dismissed this approach for two main reasons:
We find that at a protocol layer, identities should not rely on specific claim or attestation structures, but should instead be a part of a trustless framework upon which arbitrarily sophisticated claim and attestation structures may be built.
We find that at a protocol layer, identities should not rely on specific claim or attestation structures, but should instead be a part of a trustless framework upon which arbitrarily sophisticated claim and attestation structures may be built.
https://eips.ethereum.org/EIPS/eip-1485
https://eips.ethereum.org/EIPS/eip-1491
https://eips.ethereum.org/EIPS/eip-1504
https://eips.ethereum.org/EIPS/eip-1523
https://eips.ethereum.org/EIPS/eip-1538
Contract standards evolve, new ones come out. People, groups and organizations learn over time what people want and what is better and what should be built next. Contracts that cannot be improved not only hold back the authors that create them, but everybody who uses them.
The transparent contract source code and the source code for the delegate contracts should be verified in a provable way by a third party source such as etherscan.io.

A function selector clash occurs when a function is added to a contract that hashes to the same four-byte hash as an existing function. This is unlikely to occur but should be prevented in the implementation of the updateContract function. See the reference implementation of ERC1538 to see an example of how function clashes can be prevented.
It is possible to extend this standard to add consensus functionality such as an approval function that multiple different people call to approve changes before they are submitted with the updateContract function. Changes only go into effect when the changes are fully approved. The CommitMessage and ` FunctionUpdate` events should only be emitted when changes go into effect.
https://eips.ethereum.org/EIPS/eip-1559
The datastructure that is passed into keccak256 to calculate the block hash is changing, and all applications that are validating blocks are valid or using the block hash to verify block contents will need to be adapted to support the new datastructure (one additional item). If you only take the block header bytes and hash them you should still correctly get a hash, but if you construct a block header from its constituent elements you will need to add in the new one at the end.
This EIP will increase the maximum block size, which could cause problems if miners are unable to process a block fast enough as it will force them to mine an empty block. Over time, the average block size should remain about the same as without this EIP, so this is only an issue for short term size bursts. It is possible that one or more clients may handle short term size bursts poorly and error (such as out of memory or similar) and client implementations should make sure their clients can appropriately handle individual blocks up to max size.
This EIP will increase the maximum block size, which could cause problems if miners are unable to process a block fast enough as it will force them to mine an empty block. Over time, the average block size should remain about the same as without this EIP, so this is only an issue for short term size bursts. It is possible that one or more clients may handle short term size bursts poorly and error (such as out of memory or similar) and client implementations should make sure their clients can appropriately handle individual blocks up to max size.
With most people not competing on priority fees and instead using a baseline fee to get included, transaction ordering now depends on individual client internal implementation details such as how they store the transactions in memory. It is recommended that transactions with the same priority fee be sorted by time the transaction was received to protect the network from spamming attacks where the attacker throws a bunch of transactions into the pending pool in order to ensure that at least one lands in a favorable position. Miners should still prefer higher gas premium transactions over those with a lower gas premium, purely from a selfish mining perspective.
https://eips.ethereum.org/EIPS/eip-1571
Why a pool should advertise the node’s version ? It’s a matter of transparency : miners should know whether or not pool have upgraded to latest patches/releases for node’s software.
Why a pool should advertise the node’s version ? It’s a matter of transparency : miners should know whether or not pool have upgraded to latest patches/releases for node’s software.
This notification is meant only from servers to clients. Should a server receive such a notification it will simply ignore it. After the notification has been properly sent, the server is ALLOWED to close the connection, while the client will take the proper actions to reconnect to the suggested end-point.
The host member in params object SHOULD report an host DNS name and not an IP address: TLS encrypted connections require to validate the CN name in the certificate which, 99% of the cases, is an host name.
The third member resume of the params object sets whether or not the receiving server is prepared for session resuming.
After this notification has been issued by the server, the client should expect no further messages and MUST disconnect.
Every “test” over a number is called a hash. Assuming a miner should receive a job for each block and considering the actual average block time of 15 seconds that would mean a miner should try
Every “test” over a number is called a hash. Assuming a miner should receive a job for each block and considering the actual average block time of 15 seconds that would mean a miner should try
You’ll notice in the sample above the miner nonce is only 12 bytes wide (should be 16). Why ?
That’s because in the previous mining.set the server has set an extranonce of af4c. This means the full nonce is af4c68765fccd712
In presence of extranonce the miner MUST submit only the chars to append to the extranonce to build the final hex value. If no extranonce is set for the session or for the work the miner MUST send all 16 bytes.
Client should treat errors as “soft” errors (stales) or “hard” (bad nonce computation, job not found etc.). Errors in 5xx range are server errors and suggest the miner to abandon the connection and switch to a failover.
https://eips.ethereum.org/EIPS/eip-1577
https://eips.ethereum.org/EIPS/eip-1581
Describes the purpose for which the key is being used. Key types should be generic. “Instant messaging” is a good example whereas “Whisper” is not. The reason is that you want to be able to use the same identity across different services. Key types are defined at: TBD
https://eips.ethereum.org/EIPS/eip-1588
https://eips.ethereum.org/EIPS/eip-1592
This standard proposal should answer the following challenges:
ERC20 was designed as a standard interface allowing any token on Ethereum to be handled by other applications: from wallets to decentralized exchanges. This has been extremely powerful, but future developments in the industry of tokenization are bringing new challenges. For example it is already hard to know exactly why an ERC20 transfer failed, and it will become even harder when many tokens add their own transfer rules to the mix; we propose that it should be trivial to determine before a tx is sent, whether the transfer should turn out valid or invalid, and why (unless conditions change in the meantime obviously). On the other hand, if the rules were changed, it should also be easily detected, so that the interacting party knows it must adjust its expectations or model.
ERC20 was designed as a standard interface allowing any token on Ethereum to be handled by other applications: from wallets to decentralized exchanges. This has been extremely powerful, but future developments in the industry of tokenization are bringing new challenges. For example it is already hard to know exactly why an ERC20 transfer failed, and it will become even harder when many tokens add their own transfer rules to the mix; we propose that it should be trivial to determine before a tx is sent, whether the transfer should turn out valid or invalid, and why (unless conditions change in the meantime obviously). On the other hand, if the rules were changed, it should also be easily detected, so that the interacting party knows it must adjust its expectations or model.
ERC20 was designed as a standard interface allowing any token on Ethereum to be handled by other applications: from wallets to decentralized exchanges. This has been extremely powerful, but future developments in the industry of tokenization are bringing new challenges. For example it is already hard to know exactly why an ERC20 transfer failed, and it will become even harder when many tokens add their own transfer rules to the mix; we propose that it should be trivial to determine before a tx is sent, whether the transfer should turn out valid or invalid, and why (unless conditions change in the meantime obviously). On the other hand, if the rules were changed, it should also be easily detected, so that the interacting party knows it must adjust its expectations or model.
IRule interface should provide a way to validate if an address or a transfer is valid.
If one of these two methods is not applicable, it can simply be made to return true systematically.
If any parameter of isTransferValid is not needed, its name should be commented out with /* */.
The rules ordering must be thought through carefully.
Rules which are cheaper to validate or have a higher chance to break should be put first to reduce global gas expenditure, then business logic should guide the ordering of rules. That is why rules for a given context should be defined as a whole and not individually.
The rules ordering must be thought through carefully.
Rules which are cheaper to validate or have a higher chance to break should be put first to reduce global gas expenditure, then business logic should guide the ordering of rules. That is why rules for a given context should be defined as a whole and not individually.
The rules ordering must be thought through carefully.
Rules which are cheaper to validate or have a higher chance to break should be put first to reduce global gas expenditure, then business logic should guide the ordering of rules. That is why rules for a given context should be defined as a whole and not individually.
https://eips.ethereum.org/EIPS/eip-1613
If a malicious sender repeatedly abuses a recipient by sending meaningless/reverted transactions and causing the recipient to pay a relay for nothing,
it is the recipient’s responsibility to blacklist that sender and have its acceptRelayedCall function return nonzero for that sender.
Collect calls are generally not meant for anonymous senders unknown to the recipient.
Dapps that utilize the gas station networks should have a way to blacklist malicious users in their system and prevent Sybil attacks.
Once relay returns the signed transaction, which should happen immediately, the relay is incentivized to also execute it on chain, so that it can advance its nonce and serve the next transaction. The user can (but doesn’t have to) also execute the transaction. To understand why the attack isn’t viable, consider the four possible scenarios after the signed transaction was returned to the sender:
https://eips.ethereum.org/EIPS/eip-1616
https://eips.ethereum.org/EIPS/eip-1620
The structure of a stream should be as follows:
https://eips.ethereum.org/EIPS/eip-1633
https://eips.ethereum.org/EIPS/eip-1679
https://eips.ethereum.org/EIPS/eip-1681
https://eips.ethereum.org/EIPS/eip-1682
https://eips.ethereum.org/EIPS/eip-1702
Note that this specification might not apply to all hard forks. We
have emergency hard forks in the past due to network attacks. Whether
they should maintain existing account compatibility should be
evaluated in individual basis. If the attack can only be executed once
against some particular contracts, then the scheme defined here might
still be applicable. Otherwise, having a plain emergency hard fork
might still be a good idea.
Note that this specification might not apply to all hard forks. We
have emergency hard forks in the past due to network attacks. Whether
they should maintain existing account compatibility should be
evaluated in individual basis. If the attack can only be executed once
against some particular contracts, then the scheme defined here might
still be applicable. Otherwise, having a plain emergency hard fork
might still be a good idea.
Note that this section is provided only for documentation
purpose. When “enabling EIP-1702”, those extensions should not be
enabled unless the extension specification is also included.
https://eips.ethereum.org/EIPS/eip-1706
In order to keep in place the implicit reentrancy protection of existing contracts, transactions should not be allowed to modify state if the remaining gas is lower then the 2300 stipend given to ‘transfer’/’send’ in Solidity.
These are other proposed remediations and objections to implementing them:
Performing SSTORE has never been possible with less than 5000 gas, so it does not introduce incompatibility to the Ethereum mainnet. Gas estimation should account for this requirement.
https://eips.ethereum.org/EIPS/eip-1710
In order to make the experience more seamless, dApps should still be able to recommend a specific mobile web3 browser via deferred deeplinking but by having a standard url format, if the user already has a web3 browser installed that implements this standard, it will be automatically linked to it.
https://eips.ethereum.org/EIPS/eip-1716
If Petersburg is defined with an earlier block number than Constantinople, then there is no immediate effect from the Petersburg fork. However, when Constantinople is later activated, EIP-1283 should be disabled.
https://eips.ethereum.org/EIPS/eip-1753
https://eips.ethereum.org/EIPS/eip-1761
This schema allows for localization. {id} and {locale} should be replaced with the appropriate values by clients.
Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains a localization attribute, its content may be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three attributes: uri, default and locales. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.
Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains a localization attribute, its content may be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three attributes: uri, default and locales. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.
https://eips.ethereum.org/EIPS/eip-1767
https://eips.ethereum.org/EIPS/eip-1775
In a wallet, an user often holds most of her funds in her main accounts. These accounts require a significant level of security and should not be delegated in any way, this significantly impacts the design of cryptographic applications if a user has to manually confirm every action. Also often an user uses the same accounts across apps, which is a privacy and potentially also a security issue.
The app keys generated using the algorithm described in the previous section will not be BIP32 compliant. Therefore apps will not be able to create several app keys or use non-hardening and extended public keys techniques directly. They get a single private key (per origin, per persona).
Yet they can use this as initial entropy to span a new HD tree and generate addresses that can be either hardened or not. Thus we should not be losing use cases.
https://eips.ethereum.org/EIPS/eip-1803
https://eips.ethereum.org/EIPS/eip-1812
Claims should be deterministic, in that the same claim signed multiple times by the same signer.
Each claim should be typed based on its specific use case, which EIP 712 lets us do effortlessly. But there are 3 minimal attributes required of the claims structure.
When defining Verifiable Claims formats a Verifying Contract should be created with a public verify() view function. This makes it very easy for other smart contracts to verify a claim correctly.
The Claim struct should be embedded in another struct together with the v, r and s signature parameters.
Each Verifiable Claim should be individually verified together with the parent Signed Typed Data structure.
Any State Channel based on EIP712 should be able to include the embeddable Verifiable Claims as part of its protocol. This could be useful for exchanging private Identity Claims between the parties for regulatory reasons, while ultimately not posting them to the blockchain on conclusion of a channel.
In most simple cases the issuer of a Claim is the signer of the data. There are cases however where signing should be delegated to an intermediary key.
To support this an additional issuer attribute can be added to the Claim Type struct. In this case the verification code should lookup the EthereumDIDRegistry to see if the signer of the data is an allowed signing delegate for the issuer
Delegates should be created for specific EIP 712 Domains and not be reused across Domains.
Each value should use the value field to indicate the value.
Hashed claims can be used to make a claim about the subject containing the hash of a claim value. Hashes should use ethereum standard keccak256 hashing function.
Each value should use the keccak256  field to indicate the hashed value. Question. The choice of using this name is that we can easily add support for future algorithms as well as maybe zkSnark proofs.
Both Issuers and Subjects should be allowed to revoke Verifiable Claims. Revocations can be handled through a simple on-chain registry.
The ultimate rules of who should be able to revoke a claim is determined by the Verifying contract.
https://eips.ethereum.org/EIPS/eip-1820
If the interface is part of an approved ERC, it MUST be named ERC###XXXXX where ### is the number of the ERC and XXXXX should be the name of the interface in CamelCase.
The meaning of this interface SHOULD be defined in the specified ERC.
https://eips.ethereum.org/EIPS/eip-1822
The Proxy Contract proposed here should be deployed as is, and used as a drop-in replacement for any existing methods of lifecycle management of contracts. In addition to the Proxy Contract, we propose the Proxiable Contract interface/base which establishes a pattern for the upgrade which does not interfere with existing business rules. The logic for allowing upgrades can be implemented as needed.
In addition, the arbitrary nature of the Proxy Contract’s constructor provides the ability to select from one or more constructor functions available in the Logic Contract source code (e.g., constructor1, constructor2, … etc. ). Note that if multiple constructors are included in the Logic Contract, a check should be included to prohibit calling a constructor again post-initialization.
The following common best practices should be employed for all Logic Contracts when using a proxy contract.
Careful consideration should be made when designing a new Logic Contract to prevent incompatibility with the existing storage of the Proxy Contract after an upgrade. Specifically, the order in which variables are instantiated in the new contract should not be modified, and any new variables should be added after all existing variables from the previous Logic Contract
Careful consideration should be made when designing a new Logic Contract to prevent incompatibility with the existing storage of the Proxy Contract after an upgrade. Specifically, the order in which variables are instantiated in the new contract should not be modified, and any new variables should be added after all existing variables from the previous Logic Contract
Careful consideration should be made when designing a new Logic Contract to prevent incompatibility with the existing storage of the Proxy Contract after an upgrade. Specifically, the order in which variables are instantiated in the new contract should not be modified, and any new variables should be added after all existing variables from the previous Logic Contract
https://eips.ethereum.org/EIPS/eip-1829
https://eips.ethereum.org/EIPS/eip-1844
https://eips.ethereum.org/EIPS/eip-1872
A proposal to define a limited number of annual time windows in which network
upgrades (aka hard forks) should be performed within. Policies for scheduling
network upgrades outside these windows are also described.
Four different weeks, spaced roughly evenly throughout the year, are targeted
for network upgrades to be launched. Regular network upgrades should announce
their intention to launch in a particular window early in their process and
choose a block number four to six weeks prior to that window. If a network
upgrade is cancelled then it would be rescheduled for the next window. Not all
windows will be used. Priority upgrades outside the roadmap may be scheduled in
the third week of any month, but such use is discouraged. Critical upgrades are
scheduled as needed.
Roadmap network upgrades should be scheduled in one of four windows: the week
with the third Wednesday in January, April, July, and October. When initiating a
network upgrade or early in the planning process a particular window should be
targeted.
Roadmap network upgrades should be scheduled in one of four windows: the week
with the third Wednesday in January, April, July, and October. When initiating a
network upgrade or early in the planning process a particular window should be
targeted.
Implementors are expected to have software for a Roadmap network upgrade ready
two to four weeks prior to the upgrade. Hence a block number for the network
upgrade should be chosen four to six weeks prior to the network upgrade window.
Scheduling details such as whether this choice is made prior to or after testnet
deployment are out of scope of this EIP.
If a planned roadmap upgrade needs to be rescheduled then strong consideration
should be given to rescheduling the upgrade for the next window in three months
time. For the case of a six month cadence this may cause releases to be in
adjacent release windows. For a three month cadence the next network upgrade
would be merged with the current upgrade or the next network upgrade would be
delayed.
To be compatible with the scheduled release windows the cadence of the Roadmap
Network Upgrades should be a multiple of three months. Whether it is three, six,
nine, or more month cadence is out of scope of this EIP.
Priority network upgrades are best launched in unused roadmap launch windows,
namely the third week of January, April, July, and October. If necessary they
may be launched in the third week of any month, but strong consideration and
preference should be given to unused roadmap launch windows.
Priority network upgrades should be announced and a block chosen far enough in
advance so major clients implementors can release software with the needed block
number in a timely fashion. These releases should occur at least a week before
the launch window. Hence priority launch windows should be chosen two to four
weeks in advance.
Priority network upgrades should be announced and a block chosen far enough in
advance so major clients implementors can release software with the needed block
number in a timely fashion. These releases should occur at least a week before
the launch window. Hence priority launch windows should be chosen two to four
weeks in advance.
Priority network upgrades should be announced and a block chosen far enough in
advance so major clients implementors can release software with the needed block
number in a timely fashion. These releases should occur at least a week before
the launch window. Hence priority launch windows should be chosen two to four
weeks in advance.
To continue this pattern network upgrade activation block numbers for mainnet
deployments and production grade networks should chose a number whose base 10
representation ends with three or more zeros.
Block numbers for Roadmap and Priority network upgrades should be chosen so that
it is forecast to occur relatively close to Wednesday at 12:00 UTC+0 during the
launch window. This should result in an actual block production occurring
sometime between Monday and Friday of the chosen week.
Block numbers for Roadmap and Priority network upgrades should be chosen so that
it is forecast to occur relatively close to Wednesday at 12:00 UTC+0 during the
launch window. This should result in an actual block production occurring
sometime between Monday and Friday of the chosen week.
https://eips.ethereum.org/EIPS/eip-1884
Ergo, if we increase BALANCE, we should also increase EXTCODEHASH
Testcases that should be implemented:
https://eips.ethereum.org/EIPS/eip-1890
This EIP makes no changes to existing state transitions. Existing consensus tests should be sufficient.
https://eips.ethereum.org/EIPS/eip-1895
https://eips.ethereum.org/EIPS/eip-1898
If the tag is blockHash, an additional boolean field may be supplied to the block parameter, requireCanonical, which defaults to false and defines whether the block must be a canonical block according to the callee. If requireCanonical is false, the callee should raise a JSON-RPC error only if the block is not found (as described above). If requireCanonical is true, the callee SHOULD additionally raise a JSON-RPC error if the block is not in the canonical chain (the recommended error code is -32000: Invalid input and in any case should be different than the error code for the block not found case so that the caller can distinguish the cases). The block-not-found check SHOULD take precedence over the block-is-canonical check, so that if the block is not found the callee raises block-not-found rather than block-not-canonical.
If the tag is blockHash, an additional boolean field may be supplied to the block parameter, requireCanonical, which defaults to false and defines whether the block must be a canonical block according to the callee. If requireCanonical is false, the callee should raise a JSON-RPC error only if the block is not found (as described above). If requireCanonical is true, the callee SHOULD additionally raise a JSON-RPC error if the block is not in the canonical chain (the recommended error code is -32000: Invalid input and in any case should be different than the error code for the block not found case so that the caller can distinguish the cases). The block-not-found check SHOULD take precedence over the block-is-canonical check, so that if the block is not found the callee raises block-not-found rather than block-not-canonical.
https://eips.ethereum.org/EIPS/eip-1900
The dType registry should support the registration of Solidity’s elementary and complex types. In addition, it should also support contract events definitions. In this EIP, the focus will be on describing the minimal on-chain type definition and metadata needed for registering Solidity user-defined types.
The dType registry should support the registration of Solidity’s elementary and complex types. In addition, it should also support contract events definitions. In this EIP, the focus will be on describing the minimal on-chain type definition and metadata needed for registering Solidity user-defined types.
To ensure backward compatibility, we suggest that updating types should not be supported.
The remove function can also be removed from the interface, to ensure immutability. One reason for keeping it would be clearing up storage for types that are not in use or have been made obsolete. However, this can have undesired effects and should be accompanied by a solid permissions system, testing and governance process. This part will be updated when enough feedback has been received.
There is one advantage that has become clear with the emergence of global operating systems, like Ethereum: we can have a global type system through which the system’s parts can interoperate. Projects should agree on standardizing types and a type registry, continuously working on improving them, instead of creating encapsulated projects, each with their own types.
https://eips.ethereum.org/EIPS/eip-1901
The OpenRPC Document and generated Documentation that specifies all the methods an EVM-based blockchain should implement can be found here.
https://eips.ethereum.org/EIPS/eip-1921
This proposal does not affect extant Ethereum standards or implementations. Registering functions for existing contract deployments should be fully supported.
https://eips.ethereum.org/EIPS/eip-1922
https://eips.ethereum.org/EIPS/eip-1923
https://eips.ethereum.org/EIPS/eip-1930
Add the ability for smart contract to execute calls with a specific amount of gas. If this is not possible the execution should revert.
https://eips.ethereum.org/EIPS/eip-1948
The suggested data field in the NFT is used either for storing data directly, like a counter or address. If more data is required the implementer should fall back to authenticated data structures, like merkle- or patricia-trees.
https://eips.ethereum.org/EIPS/eip-1959
To protect off-chain messages from being reused across different chain, a mechanism need to be given to smart contract to only accept messages for that chain. Since a chain can change its chainID, the mechanism should consider old chainID valid.
In other words, we should consider all off-chain messages (with valid chainID) as part of the chain’s offchain state. The opcode proposed here, offer smart contracts a simple and safe method to ensure that the offchain state stay valid across fork.
As for replay protection, the idea of considering all of the off-chain messages signed with valid chainID as part of the chain’s offchain-state means that all of these off-chain messages can be reused on the different forks which share a common chainID history (up to where they differ). This is actually an important feature since as mentioned, users expect their signed messages to be valid from the time of signing. From that time onwards these messages should be considered as part of the chain’s offchain state. A hardfork should not thus render them invalid. This is similar to how the previous on-chain state is shared between 2 hardforks.
As for replay protection, the idea of considering all of the off-chain messages signed with valid chainID as part of the chain’s offchain-state means that all of these off-chain messages can be reused on the different forks which share a common chainID history (up to where they differ). This is actually an important feature since as mentioned, users expect their signed messages to be valid from the time of signing. From that time onwards these messages should be considered as part of the chain’s offchain state. A hardfork should not thus render them invalid. This is similar to how the previous on-chain state is shared between 2 hardforks.
https://eips.ethereum.org/EIPS/eip-1962
https://eips.ethereum.org/EIPS/eip-1965
EIP-1959 solves the issue of EIP-1344 but do not attempt to protect from minority-led hardfork as mentioned in the rationale. We consider this a mistake, since it remove some freedom to fork. We consider that all fork should be given equal oportunities. And while there will always be issues we can’t solve for the majority that ignore a particular fork, users that decide to use both the minority-fork and the majority-chain should be protected from replay without having to wait for the majority chain to update its chainID.
EIP-1959 solves the issue of EIP-1344 but do not attempt to protect from minority-led hardfork as mentioned in the rationale. We consider this a mistake, since it remove some freedom to fork. We consider that all fork should be given equal oportunities. And while there will always be issues we can’t solve for the majority that ignore a particular fork, users that decide to use both the minority-fork and the majority-chain should be protected from replay without having to wait for the majority chain to update its chainID.
Since chainID and blockNumber will vary, they should not be part of the domain separator (meant to be generated once) but another part of the message.
https://eips.ethereum.org/EIPS/eip-1967
Holds the address of the beacon contract this proxy relies on (fallback). SHOULD be empty if a logic address is used directly instead, and should only be considered if the logic contract slot is empty. Changes to this slot SHOULD be notified by the event:
This EIP standardises the storage slot for the logic contract address, instead of a public method on the proxy contract as EIP-897 does. The rationale for this is that proxies should never expose functions to end users that could potentially clash with those of the logic contract.
https://eips.ethereum.org/EIPS/eip-1973
https://eips.ethereum.org/EIPS/eip-1985
However, setting the limit 2^32 - 1 is beneficial from a VM design perspective and we believe limiting memory should be done via carefully selecting the block gas limit.
All of these limits are already enforced mostly through the block gas limit. Since the out of range case results in a transaction failure, there should not be a change in behaviour.
https://eips.ethereum.org/EIPS/eip-1996
The account which decides if a hold should be executed.
The operationId is a string and not something more gas efficient to allow easy traceability of the hold and allow human readable ids. It is up to the implementer if the string should be stored on-chain or only its hash, as it is enough to identify a hold.
https://eips.ethereum.org/EIPS/eip-2003
https://eips.ethereum.org/EIPS/eip-2009
Currently there is no proposal on how to accomplish decentralized compliance checks. ERC-1462 proposes a basic set of functions to check if transfer, mint and burn are allowed for a user, but not how those checks should be implemented. This EIP proposes a way to implement them fully on-chain while being generic enough to leave the actual implementation of the checks up to the implementers, as these may vary a lot between different tokens.
Adds a token to the service, which allows the token to call the functions to update the accumulated. If an existing token id is used the function must revert. It is up to the implementer if adding a token should be restricted or not.
Replaces the address of a added token with another one. It is up to the implementer if replacing a token should be restricted or not, but a token should be able to replace its own address.
Replaces the address of a added token with another one. It is up to the implementer if replacing a token should be restricted or not, but a token should be able to replace its own address.
Removes a token from the service, which disallows the token to call the functions to update the accumulated. It is up to the implementer if removing a token should be restricted or not.
https://eips.ethereum.org/EIPS/eip-2014
Proposals wanting to introduce more data to the state, which is not part of blocks or transactions, should aim to extend the ESO.
Initially, a feature to read the current chain identifier is introduced: getCurrentChainId() returns the current chain identifier as a uint64 encoded value.
It should be a non-payable function, which means sending any value would revert the transaction as described in EIP-140.
This has been proposed as EIP-1344.
Note: It should be possible to introduce another interface checking the validity of a chain identifier in the chain history or for a given block (see EIP-1959 and EIP-1965).
https://eips.ethereum.org/EIPS/eip-2015
https://eips.ethereum.org/EIPS/eip-2018
The clearing process turns the promise of a transfer into the actual movement of money from one account to another. A clearing agent decides if the transfer can be executed or not. The amount which should be transferred is not deducted from the balance of the payer, but neither is it available for another transfer and therefore ensures, that the execution of the transfer will be successful when it is executed.
It is up to the implementer of the EIP if the transfer function of ERC-20 should always revert or is allowed under certain circumstances.
It is up to the implementer of the EIP if the transferFrom function of ERC-20 should always revert or is allowed under certain circumstances.
The operationId is a string and not something more gas efficient to allow easy traceability of the hold and allow human readable ids. It is up to the implementer if the string should be stored on-chain or only its hash, as it is enough to identify a hold.
https://eips.ethereum.org/EIPS/eip-2019
The operationId is a string and not something more gas efficient to allow easy traceability of the hold and allow human readable ids. It is up to the implementer if the string should be stored on-chain or only its hash, as it is enough to identify a hold.
https://eips.ethereum.org/EIPS/eip-2020
https://eips.ethereum.org/EIPS/eip-2021
The operationId is a string and not something more gas efficient to allow easy traceability of the hold and allow human readable ids. It is up to the implementer if the string should be stored on-chain or only its hash, as it is enough to identify a hold.
https://eips.ethereum.org/EIPS/eip-2025
There is a risk that the investors lose part of their contribution in the case that this EIP is rejected by the community between the time the funds have been collected and the beginning of the payout schedule. In this case all remaining funds will be returned to the contributors. The interest on the loan is an incentive for investors to participate in spite of this risk. Their downside is limited to the amount of funds spent before this EIP is accepted or rejected, which should be no more than about 5%, while their upside consists of the 10% simple interest paid over the period.
Historically there has been a precedent that the Ethereum Foundation is solely responsible for funding the development of Ethereum. This process has evolved as the development has become more distributed. Aya Miyaguchi observed in a recent Coindesk article, “it really is not only Ethereum Foundation people who are building [Ethereum]”. Yes, we could rely on the Ethereum Foundation to fund Eth1.X. But, why should we? This is a call for the network to come together and fund its own development. Ethereum the network is not owned by any one organization or group of people. We are lucky to have the EF and I consider this EIP in support of their coordination efforts.
https://eips.ethereum.org/EIPS/eip-2026
https://eips.ethereum.org/EIPS/eip-2027
https://eips.ethereum.org/EIPS/eip-2028
https://eips.ethereum.org/EIPS/eip-2029
https://eips.ethereum.org/EIPS/eip-2031
https://eips.ethereum.org/EIPS/eip-2035
https://eips.ethereum.org/EIPS/eip-2045
Adoption of fractional gas costs should only be an implementation detail inside the EVM, and not alter the current user experience around transaction gas limits and block gas limits. The concept of particles need not be exposed to Ethereum users nor most contract authors, but only to EVM implementers and contract developers concerned with optimized gas usage. Furthermore, only the EVM logic for charging gas per opcode executed should be affected by this change. All other contexts dealing with gas and gas limits, such as block headers and transaction formats, should be unaffected.
Adoption of fractional gas costs should only be an implementation detail inside the EVM, and not alter the current user experience around transaction gas limits and block gas limits. The concept of particles need not be exposed to Ethereum users nor most contract authors, but only to EVM implementers and contract developers concerned with optimized gas usage. Furthermore, only the EVM logic for charging gas per opcode executed should be affected by this change. All other contexts dealing with gas and gas limits, such as block headers and transaction formats, should be unaffected.
Adoption of fractional gas costs should only be an implementation detail inside the EVM, and not alter the current user experience around transaction gas limits and block gas limits. The concept of particles need not be exposed to Ethereum users nor most contract authors, but only to EVM implementers and contract developers concerned with optimized gas usage. Furthermore, only the EVM logic for charging gas per opcode executed should be affected by this change. All other contexts dealing with gas and gas limits, such as block headers and transaction formats, should be unaffected.
https://eips.ethereum.org/EIPS/eip-2046
Reduce the base gas cost of calling precompiles using STATICCALL from 700 to 40. This should allow more efficient use of precompiles as well as precompiles with a total cost below 700.
Only the STATICCALL instruction was changed to reduce the impact of the change. This should not be a limiting factor, given precompiles (currently) do not have a state and cannot change the state.
However, contracts created and deployed before Byzantium likely will not use STATICCALL and as a result this change will not reduce their costs.
This EIP should be backwards compatible. The only effect is that the cost is reduced. Since the cost is not reduced to zero, it should not be possible for a malicious proxy contract, when deployed before
the HF, to do any state changing operation.
This EIP should be backwards compatible. The only effect is that the cost is reduced. Since the cost is not reduced to zero, it should not be possible for a malicious proxy contract, when deployed before
the HF, to do any state changing operation.
https://eips.ethereum.org/EIPS/eip-2069
https://eips.ethereum.org/EIPS/eip-2070
https://eips.ethereum.org/EIPS/eip-2098
The ethers.js library supports this in v5
as an unofficial property of split signatures (i.e. sig._vs), but should be
considered an internal property that may change at discretion of the community
and any changes to this EIP.
https://eips.ethereum.org/EIPS/eip-2124
Instead of just taking the first 4 bytes of a Keccak256 hash (seems odd) or XOR-ing all the 4-byte groups (messy), CRC32 is a better alternative, as this is exactly what it was designed for. IEEE CRC32 is also used by ethernet, gzip, zip, png, etc, so every programming language support should not be a problem.
https://eips.ethereum.org/EIPS/eip-2135
https://eips.ethereum.org/EIPS/eip-2157
The TypeStorageContract pattern should ensure:
https://eips.ethereum.org/EIPS/eip-2159
The table below defines metrics which may be captured by Ethereum clients which expose metrics to Prometheus. Clients may expose additional metrics however these should not use the ethereum_ prefix.
https://eips.ethereum.org/EIPS/eip-2193
https://eips.ethereum.org/EIPS/eip-2200
An implementation should also note that with the above definition, if
the implementation uses call-frame refund counter, the counter can go
negative. If the implementation uses transaction-wise refund counter,
the counter always stays positive.
In order to keep in place the implicit reentrancy protection of
existing contracts, transactions should not be allowed to modify state
if the remaining gas is lower then the gas stipend given to
“transfer”/”send” in Solidity. These are other proposed remediations
and objections to implementing them:
Performing SSTORE has never been possible with less than 5000 gas, so
it does not introduce incompatibility to the Ethereum Mainnet. Gas
estimation should account for this requirement.
https://eips.ethereum.org/EIPS/eip-2228
Anybody that has travelled to certain countries and seen an “IPhone [sic]” repair store should immediately recognize that this is off-brand and unofficial. Likewise, the astute customer of Ethereum should recognize if they see the network referred to using inconsistent names in different software, so let’s avoid this.
Anybody that has travelled to certain countries and seen an “IPhone [sic]” repair store should immediately recognize that this is off-brand and unofficial. Likewise, the astute customer of Ethereum should recognize if they see the network referred to using inconsistent names in different software, so let’s avoid this.
These words literally mean nothing. The lowercase, not-proper-noun word “mainnet” is not a plain English word and it should not be in any dictionary. Do NOT use wording like this.
https://eips.ethereum.org/EIPS/eip-2242
For trust-minimized side chains with fraud proofs, we simply need to ensure that the side chain block proposer has attested that some data is available. Authentication can be performed as part of a fraud proof should that data end up invalid. Note that trust-minimized side chains with validity proofs can’t make use of the changes proposed in this EIP, as they required immediate authentication of the posted data. This will be the topic of a future EIP.
https://eips.ethereum.org/EIPS/eip-2255
These two methods are used to restrict a few hypothetical “restricted methods”. The first such method we would suggest should be included as part of the standard is eth_accounts.
https://eips.ethereum.org/EIPS/eip-2256
The wallet should display a UI to the user, showing the request.
The user can:
The chainId and types optional parameters enable dApps to provide options in order to restrict the selection list that the user will be presented with by the wallet, in accordance with the dApp’s functionality. The limit parameter enables the dApp to tell the user an upper limit of accounts that the user can select. It remains to be seen if a lower bound should also be provided. At the moment, this lower bound can be considered as being 1.
https://eips.ethereum.org/EIPS/eip-2266
The Atomic Swap-based American Call Option smart contract should follow the syntax and semantics of Ethereum smart contracts.
https://eips.ethereum.org/EIPS/eip-2304
In general, the native binary representation of the address should be used, without any checksum commonly used in the text representation.
Both address types should be stored in ENS by performing ripple’s version of base58check decoding and storing them directly (including version byte). For example, the ripple address rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn decodes to and is stored as 004b4e9c06f24296074f7bc48f92a97916c6dc5ea9, while the address X7qvLs7gSnNoKvZzNWUT2e8st17QPY64PPe7zriLNuJszeg decodes to and is stored as 05444b4e9c06f24296074f7bc48f92a97916c6dc5ea9000000000000000000.
Bitcoin Cash defines a new address format called ‘CashAddr’, specified here. This uses a variant of bech32 encoding to encode and decode (non-segwit) Bitcoin Cash addresses, using a prefix of ‘bitcoincash:’. A CashAddr should be decoded using this bech32 variant, then converted and stored based on its type (P2PKH or P2SH) as described in the relevant sections above.
https://eips.ethereum.org/EIPS/eip-2309
This can lead to bugs and unnecessary complex logic for platforms using these events to track token ownership. When transferring a single token it is acceptable to emit the original Transfer event, but the ConsecutiveTransfer event should not be emitted during the same transaction and vice-versa.
https://eips.ethereum.org/EIPS/eip-2315
This should jump into a subroutine, back out and stop.
This should execute fine, going into one two depths of subroutines
This should fail, since the given location is outside of the code-range.
This should fail at first opcode, due to shallow return_stack
In this example the RJUMPSUB is on the last byte of code. When the subroutine returns, it should hit the ‘virtual stop’ after the bytecode, and not exit with error
https://eips.ethereum.org/EIPS/eip-2327
Introduces a new opcode BEGINDATA, which indicates that the remaining bytes of the contract should be regarded as data rather than contract code
and cannot be executed.
Test cases should include:
1) A contract which jumps to a destination X, where X has a pc value higher than the BEGINDATA opcode, and the byte at X is 0x5b. This should fail with a BAD_JUMP_DESTINATION error.
2) A contract which encounters the BEGINDATA opcode (should stop executing the current call frame)
Test cases should include:
1) A contract which jumps to a destination X, where X has a pc value higher than the BEGINDATA opcode, and the byte at X is 0x5b. This should fail with a BAD_JUMP_DESTINATION error.
2) A contract which encounters the BEGINDATA opcode (should stop executing the current call frame)
Test cases should include:
1) A contract which jumps to a destination X, where X has a pc value higher than the BEGINDATA opcode, and the byte at X is 0x5b. This should fail with a BAD_JUMP_DESTINATION error.
2) A contract which encounters the BEGINDATA opcode (should stop executing the current call frame)
https://eips.ethereum.org/EIPS/eip-2330
https://eips.ethereum.org/EIPS/eip-2333
The child key derivation function takes in the parent’s private key and the index of the child and returns the child private key. The seed should ideally be derived from a mnemonic, with the intention being that BIP39 mnemonics, with the associated mnemonic_to_seed method be used.
https://eips.ethereum.org/EIPS/eip-2334
This level is designed to provide a set of related keys that can be used for any purpose. The idea being that a single account has many uses which are related yet should remain separate for security reasons. It is required to support this level in the tree, although, for many purposes it will remain 0.
The primary reason validators have separate signing and withdrawal keys is to allow for the different security concerns of actions within Eth2. The signing key is given to the validator client where it signs messages as per the requirements of being a validator, it is therefore a “hot key”. If this key is compromised, the worst that can happen (locally) is that a slashable message is signed, resulting in the validator being slashed and forcibly exited. The withdrawal key is only needed when a validator wishes to perform an action not related to validating and has access to the full funds at stake for that validator. The withdrawal key therefore has higher security concerns and should be handled as a “cold key”. By having the signing key be a child of the withdrawal key, secure storage of the withdrawal key is sufficient to recover the signing key should the need arise.
The primary reason validators have separate signing and withdrawal keys is to allow for the different security concerns of actions within Eth2. The signing key is given to the validator client where it signs messages as per the requirements of being a validator, it is therefore a “hot key”. If this key is compromised, the worst that can happen (locally) is that a slashable message is signed, resulting in the validator being slashed and forcibly exited. The withdrawal key is only needed when a validator wishes to perform an action not related to validating and has access to the full funds at stake for that validator. The withdrawal key therefore has higher security concerns and should be handled as a “cold key”. By having the signing key be a child of the withdrawal key, secure storage of the withdrawal key is sufficient to recover the signing key should the need arise.
https://eips.ethereum.org/EIPS/eip-2335
The C0, C1, and Delete control codes are not valid characters in the password and should therefore be stripped from the password. C0 are the control codes between 0x00 - 0x1F (inclusive) and C1 codes lie between 0x80 and 0x9F (inclusive). Delete, commonly known as “backspace”, is the UTF-8 character 7F which must also be stripped. Note that space (Sp UTF-8 0x20) is a valid character in passwords despite it being a pseudo-control character.
This standard makes use of the notion of a module which serves to represent, in an abstract sense, the different  cryptographic constructions and corresponding parameters for each component of the keystore. The idea being that components can be swapped out without affecting the rest of the specification should the need arise.
This field is an optional field to help explain the purpose and identify a particular keystores in a user-friendly manner. While this field can, and should, be used to help distinguish keystores from one-another, the description is not necessarily unique.
The pubkey is the public key associated with the the private key secured within the keystore. It is stored here to improve user experience and security which is achieved by not requiring users to enter their password just to obtain their public keys. This field is required if the secret being stored within the keystore is a private key. The encoding of the pubkey is specified in the in the appropriate signature standard (eg. BLS12-381 signature standard), but can be seen as a byte-string in the abstract and should be directly compatible with the appropriate signature library.
https://eips.ethereum.org/EIPS/eip-2364
EIP-2124 only defines how the forkid is calculated and validated, but does not specify how the forkid should be exchanged between peers. This EIP specifies the inclusion of the forkid as a new field in the Ethereum wire protocol (eth) handshake (releasing a new version, eth/64).
https://eips.ethereum.org/EIPS/eip-2378
https://eips.ethereum.org/EIPS/eip-2384
This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation. Therefore, it should be included in a scheduled hardfork at a certain block number. It’s suggested to include this EIP shortly after the Istanbul fork.
https://eips.ethereum.org/EIPS/eip-2386
Hierarchical deterministic wallets create keys from a seed and a path. The seed needs to be accessible to create new keys, however it should also be protected to the same extent as private keys to stop it from becoming an easy attack vector. The path, or at least the variable part of it, needs to be stored to ensure that keys are not duplicated. Providing a standard method to do this can promote interoperability between wallets and similar software.
https://eips.ethereum.org/EIPS/eip-2387
The existing implementation of the ice age, while it does work in practice, is unnecessarily complex to model and confusing to communicate to the community. Any updates to the design should be:
https://eips.ethereum.org/EIPS/eip-2390
https://eips.ethereum.org/EIPS/eip-2400
transaction_hash is mandatory. The hash must be looked up in the corresponding chain_id transaction history, if not found it should be looked into the pending transaction queue and rechecked until is found. If not found anequivalent error as “transaction not found error” should be shown instead of the transaction. When the transaction is pending, it should keep checking until the transaction is included in a block and becomes “unrevertable” (usually 12 blocks after transaction is included).
transaction_hash is mandatory. The hash must be looked up in the corresponding chain_id transaction history, if not found it should be looked into the pending transaction queue and rechecked until is found. If not found anequivalent error as “transaction not found error” should be shown instead of the transaction. When the transaction is pending, it should keep checking until the transaction is included in a block and becomes “unrevertable” (usually 12 blocks after transaction is included).
transaction_hash is mandatory. The hash must be looked up in the corresponding chain_id transaction history, if not found it should be looked into the pending transaction queue and rechecked until is found. If not found anequivalent error as “transaction not found error” should be shown instead of the transaction. When the transaction is pending, it should keep checking until the transaction is included in a block and becomes “unrevertable” (usually 12 blocks after transaction is included).
If events is not present, this means that the transaction receipt URI does not specify details, or that the transaction did not raised any events. Pending and failed transactions don’t validate events, however, when transaction is successful (or changes from pending to success) and events are present in URI, each event in the event_list must occur at least once in the transaction receipt event logs, otherwise an equivalent error as “event validation error: {event(s) [$event_signature, …] not found}” should be shown instead of the transaction. A URI might contain the event signature for all, some or none of the raised events.
https://eips.ethereum.org/EIPS/eip-2458
updated-by is reserved for EIPs in active status. For an EIP in status active, updates to that EIP, which update the header updated, should be started by opening a new EIP to start vetting for that update. When an active EIP receives a new entry to header updated, an associated updated-by EIP listing should be included, where that newly listed EIP has reached final status.
updated-by is reserved for EIPs in active status. For an EIP in status active, updates to that EIP, which update the header updated, should be started by opening a new EIP to start vetting for that update. When an active EIP receives a new entry to header updated, an associated updated-by EIP listing should be included, where that newly listed EIP has reached final status.
updates should be included as an EIP header, as all EIP headers, and include a reference to an EIP designation. When multiple EIP designations are referenced, each should be separated by a comma. Example:
updates should be included as an EIP header, as all EIP headers, and include a reference to an EIP designation. When multiple EIP designations are referenced, each should be separated by a comma. Example:
updates should be included as an EIP header, as all EIP headers, and include a reference to an EIP designation. When multiple EIP designations are referenced, each should be separated by a comma. Example:
updates should be included as an EIP header, as all EIP headers, and include a reference to an EIP designation. When multiple EIP designations are referenced, each should be separated by a comma. Example:
The syntax should align with previous EIP header syntax, as this EIP is not updating syntax, simply adding header options.
https://eips.ethereum.org/EIPS/eip-2464
This EIP proposes a tiny extension to the eth protocol, which permits nodes to agree on the set of transactions that need to be transferred across a network connection, before doing the costly exchange. This should help reduce the global (operational) bandwidth usage of the Ethereum network by at least an order of magnitude.
Similarly to GetPooledTransactions (0x09), NewPooledTransactionHashes (0x08) should also only operate on the transaction pool and should ignore the disk altogether. During healthy network conditions, a transaction will propagate through much faster than it’s included in a block, so it will essentially be non-existent that a newly announced transaction is already on disk. By avoiding disk deduplication, we can avoid a DoS griefing by remote transaction announces.
Similarly to GetPooledTransactions (0x09), NewPooledTransactionHashes (0x08) should also only operate on the transaction pool and should ignore the disk altogether. During healthy network conditions, a transaction will propagate through much faster than it’s included in a block, so it will essentially be non-existent that a newly announced transaction is already on disk. By avoiding disk deduplication, we can avoid a DoS griefing by remote transaction announces.
https://eips.ethereum.org/EIPS/eip-2470
Some contracts are designed to be Singletons which have the same address no matter what chain they are, which means that should exist one instance for all, such as EIP-1820 and EIP-2429. These contracts are usually deployed using a method known as Nick’s method, so anyone can deploy those contracts on any chain and they have a deterministic address.
This standard proposes the creation of a CREATE2 factory using this method, so other projects requiring this feature can use this factory in any chain with the same setup, even in development chains.
SingletonFactory does not allow sending value on create2, this was done to prevent different results on the created object.
SingletonFactory allows user defined salt to facilitate the creation of vanity addresses for other projects. If vanity address is not necessary, salt bytes(0) should be used.
Contracts that are constructed by the SingletonFactory MUST not use msg.sender in their constructor, all variables must came through initialization data. This is intentional, as if allowing a callback after creation to aid initialization state would lead to contracts with same address (but different chains) to have the same address but different initial state.
The resulting address can be calculated in chain by any contract using this formula: address(keccak256(bytes1(0xff), 0xce0042B868300000d44A59004Da54A005ffdcf9f, _salt, keccak256(_code)) << 96) or in javascript using https://github.com/ethereumjs/ethereumjs-util/blob/master/docs/README.md#const-generateaddress2.
Some contracts can possibly not support being deployed on any chain, or require a different address per chain, that can be safely done by using comparison in EIP-1344 in constructor.
Account contracts are singletons in the point of view of each user, when wallets want to signal what chain id is intended, EIP-1191 should be used.
Contracts deployed on factory must not use msg.sender in constructor, instead use constructor parameters, otherwise the factory would end up being the controller/only owner of those.
https://eips.ethereum.org/EIPS/eip-2474
https://eips.ethereum.org/EIPS/eip-2477
https://eips.ethereum.org/EIPS/eip-2481
The node that receives the GetBlockHeaders command should answer it with the BlockHeaders response command accordingly.
https://eips.ethereum.org/EIPS/eip-2488
This is a breaking change and has a potential to break contracts. The author expects no contracts of any value
should be affected.
https://eips.ethereum.org/EIPS/eip-2494
It is crucial that Baby Jubjub be safe against well-known attacks. To that end, we decided that the curve should pass SafeCurves security tests, as they are known for gathering the best known attacks against elliptic curves. Supporting evidence that Baby Jubjub satisfies the SafeCurves criteria can be found here.
https://eips.ethereum.org/EIPS/eip-2515
https://eips.ethereum.org/EIPS/eip-2520
Many applications are resolving ENS names to content hosted on distributed systems. To do this, they use contenthash record from ENS domain to know how to resolve names and which distributed system should be used.
However, the domain can store only one contenthash record which means that the site owner needs to decide which hosting system to use. Because there are many ENS-compatible hosting systems available (IPFS, Swarm, recently Onion and ZeroNet), and there will probably be even more in the future, lack of support for multiple records could become problematic. Instead, domains should be able to store multiple contenthash records to allow applications to resolve to multiple hosting systems.
https://eips.ethereum.org/EIPS/eip-2525
This presents a method to improve a universal method of login to the ethereum blockchain, leveraging the metadata storage provided by the ENS. We consider a user to be logged in when we have an EIP-1193 provider that can sign transaction and messages on his behalf. This method is inspired by Alex Van de Sande’s work and Web3Connect. In the future, the approach described here-after should be extended to work with any blockchain.
At this point, the app should process like with any web3 provider. Calling the enable() functions should ask the users for wallet specific credentials is needed.
At this point, the app should process like with any web3 provider. Calling the enable() functions should ask the users for wallet specific credentials is needed.
This workflow is to be implemented by an SDK that Dapp could easily import. The SDK would contain the resolution mechanism and support for both centralized and decentralized storage solution. Wallet-provider specific code should NOT be part of SDK. Wallet-provider specific code should only be present in the external file used to generate the web3 provider.
This workflow is to be implemented by an SDK that Dapp could easily import. The SDK would contain the resolution mechanism and support for both centralized and decentralized storage solution. Wallet-provider specific code should NOT be part of SDK. Wallet-provider specific code should only be present in the external file used to generate the web3 provider.
https://eips.ethereum.org/EIPS/eip-2535
The standard diamondCut function below is specified for the purpose of interoperability. Diamond tools, software and user-interfaces should expect and use the standard diamondCut function. Diamonds that might work with diamond specific tooling to add/replace/remove functions should implement the standard diamondCut function.
The standard diamondCut function below is specified for the purpose of interoperability. Diamond tools, software and user-interfaces should expect and use the standard diamondCut function. Diamonds that might work with diamond specific tooling to add/replace/remove functions should implement the standard diamondCut function.
Some loupe implementations are not gas efficient and should not be called in on-chain transactions. Some loupe implementations may be gas efficient and can be called in on-chain transactions. Read the documentation of the loupe implementation you use.
https://eips.ethereum.org/EIPS/eip-2537
One should note that base field modulus is equal to 3 mod 4 that allows an efficient square root extraction, although as described below gas cost of decompression is larger than gas cost of supplying decompressed point data in calldata.
Sane implementation of this EIP should not contain infinite cycles (it is possible and not even hard to implement all the functionality without while cycles) and gas schedule accurately reflects a time spent on computations of the corresponding function (precompiles pricing reflects an amount of gas consumed in the worst case where such case exists).
The following pseudofunction reflects how gas should be calculated:
The following pseudofunction reflects how gas should be calculated:
Subgroup check is mandatory during the pairing call. Implementations should use fast subgroup checks: at the time of writing multiplication gas cost is based on double-and-add multiplication method that has a clear “worst case” (all bits are equal to one). For pairing operation it’s expected that implementation uses faster subgroup check, e.g. by using wNAF multiplication method for elliptic curves that is ~ 40% cheaper with windows size equal to 4. (Tested empirically. Savings are due to lower hamming weight of the group order and even lower hamming weight for wNAF. Concretely, subgroup check for both G1 and G2 points in a pair are around 35000 combined).
https://eips.ethereum.org/EIPS/eip-2539
Subgroup check is mandatory during the pairing call. Implementations should use fast subgroup checks: at the time of writing multiplication gas cost is based on double-and-add multiplication method that has a clear “worst case” (all bits are equal to one). For pairing operation it’s expected that implementation uses faster subgroup check, e.g. by using wNAF multiplication method for elliptic curves that is ~ 40% cheaper with windows size equal to 4. (Tested empirically. Savings are due to lower hamming weight of the group order and even lower hamming weight for wNAF. Concretely, subgroup check for both G1 and G2 points in a pair are around 35000 combined).
https://eips.ethereum.org/EIPS/eip-2542
https://eips.ethereum.org/EIPS/eip-2544
Existing ENS clients that are compliant with EIP-137 will fail to resolve wildcard records and refuse to interact with them, while those compliant with EIP-2544 will continue to correctly resolve, or reject, existing ENS records. Resolvers wishing to implement the new resolve function for non-wildcard use-cases (eg, where the resolver is set directly on the name being resolved) should consider what to return to legacy clients that call the individual resolution functions for maximum compatibility.
Additionally, resolvers supporting completely arbitrary wildcard subdomain resolution will increase the likelihood of funds being sent to unintended recipients as a result of typos. Applications that implement such resolvers should consider making additional name validation available to clients depending on the context, or implementing features that support recoverability of funds.
There is also the possibility that some applications might require that no resolver be set for certain subdomains. For this to be problematic, the parent domain would need to successfully resolve the given subdomain node — to the knowledge of the authors, no application currently supports this feature or expects that subdomains should not resolve to a record.
https://eips.ethereum.org/EIPS/eip-2565
https://eips.ethereum.org/EIPS/eip-2566
https://eips.ethereum.org/EIPS/eip-2569
By calling the methods users should access an SVG image.
imageSvg: we use a string variable to save an SVG image file’s content.
An SVG image that will be saved in the imageSvg string should include at least two attributes:”name”, “desc”(description).
imageSvg: an SVG image’s file content. It is a string variable. Note: the SVG image should include at least three attributes:”name”, “description” and “issuer”.
https://eips.ethereum.org/EIPS/eip-2583
This scenario could be affected, but in practice should not be. Let’s consider the possibilities:
In summary, it would seem that ERC223 should not be affected, as long as the penalty does not go above around 3000 gas.
https://eips.ethereum.org/EIPS/eip-2584
https://eips.ethereum.org/EIPS/eip-2593
EIP 1559 is currently being championed as an improvement for the Ethereum protocol, and while I agree that the gas market is very inefficient, since a change like this will affect all client and wallet implementations, the Ethereum community should make sure to make a selection based on solid reasoning and justifications, which I believe 1559 is currently lacking.
We should then ask:
While I think a deeper simulation/analysis should be completed, I will share my expected results under these conditions.
https://eips.ethereum.org/EIPS/eip-2612
where DOMAIN_SEPARATOR is defined according to EIP-712. The DOMAIN_SEPARATOR should be unique to the contract and chain to prevent replay attacks from other domains,
and satisfy the requirements of EIP-712, but is otherwise unconstrained.
A common choice for DOMAIN_SEPARATOR is:
https://eips.ethereum.org/EIPS/eip-2615
https://eips.ethereum.org/EIPS/eip-2645
The key derivation should follow the following algorithm
https://eips.ethereum.org/EIPS/eip-2657
https://eips.ethereum.org/EIPS/eip-2666
Precompile repricings has happened in a past and can be considered standard procedure. Gas costs of many contracts is expected to reduce that may break re-entrancy protection measures based on fixed gas costs. In any case, such protection should have never been considered good and final.
https://eips.ethereum.org/EIPS/eip-2677
In all these (and future) cases, the EVM should fail with Out Of Gas error if the code has a length more than max_initcode_size.
For client implementations, this EIP makes attacks based on jumpdest-analysis or hashing of code less problematic, so should increase the robustness of clients.
Test cases should include the following cases,
https://eips.ethereum.org/EIPS/eip-2678
A prefixed hexadecimal value begins with 0x.
Unprefixed values have no prefix. Unless otherwise
specified, all hexadecimal values should be represented with the
0x prefix.
The following fields are defined for the package. Custom fields may
be included. Custom fields should be prefixed with x- to prevent
name collisions with future versions of the specification.
The sources field defines a source tree that should comprise the
full source tree necessary to recompile the contracts contained in this
release.
Definitions for different objects used within the Package. All objects
allow custom fields to be included. Custom fields should be prefixed
with x- to prevent name collisions with future versions of the
specification.
The name field is a string which must be a valid
Identifier. Any link references which should be
linked with the same link value should be given the same name.
The name field is a string which must be a valid
Identifier. Any link references which should be
linked with the same link value should be given the same name.
The value field defines the value which should be written when linking the corresponding bytecode.
To reference the address of a Contract
Instance from the current package the value
should be the name of that contract instance.
The license field declares the license associated with this package.
This value should conform to the
SPDX
format. Packages should include this field. If a file Source
Object defines its own license, that license takes
precedence for that particular file over this package-scoped meta
license.
The license field declares the license associated with this package.
This value should conform to the
SPDX
format. Packages should include this field. If a file Source
Object defines its own license, that license takes
precedence for that particular file over this package-scoped meta
license.
The links field provides URIs to relevant resources associated with
this package. When possible, authors should use the following keys
for the following common resources.
The type field declares the type of the source file. The field
should be one of the following values: solidity, vyper,
abi-json, solidity-ast-json.
The version field defines the version of the compiler. The field
should be OS agnostic (OS not included in the string) and take the
form of either the stable version in
semver format or if built on a
nightly should be denoted in the form of <semver>-<commit-hash> ex:
0.4.8-commit.60cc1668.
The version field defines the version of the compiler. The field
should be OS agnostic (OS not included in the string) and take the
form of either the stable version in
semver format or if built on a
nightly should be denoted in the form of <semver>-<commit-hash> ex:
0.4.8-commit.60cc1668.
The settings field defines any settings or configuration that was used
in compilation. For the "solc" compiler, this should conform to
the Compiler Input and Output
Description.
The <genesis hash> represents the blockhash of the first block on the
chain, and <latest confirmed block hash> represents the hash of the
latest block that’s been reliably confirmed (package managers should be
free to choose their desired level of confirmations).
The set of EVM instructions as produced by a compiler. Unless otherwise
specified this should be assumed to be hexadecimal encoded, representing
a whole number of bytes, and prefixed with 0x.
In cases where there is a single deployed instance of a given Contract
Type, package managers should use the
Contract Alias for that contract type for this
name.
In cases where there are multiple deployed instances of a given contract
type, package managers should use a name which provides some added
semantic information as to help differentiate the two deployed instances
in a meaningful way.
Compilers are now defined in a top-level array, simplifying the task for tooling to identify the compiler types
needed to interact with or validate the contract assets. This also removes unnecessarily duplicated
information, should multiple contractTypes share the same compiler type.
https://eips.ethereum.org/EIPS/eip-2680
Locations for wallet stores are defined to be within each user’s personal space, reducing the possibility of accidental exposure of information. It is, however, still possible for permissions to be set such that this data is world-readable, and applications implementing this EIP should attempt to set, and reset, permissions to ensure that only the relevant user has access to the information.
https://eips.ethereum.org/EIPS/eip-2681
While this is a breaking change, no actual effect should be visible:
https://eips.ethereum.org/EIPS/eip-2696
If the Provider supports a JSON-RPC (https://www.jsonrpc.org/specification) request as specified elsewhere, then it MUST accept a request call for that JSON-RPC method with the RequestArguments.method argument matching the JSON-RPC method string for the RPC call and the RequestArguments.params matching the params object of the RPC call. The RequestArguments.params should be encoded as a JavaScript object matching the specified JSON-RPC type, not encoded as a JSON string as would normally be the case when transporting JSON-RPC.
If the Provider is unable to fulfill a request for any reason, it MUST resolve the promise as an error. The resolved error MUST be shaped as a ProviderRpcError defined above whenever possible. While it is impossible to guaranteed that a JavaScript application will never throw an out of memory or stack overflow error, care should be taken to ensure that promise rejections conform to the above shape whenever possible.
While this standard is perhaps not the greatest mechanism for communicating between an application and a blockchain, it is closely aligned with established practices within the community so migration from existing systems to this one should be relatively easy. Most communication is currently done via JSON-RPC, so aligning with the JSON-RPC standard was desired to enable quick integration with existing systems.
https://eips.ethereum.org/EIPS/eip-2700
https://eips.ethereum.org/EIPS/eip-2711
https://eips.ethereum.org/EIPS/eip-2718
https://eips.ethereum.org/EIPS/eip-2733
Transaction packages should be executed as follows:
Allowing child packages to specify a range of acceptable gas prices is
strictly more versatile than a static price. It gives relayers more flexibility
in terms of building transaction bundles, and it makes it possible for relayers
to try and achieve the best price for the transaction sender. With a fixed
price, the relayer may require the user to sign multiple different
transactions, with varying prices. This can be avoided by specifying a max
price, and communicating out-of-band how the urgency of the transaction (e.g.
the relayer should package it with the max price immediately vs. slowly
increasing the gas price).
A future transaction type can be specified with only a single
signature, if such an optimization is desired.
https://eips.ethereum.org/EIPS/eip-2746
The deployer of the contract should be the owner and administrator, allowing for the addition of Attributes and RuleTrees. Since a RuleTree is owned by a particular EOA (or contract address), the only accounts that should be able to execute the RuleTree should be its owner or the contract’s owner/administrator. If Attributes are defined to exist as data within other contracts, the implementation must take into account the possibility that RuleTree owners must have the security to access the data in those contracts.
The deployer of the contract should be the owner and administrator, allowing for the addition of Attributes and RuleTrees. Since a RuleTree is owned by a particular EOA (or contract address), the only accounts that should be able to execute the RuleTree should be its owner or the contract’s owner/administrator. If Attributes are defined to exist as data within other contracts, the implementation must take into account the possibility that RuleTree owners must have the security to access the data in those contracts.
The deployer of the contract should be the owner and administrator, allowing for the addition of Attributes and RuleTrees. Since a RuleTree is owned by a particular EOA (or contract address), the only accounts that should be able to execute the RuleTree should be its owner or the contract’s owner/administrator. If Attributes are defined to exist as data within other contracts, the implementation must take into account the possibility that RuleTree owners must have the security to access the data in those contracts.
https://eips.ethereum.org/EIPS/eip-2767
An ERC-2767 Governance Contract should reference an address through token() that implements ERC-20 interface. token() is allowed to return self address (address(this)), if ERC-20 functionalities are implemented in the same contract (one can consider checking out Diamond Standard ERC-2535 to optimise contract size).
An ERC-2767 Governance Contract should also implement ERC-165. This helps general tools to identify whether a contract is a ERC-2767 Governance contract.
https://eips.ethereum.org/EIPS/eip-2770
https://eips.ethereum.org/EIPS/eip-2771
This means a recipient contract should be very careful which forwarder it
trusts and whether this can be modified. The power to change the forwarder
trusted by a recipient is equivalent to giving full control over the contract.
If this kind of control over the recipient is acceptable, it is recommended
that only the owner of the recipient contract be able to modify which forwarder
is trusted. Otherwise best to leave it unmodifiable, as in the example above.
https://eips.ethereum.org/EIPS/eip-2780
Reducing the intrinsic cost of a transaction from 21,000 to 7,000 gas will make sending transactions cheaper,
is easily achievable, and does not incur technical debt.
However, such a change should only be made after it is determined that it does not impose non-negligble externalities, specifically:
While the benefits of reducing transactions’ intrinsic cost are appearant,
such a change should be applied if it impose no negative externalities,
or if such effects are negligible.
A testnet applying this change should be deployed to test the effect of this change on uncle rate.
https://eips.ethereum.org/EIPS/eip-2786
https://eips.ethereum.org/EIPS/eip-2803
https://eips.ethereum.org/EIPS/eip-2831
The implementation was chosen to help the ease of implementation for both providers and dapp developers. Since ProviderMessage is widely used by dapp developers already it means that the implementation path would be as trivial as adding and additional if clause to their existing message listener. This also provides a benefit to dapps in the event that a provider has not yet implemented the events, it will not cause the dapp panic with undefined should it be implemented natively (eg: ethereum.txCancel(...) which would error with ethereum.txReplacement() is not a function).
Many Providers adopted EIP-1193, as this EIP extends the same event logic, there should be no breaking changes. All providers that do not support the new events should either I) Ignore the subscription or II) Provide some error to the user.
Many Providers adopted EIP-1193, as this EIP extends the same event logic, there should be no breaking changes. All providers that do not support the new events should either I) Ignore the subscription or II) Provide some error to the user.
https://eips.ethereum.org/EIPS/eip-2844
An additional property kid with the value which represents the DID, and the keyFragment that was used to sign the JWS should be added to the protected header (details).
An additional property kid with the value which represents the DID, and the keyFragment that was used to sign the JWS should be added to the protected header (details). When revocable is set to false the JWS signature should not be possible to revoke. For some DID methods like. did:key this is always the case. For other methods which support key revocation it is necessary to include the version-id in the kid to refer to a specific version of the DID document. When revocable is set to true version-id must not be included in the kid for DID methods that support key revocation.
An additional property kid with the value which represents the DID, and the keyFragment that was used to sign the JWS should be added to the protected header (details). When revocable is set to false the JWS signature should not be possible to revoke. For some DID methods like. did:key this is always the case. For other methods which support key revocation it is necessary to include the version-id in the kid to refer to a specific version of the DID document. When revocable is set to true version-id must not be included in the kid for DID methods that support key revocation.
If the cleartext object contains a property paths that contains an array of strings and one of the paths in there are already authenticated using did_authenticate the decryption should happen without user confirmation.
A simple permission system is proposed where clients can request permissions though path prefixes, e.g. /some/permission. When decryption of a JWE is requested the wallet should check if the decrypted payload contains a paths property. If this property doesn’t exist the user may be prompted to confirm that the given rpc connection (app) is allowed to read the decrypted data. If the paths property is present in the decrypted data it should contain an array of string paths. If one of the these path prefixes matches with one of the path prefixes the user has already granted permission for then decryption should happen automatically without any user confirmation.
A simple permission system is proposed where clients can request permissions though path prefixes, e.g. /some/permission. When decryption of a JWE is requested the wallet should check if the decrypted payload contains a paths property. If this property doesn’t exist the user may be prompted to confirm that the given rpc connection (app) is allowed to read the decrypted data. If the paths property is present in the decrypted data it should contain an array of string paths. If one of the these path prefixes matches with one of the path prefixes the user has already granted permission for then decryption should happen automatically without any user confirmation.
A simple permission system is proposed where clients can request permissions though path prefixes, e.g. /some/permission. When decryption of a JWE is requested the wallet should check if the decrypted payload contains a paths property. If this property doesn’t exist the user may be prompted to confirm that the given rpc connection (app) is allowed to read the decrypted data. If the paths property is present in the decrypted data it should contain an array of string paths. If one of the these path prefixes matches with one of the path prefixes the user has already granted permission for then decryption should happen automatically without any user confirmation.
The main security consideration of this EIP is the suggested permission system. Here various threat models could be considered. However, this EIP does not go into details about how it should work other than suggesting an approach. In the end it is up to wallet implementations to choose how to ask their users for consent.
https://eips.ethereum.org/EIPS/eip-2848
Because content multihash is always stored into the chain, clients can download that content from Content Addressable Network (like IPFS or Swarm) or from central servers. In the latter case, a client should always check the integrity of the received messages, or it must warn the user if it cannot do that (feature not implemented or in error).
https://eips.ethereum.org/EIPS/eip-2876
In general, contracts that implement the contract interface should forward funds received to the deposit(bytes8) function to their cold wallet account. This address SHOULD be hard coded as a constant OR take advantage of the immutable keyword in solidity versions >=0.6.5.
https://eips.ethereum.org/EIPS/eip-2917
https://eips.ethereum.org/EIPS/eip-2926
The transition process involves reading all contracts in the state and applying the above procedure to them. A benchmark showing how long this process will take is still pending, but intuitively it should take longer than the time between two blocks (in the order of hours). Hence we recommend clients to pre-process the changes before the EIP is activated.
https://eips.ethereum.org/EIPS/eip-2929
The sets are transaction-context-wide, implemented identically to other transaction-scoped constructs such as the self-destruct-list and global refund counter. In particular, if a scope reverts, the access lists should be in the state they were in before that scope was entered.
Another option is EIP-2930, which would have a similar effect to POKE but is more general: it also works for the EOA -> contract -> contract case, and generally should work for all known cases of breakage due to gas cost increases. This option is more complex, though it is arguably a stepping stone toward access lists being used for other use cases (regenesis, account abstraction, SSA all demand access lists).
https://eips.ethereum.org/EIPS/eip-2930
This is done because it maximizes simplicity, avoiding questions of what to prevent duplication against: just between two addresses/keys in the access list, between the access list and the tx sender/recipient/newly created contract, other restrictions? Because gas is charged per item, there is no gain and only cost in including a value in the access list twice, so this should not lead to extra chain bloat in practice.
https://eips.ethereum.org/EIPS/eip-2935
https://eips.ethereum.org/EIPS/eip-2936
https://eips.ethereum.org/EIPS/eip-2937
https://eips.ethereum.org/EIPS/eip-2938
A new EIP-2718 transaction with type AA_TX_TYPE is introduced. Transactions of this type are referred to as “AA transactions”. Their payload should be interpreted as rlp([nonce, target, data]).
https://eips.ethereum.org/EIPS/eip-2942
https://eips.ethereum.org/EIPS/eip-2970
https://eips.ethereum.org/EIPS/eip-2972
https://eips.ethereum.org/EIPS/eip-2976
If a client chooses to ignore the SHOULD recommendation for disconnecting peers that send unknown transaction types they may be susceptible to DoS attacks.
Ignoring this recommendation should be limited to trusted peers only, or other situations where the risk of DoS is extremely low.
https://eips.ethereum.org/EIPS/eip-2980
https://eips.ethereum.org/EIPS/eip-2981
This standard allows contracts, such as NFTs that support ERC-721 and ERC-1155 interfaces, to signal a royalty amount to be paid to the NFT creator or rights holder every time the NFT is sold or re-sold. This is intended for NFT marketplaces that want to support the ongoing funding of artists and other NFT creators. The royalty payment must be voluntary, as transfer mechanisms such as transferFrom() include NFT transfers between wallets, and executing them does not always imply a sale occurred. Marketplaces and individuals implement this standard by retrieving the royalty payment information with royaltyInfo(), which specifies how much to pay to which address for a given sale price. The exact mechanism for paying and notifying the recipient will be defined in future EIPs. This ERC should be considered a minimal, gas-efficient building block for further innovation in NFT royalty payments.
Many of the largest NFT marketplaces have implemented bespoke royalty payment solutions that are incompatible with other marketplaces. This standard implements standardized royalty information retrieval that can be accepted across any type of NFT marketplace. This minimalist proposal only provides a mechanism to fetch the royalty amount and recipient. The actual funds transfer is something which the marketplace should execute.
This EIP does not specify the manner of payment to the royalty recipient. Furthermore, it is impossible to fully know and efficiently implement all possible types of royalty payments logic. With that said, it is on the royalty payment receiver to implement all additional complexity and logic for fee splitting, multiple receivers, taxes, accounting, etc. in their own receiving contract or off-chain processes. Attempting to do this as part of this standard, it would dramatically increase the implementation complexity, increase gas costs, and could not possibly cover every potential use-case. This ERC should be considered a minimal, gas-efficient building block for further innovation in NFT royalty payments. Future EIPs can specify more details regarding payment transfer and notification.
https://eips.ethereum.org/EIPS/eip-2982
https://eips.ethereum.org/EIPS/eip-2997
https://eips.ethereum.org/EIPS/eip-3000
ERC-3000 should be seen as a public good of top of which public infrastrastructure will be built, being way more important than any particular implementation or the interests of specific companies or projects.
https://eips.ethereum.org/EIPS/eip-3005
The EIP-2612 (permit() function) also requires a nonce mapping. At this point, I’m not sure yet if this mapping should be re-used in case a smart contract implements both EIP-3005 and EIP-2612.
At the first glance, it seems the nonces mapping from EIP-2612 could be re-used, but this should be thought through (and tested) for possible security implications.
Why not reverting the whole on-chain transaction? Because there could be only one problematic meta transaction, and the others should not be dropped just because of one rotten apple.
Solution: Each meta transaction should have an “expiry date”. This is defined in a form of a block number by which the meta transaction must be relayed on-chain.
This addition could open new security implications, that’s why it is left out of this proof-of-concept. But anyone who wishes to implement it should know about this potential constraint, too.
https://eips.ethereum.org/EIPS/eip-3009
https://eips.ethereum.org/EIPS/eip-3014
https://eips.ethereum.org/EIPS/eip-3026
https://eips.ethereum.org/EIPS/eip-3030
The eth2 specification does not explicitly provide a directive on where this BLS private key must/should be stored, leaving this implementation detail to the client teams, who assume that this cryptographic secret is stored on the same host as the validator client.
It is in this perspective, that any procedure to create, update, or delete keys should be built separate from the client implementation.
https://eips.ethereum.org/EIPS/eip-3041
https://eips.ethereum.org/EIPS/eip-3044
https://eips.ethereum.org/EIPS/eip-3045
https://eips.ethereum.org/EIPS/eip-3046
https://eips.ethereum.org/EIPS/eip-3068
Due to recent work, the
128-bit security promised by the BN256 elliptic curve no longer applies;
this was mentioned in the Cloudflare BN256
library.
There has been some discussion on the exact security decrease
from this advancement; see these
two
papers
for different estimates.
The more conservative estimate puts the security of BN256 at
100-bits.
While this is likely still out of reach for many adversaries,
it should give us pause.
This reduced security was noted in the recent MadNet
whitepaper,
and this security concern was partially mitigated by
requiring Secp256k1 signatures of the partial group signatures
in order for those partial signatures to be valid.
Full disclosure: the author of this EIP works for MadHive,
assisted in the development of MadNet, and
helped write the MadNet whitepaper.
https://eips.ethereum.org/EIPS/eip-3074
A well-behaved contract should never reach an AUTHCALL without having successfully set authorized beforehand. The safest behavior, therefore, is to exit the current frame of execution immediately. This is especially important in the context of transaction sponsoring / relaying, which is expected to be one of the main use cases for this EIP. In a sponsored transaction, the inability to distinguish between a sponsee-attributable fault (like a failing sub-call) and a sponsor-attributable fault (like a failing AUTH) is especially dangerous and should be prevented because it charges unfair fees to the sponsee.
A well-behaved contract should never reach an AUTHCALL without having successfully set authorized beforehand. The safest behavior, therefore, is to exit the current frame of execution immediately. This is especially important in the context of transaction sponsoring / relaying, which is expected to be one of the main use cases for this EIP. In a sponsored transaction, the inability to distinguish between a sponsee-attributable fault (like a failing sub-call) and a sponsor-attributable fault (like a failing AUTH) is especially dangerous and should be prevented because it charges unfair fees to the sponsee.
A user will specifically interact with an invoker they trust. Because they trust this contract to execute faithfully, they will “commit” to certain properties of a call they would like to make by computing a hash of the call values. They can be certain that the invoker will only allow they call to proceed if it is able to verify the values committed to (e.g. a nonce to protect against replay attacks). This certainty arises from the commit value that is signed over by the user. This is the hash of values which the invoker will validate. A safe invoker should accept the values from the user and compute the commit hash itself. This ensures that invoker operated on the same input that user authorized.
A solution to this would be at the same time that EOAs are removed, to modify the logic of AUTH to actually call into the account with some standard message and allow the account to determine if the signature / witness is valid. Further research should be done to understand how invokers would need to change in this situation and how best to write them in a future-compatible manner.
The following is a non-exhaustive list of checks/pitfalls/conditions that invokers should be wary of:
https://eips.ethereum.org/EIPS/eip-3076
https://eips.ethereum.org/EIPS/eip-3085
For security reasons, a wallet should always attempt to validate the chain metadata provided by the requester, and may choose to fetch the metadata elsewhere entirely.
Either way, only the wallet can know which chain metadata it needs from the requester in order to “add” the chain.
Therefore, all parameters except chainId are specified as optional, even though a wallet may require them in practice.
Since the chain ID used for transaction signing determines which chain the transaction is valid for, handling the chain ID correctly is of utmost importance.
The wallet should:
Therefore, the wallet should:
A wallet that implements wallet_addEthereumChain should expect to encounter requests for chains completely unknown to the wallet maintainers.
That said, community resources exist that can be leveraged to verify requests for many Ethereum chains.
The wallet should maintain a list of known chains, and verify requests to add chains against that list.
Indeed, a wallet may even prefer its own chain metadata over anything submitted with a wallet_addEthereumChain request.
A wallet that implements wallet_addEthereumChain should expect to encounter requests for chains completely unknown to the wallet maintainers.
That said, community resources exist that can be leveraged to verify requests for many Ethereum chains.
The wallet should maintain a list of known chains, and verify requests to add chains against that list.
Indeed, a wallet may even prefer its own chain metadata over anything submitted with a wallet_addEthereumChain request.
Adding a new chain to the wallet can have significant implications for the wallet’s functionality and the experience of the user.
A chain should never be added without the explicit consent of the user, and different chains should be clearly differentiated in the wallet UI.
In service of these goals, the wallet should:
Adding a new chain to the wallet can have significant implications for the wallet’s functionality and the experience of the user.
A chain should never be added without the explicit consent of the user, and different chains should be clearly differentiated in the wallet UI.
In service of these goals, the wallet should:
Adding a new chain to the wallet can have significant implications for the wallet’s functionality and the experience of the user.
A chain should never be added without the explicit consent of the user, and different chains should be clearly differentiated in the wallet UI.
In service of these goals, the wallet should:
Although a request to add a chain that was already added should generally be considered a success, treating such requests as automatic successes leaks information to requesters about the chains a user has added to their wallet.
In the interest of preserving user privacy, implementers of wallet_addEthereumChain should consider displaying user confirmations even in these cases.
If the user denies the request, the wallet should return the same user rejection error as normal so that requesters cannot learn which chains are supported by the wallet without explicit permission to do so.
Although a request to add a chain that was already added should generally be considered a success, treating such requests as automatic successes leaks information to requesters about the chains a user has added to their wallet.
In the interest of preserving user privacy, implementers of wallet_addEthereumChain should consider displaying user confirmations even in these cases.
If the user denies the request, the wallet should return the same user rejection error as normal so that requesters cannot learn which chains are supported by the wallet without explicit permission to do so.
Although a request to add a chain that was already added should generally be considered a success, treating such requests as automatic successes leaks information to requesters about the chains a user has added to their wallet.
In the interest of preserving user privacy, implementers of wallet_addEthereumChain should consider displaying user confirmations even in these cases.
If the user denies the request, the wallet should return the same user rejection error as normal so that requesters cannot learn which chains are supported by the wallet without explicit permission to do so.
https://eips.ethereum.org/EIPS/eip-3091
This EIP was designed with existing API routes in mind to reduce disruption. Incompatible block explorers should include either 301 redirects to their existing API routes to match this EIP.
https://eips.ethereum.org/EIPS/eip-3102
https://eips.ethereum.org/EIPS/eip-3135
In prepayment business model such as using token as recharge card of general store, the user pays (crypto)currency to store in advance for claimable token as recharge card (with bonus or discount). When checking out, the customer signs a message with updated consumption (old consumption + consumption this time) to store and store verifies this message off chain. The shopping process loops without any blockchain involved, until the customer wants to return the card and get money back. Because the store already holds all currency, the withdraw function should be executed by token issuer (store) to return remaining deposit balance after claim. The prepayment model can easily be built into a wallet with QR-code scanning function.
If we run a paid end-to-end encrypted e-mail service that accepts token as payment, we can use lock-release model. Unlike prepayment, we charge X * N token for an e-mail sent to N recipients. In this “pay for usage” scenario, the counting of services happens on both client and server side. The client should not trust charge amount given by server in case the it’s malfunctioning or malicious. When client decide not to trust server, it stops signing messages, but some of token is taken hostage in deposit balance. To fix this problem, the withdraw function should be executed by payer account with limitation such as epoch didn’t change in a month.
If we run a paid end-to-end encrypted e-mail service that accepts token as payment, we can use lock-release model. Unlike prepayment, we charge X * N token for an e-mail sent to N recipients. In this “pay for usage” scenario, the counting of services happens on both client and server side. The client should not trust charge amount given by server in case the it’s malfunctioning or malicious. When client decide not to trust server, it stops signing messages, but some of token is taken hostage in deposit balance. To fix this problem, the withdraw function should be executed by payer account with limitation such as epoch didn’t change in a month.
https://eips.ethereum.org/EIPS/eip-3143
https://eips.ethereum.org/EIPS/eip-3155
Clients should be able to execute simple transactions as well as code and return traces. In the following, we will call this client CUT (client under test) and use go-ethereums evm binary for code examples.
At the end of execution, the CUT MUST print some summerical info, this info SHOULD have the following fields.
The summary should be a single jsonl object.
Tracing is expensive.
Exposing an endpoint for creating traces publicly could open up a denial of service vector.
Clients should consider putting trace endpoints behind a separate flag from other endpoints.
https://eips.ethereum.org/EIPS/eip-3156
https://eips.ethereum.org/EIPS/eip-3198
Assuming current block base fee is 7 wei.
This should push the value 7 (left padded byte32) to the stack.
https://eips.ethereum.org/EIPS/eip-3220
Hence there is need for a more robust blockchain identifier that will overcome these drawbacks, especially for crosschain operations where multiple chains are involved. A blockchain identifier (crosschain id) should be unique and satisfy the following requirements:
Preventing relay attack: Although crosschain id by itself is different from chainid and it is not signed into blockchain transaction, the crosschain id can still be used for presenting relay attack. An application that handles crosschain transaction can verified the crosschain id with its blockhash and decide whether the transaction is valid or not. Any transaction with a non-verifiable crosschain id should be rejected.
https://eips.ethereum.org/EIPS/eip-3224
During evaluation, the ADDRESS (i.e. to), CALLER
(i.e. from), VALUE, and GASPRICE must be the same as the
values for the transaction being described, so that the
code generating the description can rely on them. For signing
described messages, VALUE should always be 0.
When executing the bytecode, best efforts should be made to
ensure BLOCKHASH, NUMBER, TIMESTAMP and DIFFICULTY
match the "latest" block. The COINBASE should be the zero
address.
When executing the bytecode, best efforts should be made to
ensure BLOCKHASH, NUMBER, TIMESTAMP and DIFFICULTY
match the "latest" block. The COINBASE should be the zero
address.
Clients which manage private keys should expose additional
methods for interacting with the related accounts.
If an user interface is not present or expected for any other
account-based operations, the description strings should be
ignored and the described data used directly.
If the wallet contains a user interface for accepting or
denying signing a message, it should present the description
string to the user. Optionally, a wallet may wish to
additionally provide a way to examine the described data.
If the wallet contains a user interface for accepting or
denying a transaction, it should present the description string
along with fee and value information. Optionally, a wallet may
wish to additionally provide a way to further examine the
transaction.
If the wallet contains a user interface for accepting or
denying a transaction, it should present the description string
along with fee and value information. Optionally, a wallet may
wish to additionally provide a way to further examine the
transaction.
All signatures for messages are generated using EIP-191
which had a previously compatible version byte of 0x00, so
there should be no concerns with backwards compatibility.
Applications implementing this EIP to sign message data should
ensure there are no collisions within the data which could
result in ambiguously signed data.
If an abort occurs during signing, the response from this call
should match the response from a declined signing request;
otherwise this could be used for enumeration attacks, etc. A
random interactive-scale delay should also be added, otherwise
a < 10ms response could be interpreted as an error.
If an abort occurs during signing, the response from this call
should match the response from a declined signing request;
otherwise this could be used for enumeration attacks, etc. A
random interactive-scale delay should also be added, otherwise
a < 10ms response could be interpreted as an error.
https://eips.ethereum.org/EIPS/eip-3234
The protocols on the receiving end of the flash mints will need to ensure their contracts can handle this. One obvious way is to leverage OpenZeppelin’s SafeMath libraries as a catch-all safety net, however consideration should be given to when it is or isn’t used given the gas tradeoffs.
https://eips.ethereum.org/EIPS/eip-3238
Even after the Ethereum 2.0 mainnet launch, Ethash proof-of-work mining on the legacy chain should be feasible. It should allow miners sealing new blocks every 13~15 seconds on average for another ten months and allow both Ethereum 1.x and Ethereum 2.0 developers to conclude the merge.
Even after the Ethereum 2.0 mainnet launch, Ethash proof-of-work mining on the legacy chain should be feasible. It should allow miners sealing new blocks every 13~15 seconds on average for another ten months and allow both Ethereum 1.x and Ethereum 2.0 developers to conclude the merge.
This EIP is not forward compatible and introduces backwards incompatibilities in the difficulty calculation. Therefore, it should be included in a scheduled hardfork at a certain block number. It’s suggested to consider this EIP either with or shortly after the Berlin hard-fork but not later than July 2021.
https://eips.ethereum.org/EIPS/eip-3267
Because this EIP solves a similar problem, cancel any other EIPs that burn ETH (except gas fees) during transfers or mining. (TBD: We should transfer more ETH in this EIP than we burned accordingly older accepted EIPs, because this EIP has the additional advantages of: 1. funding common goods; 2. better aligning values of ETH and values of tokens).
https://eips.ethereum.org/EIPS/eip-3298
The description above is sufficient to describe the change, but for the sake of clarity we enumerate all places where gas refunds are currently used and which should/could be removed within a node implementation.
https://eips.ethereum.org/EIPS/eip-3300
Persisted refunds would become worthless before they fall below their activation cost.
Once the refunds are worthless, they can be removed by another hard fork without waiting for 0.
The rate of diminishing specified would currently require (24000-5000) * 100 = 1,900,000 blocks for SELFDESTRUCT and (15000-5000) * 100 = 1,000,000 blocks for SSTORE.
This timeframe is currently about a year, which should be enough flexibility for the remaining refunds to be consumed.
https://eips.ethereum.org/EIPS/eip-3322
Most accounts will store no gas, so the per-account storage overhead should be minimal or even zero in the normal case.
https://eips.ethereum.org/EIPS/eip-3326
In light of this, the wallet should:
Automatically rejecting requests for chains that aren’t supported or have yet to be added by the wallet allows requesters to infer which chains are supported by the wallet.
Wallet implementers should consider whether this communication channel violates any security properties of the wallet, and if so, take appropriate steps to mitigate it.
https://eips.ethereum.org/EIPS/eip-3332
Post EIP-1559 MEDGASPRICE (0x46) should return the median effective_gas_price of the previous block.
The name MEDGASPRICE was chosen because the median gas price of the network can only be calculated from the latest complete block. Thus transactions being executed should expect the median gas price to be calculated from the previous block.
https://eips.ethereum.org/EIPS/eip-3336
https://eips.ethereum.org/EIPS/eip-3337
A new opcode MLOADFP is introduced with value 0x5e. This opcode acts in all ways identical to MLOAD, except that the value of the frame pointer is added to the address before loading data from memory. An attempt to load data from a negative address should be treated identically to an invalid opcode, consuming all gas and reverting the current execution context.
A new opcode MSTOREFP is introduced with value 0x5f. This opcode acts in all ways identical to MSTORE, except that the value of the frame pointer is added to the address before storing data to memory. An attempt to store data to a negative address should be treated identically to an invalid opcode, consuming all gas and reverting the current execution context.
This EIP exclusively introduces new opcodes, and as a result should not impact any existing programs unless they operate under the assumption that these opcodes are undefined, which we believe will not be the case.
https://eips.ethereum.org/EIPS/eip-3338
While this is a breaking change, no actual effect should be visible:
https://eips.ethereum.org/EIPS/eip-3368
2 years was chosen because it gives miners sufficient time to find alternative uses for their hardware and/or get their hardware back out onto the open market (e.g., in the form of gaming GPUs) without flooding the market suddenly. This proposal should ONLY be considered as a last resort as something we have in our pocket should the “network need to attract hashing power quickly and then bleed it off over time” rather than “something that is scheduled to be included in X hard fork” ; Recommendation to have in a fast track state, but NOT deployed to mainnet unless needed.
2 years was chosen because it gives miners sufficient time to find alternative uses for their hardware and/or get their hardware back out onto the open market (e.g., in the form of gaming GPUs) without flooding the market suddenly. This proposal should ONLY be considered as a last resort as something we have in our pocket should the “network need to attract hashing power quickly and then bleed it off over time” rather than “something that is scheduled to be included in X hard fork” ; Recommendation to have in a fast track state, but NOT deployed to mainnet unless needed.
https://eips.ethereum.org/EIPS/eip-3372
Finally, Ethereum has always sought to pursue “minimum issuance”. By reducing the amount of miners that can pose a threat to the network, Ethereum also decreases how much it needs to pay for protection. Some EIP’s are being prepared to increase miner incomes post EIP-1559 should a threat appear. EIP-3372 eliminates the need to pay more for security and allows miners to be paid less without compromising the network’s security. As we go forward closer to the merge, the community must reduce attack vectors so as to reduce the cost of the merge itself and maximize the security of the network. The community already pays too much for protection and by reducing threats we can reduce this cost. ASIC warehouse farms are dumping all the ETH they make which is suppressing the price of ETH. Although rare, several individual GPU miners are taking part in staking or have gone on to join the community in development or our financial endeavors. They thus are more valuable to the community than a warehouse of future junk. There is no need for the Ethereum community to continue to pay for soon-to-be obsolete hardware that will end up in landfills.
https://eips.ethereum.org/EIPS/eip-3374
https://eips.ethereum.org/EIPS/eip-3382
Both Ethereum’s Proof of Work and Proof of Stake designs assume that block producers are financially rational, but does not assume block producers to be benevolent. There is one exception however, and it is when block producers choose the gas limit of a block where it is assumed that block producers care about the long term health and decentralisation of the chain. Indeed, the block gas limit is one of the only parameters in Ethereum that is not dictated by node consensus, but instead is chosen by block producers. This decision was initially made to allow urgent changes in the block gas limit if necessary. Both drastically increasing or decreasing this parameter could have serious consequences that may not be desired. It is therefore a critical parameter that should require node consensus to avoid any sudden harmful change imposed by a small number of actors on the rest of the network.
https://eips.ethereum.org/EIPS/eip-3386
This standard outlines a smart contract interface to wrap identifiable tokens with fungible tokens. This allows for derivative ERC-20 tokens to be minted by locking the base ERC-721 non-fungible tokens and ERC-1155 multi tokens into a pool. The derivative tokens can be burned to redeem base tokens out of the pool. These derivatives have no reference to the unique id of these base tokens, and should have a proportional rate of exchange with the base tokens. As representatives of the base tokens, these generic derivative tokens can be traded and otherwise utilized according to ERC-20, such that the unique identifier of each base token is irrelevant.
Prices should not be necessarily fixed. therefore, Mint/Burn events MUST include the ERC-20 _value minted/burned.
https://eips.ethereum.org/EIPS/eip-3403
Refunds are not visible to transaction execution, so this should not have any impact on transaction execution logic.
The maximum amount of gas that can be spent on execution in a block is limited to the gas limit, if we do not count zero-to-nonzero SSTOREs that were later reset back to zero. It is okay to not count those, because if such an SSTORE is reset, storage is not expanded and the client does not need to actually adjust the Merke tree; the gas consumption is refunded, but the effort normally required by the client to process those opcodes is also cancelled. Clients should make sure to not do a storage write if new_value = original_value; this was a prudent optimization since the beginning of Ethereum but it becomes more important now.
https://eips.ethereum.org/EIPS/eip-3416
https://eips.ethereum.org/EIPS/eip-3436
Add a four step block rule to Clique that should reduce block production deadlocks
There has been more than one deadlock in the Goerli multi-client Clique network. The number of
active validators was greater than 1/2 of the available validators so a chain halt should not have
occurred. The halt was resolved by an inactive validator coming back on line. The state of the chain
was in one of two configurations of 8 validators that can result in a chain halt. Three of the four
clients observed a choice sequence of lowest total difficulty followed by first observed block. Geth
added one extra rule of preferring the shortest chain before preferring the first observed block.
This fork would have resolved itself with Geth’s rule, but there is still a configuration where the
chain can halt with a shortest chain rule.
When a Clique validator is arbitrating the canonical status between two different chain head blocks,
they should choose the canonical block with the following ordered priorities.
When resolving rule 3 clients should use the following formula, where validator_index is the integer
index of the validator that signed the block when sorted as per epoch checkpointing,
header_number is the number of the header, and validator_count is the count of the current
validators. Clients should choose the block with the largest value. Note that an in-turn block
is considered to be the most recent in-turn block.
When resolving rule 3 clients should use the following formula, where validator_index is the integer
index of the validator that signed the block when sorted as per epoch checkpointing,
header_number is the number of the header, and validator_count is the count of the current
validators. Clients should choose the block with the largest value. Note that an in-turn block
is considered to be the most recent in-turn block.
When resolving rule 4 the hash should be converted into an unsigned 256 bit integer.
For the first scenario where chains of different lengths can halt consider a block with 8
validators, whose addresses sort to the same order as their designation in this example. A fully
in-order chain exists and validator number 8 has just produced an in-turn block and then validators
5, 7 and 8 go offline, leaving validators 1 to 6 to produce blocks. Two forks form, one with an
in-order block from validator 1 and then an out of order block from validator 3. The second fork
forms from validators 2, 4, and 6 in order. Both have a net total difficulty of 3 more than the
common ancestor. So in this case if both forks become aware of the other fork then both are
considered equally viable and neither set of validators should switch to the newly observed fork. In
this case, adding a shortest chain rule would break the deadlock as the even numbered validators
would adopt the shorter chain.
One consideration when formulating the rules is that the block choice should be chosen so that it
would encourage the maximum amount of in-order blocks. Selecting a chain based on shortest chain
implicitly prefers the chain with more in-order blocks. When selecting between competing out of
order chains the validator who is closest to producing an in-order block in the future should have
their chain declined so that they are available to produce an in-order block sooner.
One consideration when formulating the rules is that the block choice should be chosen so that it
would encourage the maximum amount of in-order blocks. Selecting a chain based on shortest chain
implicitly prefers the chain with more in-order blocks. When selecting between competing out of
order chains the validator who is closest to producing an in-order block in the future should have
their chain declined so that they are available to produce an in-order block sooner.
At least one client has been observed producing multiple blocks at the same height with the same
difficulty, so a final catch-all standard of lowest block hash should break any remaining ties.
https://eips.ethereum.org/EIPS/eip-3440
This extension gives an artist the ability to designate an original edition, set the maximum supply of editions as well as print the editions and uses the tokenURI extension to supply a link to the art work. To minimize the risk of an artist changing this value after selling an original piece this function can only happen once. Ensuring that these functions can only happen once provides consistency with uniqueness and verifiability. Due to this, the reference implementation handles these features in the constructor function. An edition may only be signed once, and care should be taken that the edition is signed correctly before release of the token/s.
https://eips.ethereum.org/EIPS/eip-3448
https://eips.ethereum.org/EIPS/eip-3450
The additional data may hint to an attacker of the existence of other keys and the scheme under which they are stored. Therefore, the ID should be stored in a way that obscures its use.
https://eips.ethereum.org/EIPS/eip-3475
https://eips.ethereum.org/EIPS/eip-3508
Atomically, the ORIGINDATALOAD and ORIGINDATACOPY values should be considered insecure as they can easily be spoofed by creating an entry smart contract with the appropriate function signature and arguments that consequently invokes other contracts within the call chain. In brief, one should always assume that tx.data != calldata and these instructions should not be used as an introspection tool alone.
Atomically, the ORIGINDATALOAD and ORIGINDATACOPY values should be considered insecure as they can easily be spoofed by creating an entry smart contract with the appropriate function signature and arguments that consequently invokes other contracts within the call chain. In brief, one should always assume that tx.data != calldata and these instructions should not be used as an introspection tool alone.
Atomically, the ORIGINDATALOAD and ORIGINDATACOPY values should be considered insecure as they can easily be spoofed by creating an entry smart contract with the appropriate function signature and arguments that consequently invokes other contracts within the call chain. In brief, one should always assume that tx.data != calldata and these instructions should not be used as an introspection tool alone.
This would lead to an increase in memory consumption, however, this increase should be negligible if at all existent given that the data of a transaction should already exist in memory as part of its execution process; a step in the overall inclusion of a transaction within a block.
This would lead to an increase in memory consumption, however, this increase should be negligible if at all existent given that the data of a transaction should already exist in memory as part of its execution process; a step in the overall inclusion of a transaction within a block.
https://eips.ethereum.org/EIPS/eip-3520
The ENTRYPOINT (0x4a) instruction alone has no perceivable benefit as it can be replaced by the AUTHCALL (0xf7) instruction and as such should solely be introduced to the system in conjunction with the ORIGINDATA* opcodes defined in EIP-3508.
However, this type of introspection should solely be applied on pre-approved contracts rather than user-defined ones as the value stemming from this type of introspection entirely relies on a contract’s code immutability and proper function, both of which a user supplied contract can easily bypass.
The instructions of this EIP should not be utilized as a way to discriminate between EOA callers and smart contracts, as this type of differentiation can be broken by an AUTHCALL as defined in the specification chapter.
The behaviour of the ENTRYPOINT opcode during a contract creation will result in the opcode yielding the zero-address as the first address interacted with in the transaction. This should be taken into account by contract implementations in a similar fashion to how ecrecover invalid signatures are handled to prevent software misbehaviours from arising.
https://eips.ethereum.org/EIPS/eip-3521
The cost of calldata was  thoroughly analyzed in EIP-2028 to determine
a fair value that is not susceptible to denial-of-service attacks. We consider
this the lower bound on how much transaction data should cost. Since there is
no computation burden imposed for adding tx.to to the accessed_addresses
map (it’s added by default by EIP-2929), there is no reason to charge more than
the absolute minimum for the data.
https://eips.ethereum.org/EIPS/eip-3525
If a smart contract wants to be informed when they receive values from other addresses, it should implement all of the functions in the IERC3525Receiver interface, in the implementation it can decide whether to accept or reject the transfer. See “Transfer Rules” for further detail.
The second one allows value transfers from one token (specified by _fromTokenId) to an address (specified by _to), the value is actually transferred to a token owned by the address, and the id of the destination token should be returned. Further explanation can be found in the ‘design decision’ section for this method.
This token standard is designed to represent semi-fungible assets, which are most suited for financial instruments rather than collectibles or in-game items. For maximum transparency and safety of digital assets, we strongly recommend that all implementations should generate metadata directly from contract code rather than giving out an off-chain server URL.
Both implementations described above should be treated as compliant with this standard.
The value level approval and slot level approval(optional) is isolated from EIP-721 approval models, so that approving value should not affect EIP-721 level approvals, implementations of this EIP must obey this principle.
https://eips.ethereum.org/EIPS/eip-3529
Refunds are not visible to transaction execution, so this should not have any impact on transaction execution logic.
The maximum amount of gas that can be spent on execution in a block is limited to the gas limit, if we do not count zero-to-nonzero SSTOREs that were later reset back to zero. It is okay to not count those, because if such an SSTORE is reset, storage is not expanded and the client does not need to actually adjust the Merke tree; the gas consumption is refunded, but the effort normally required by the client to process those opcodes is also cancelled. Clients should make sure to not do a storage write if new_value = original_value; this was a prudent optimization since the beginning of Ethereum but it becomes more important now.
https://eips.ethereum.org/EIPS/eip-3534
The chainContext value should be of the form ANNOTATION_COMPOSITE_PREFIX || [{subclass value}...], where
The chainContext value should be encoded as ANNOTATION_COMPOSITE_PREFIX || rlp[{subclass value}...].
The values defined as subclasses below acts as constraints on transaction validity for specific chain contexts.
Transactions defining constraints which are not satisfied by their chain context should be rejected as invalid.
Blocks containing invalid transactions should be rejected as invalid themselves, per the status quo.
The values defined as subclasses below acts as constraints on transaction validity for specific chain contexts.
Transactions defining constraints which are not satisfied by their chain context should be rejected as invalid.
Blocks containing invalid transactions should be rejected as invalid themselves, per the status quo.
chainContext values annotating more than one subclass reference should provide those values in the following sequential order:
As above, the ANNOTATION_COMPOSITE_PREFIX should be the sum of the designated subclass’ ANNOTATION_PREFIXs.
The ANCESTOR_ID is a reference to a specific block by concatenating the byte representation of a block number and the first 4 bytes of its hash.
The block number’s should be encoded as a big endian value and should have left-padding 0’s removed.
The block number value may be omitted in case of reference to the genesis block.
The ANCESTOR_ID is a reference to a specific block by concatenating the byte representation of a block number and the first 4 bytes of its hash.
The block number’s should be encoded as a big endian value and should have left-padding 0’s removed.
The block number value may be omitted in case of reference to the genesis block.
The ANCESTOR_ID value should be RLP encoded as a byte array for hashing and transmission.
The ELIGIBLE_MINER_LIST value should be of the type [{20 bytes}+], where + means “one or more of the thing to the left.”
Non-unique values are not permitted.
The ELIGIBLE_MINER_LIST value should be RLP encoded for hashing and transmission.
The INELIGIBLE_MINER_LIST value should be of the type [{20 bytes}+], where + means “one or more of the thing to the left.”
Non-unique values are not permitted.
The INELIGIBLE_MINER_LIST value should be RLP encoded for hashing and transmission.
The EXPIRY value should be RLP encoded as an integer for hashing and transmission.
ANNOTATION_PREFIX values’ use of octal-derived values, ie. 1, 2, 4, 8, 16, 32, 64, 128, follows a conventional pattern of representing combinations from a limited set uniquely and succinctly, eg. Unix-style file permissions.
This EIP defines four of the eight possible context subclasses; this seems to leave plenty of room for future growth in this direction if required.
If this limit is met or exceeded, doing so will require a hard fork de facto (by virtue of making consensus protocol facing changes to transaction validation schemes), so revising this scheme as needed should be only incidental and trivial.
Miners who do not find themselves listed in an annotated eligibleMinerList should be expected to immediately remove the transaction from their transaction pool.
In a pessimistic outlook, we should also expect that these ineligible nodes would not offer rebroadcasts of these transactions, potentially impacting the distribution (and availability) of the transactions to their intended miners. On the other hand, miners are incentivized to make themselves available for reception of such transactions, and there are many ways this is feasible both on-network and off-.
A final consideration is the economics of a whitelisted miner concerning the processing order of transactions in which they are whitelisted and those without whitelists.
Transactions without whitelists would appear at first glean to be more competitive, and thus should be processed with priority.
However, miners following such a strategy may find their reputation diminished, and, in the worst case, see the assertive preferences of transaction authors shift to their competitors and beyond their reach.
However, there are associated costs to the “dodging” miner that should be considered.
Validation of ancestorId demands the assertion of a positive database hit by block number (thereby cross-referencing a stored block’s hash).
This necessary lookup can be (and maybe already is) cached, but we must expect less than 100% hits on cached values, since the lookup value is arbitrary.
With that in mind, however, the value provided to a transaction using a deep ancestorId is increasingly marginal, so we should expect
most transactions using this field to use a relatively small set of common, shallow, cache-friendly values.
https://eips.ethereum.org/EIPS/eip-3540
The values for PC and JUMP/JUMPI start with 0 and are within the code section. We considered keeping PC/JUMP/JUMPI values to operate on the whole container and be consistent with CODECOPY/EXTCODECOPY but in the end decided otherwise. It looks to be much easier to propose EOF extensions that affect jumps and jumpdests when JUMP/JUMPI already operates on indexes within code section only. This also feels more natural and easier to implement in EVM: the new EOF EVM should only care about traversing code and accessing other parts of the container only on special occasions (e.g. in CODECOPY instruction).
All cases should be checked for creation transaction, CREATE and CREATE2.
Proposed validation rules can be checked at constant time, therefore it should not be easily attackable. This is subject to change with future extensions.
Currently initcode validation has no extra cost and the currently charged creation costs should be sufficient, however we consider adding an additional gas cost for contract creation.
https://eips.ethereum.org/EIPS/eip-3541
Contracts using unassigned opcodes are generally understood to be at risk of changing semantics. Hence using the unassigned 0xEF should have lesser effects, than choosing an assigned opcode, such as 0xFD (REVERT), 0xFE (INVALID), or 0xFF (SELFDESTRUCT). Arguably while such contracts may not be very useful, they are still using valid opcodes.
https://eips.ethereum.org/EIPS/eip-3554
https://eips.ethereum.org/EIPS/eip-3561
Storage slot 0x7913203adedf5aca5386654362047f05edbd30729ae4b0351441c46289146720 (obtained as bytes32(uint256(keccak256('eip3561.proxy.zero.trust.period')) - 1)).
Zero Trust Period in amount of blocks, can only be set higher than previous value. While it is at default value(0), the proxy operates exactly as standard EIP-1967 transparent proxy. After zero trust period is set, all above specification is enforced.
Admin interactions with this slot should correspond with this method and event:
Propose block adds to convenience if used, so should be kept.
https://eips.ethereum.org/EIPS/eip-3569
There is not a way for the smart contract layer to communicate with a storage layer and as such we need a solution which provides a way for potential NFT collectors on Ethereum to verify that their NFT will not be “rug pulled”. This standard provides a solution for that. By allowing creators to seal their NFTs during or after creation, they are provided with full flexibility when it comes to creating their NFTs. Decentralized storage means permanence - in the fast-moving world of digital marketing campaigns, or art projects mistakes can happen. As such, it is important for creators to have flexibility when creating their projects. Therefore, this standard allows creators to opt in at a time of their choosing. Mistakes do happen and metadata should be flexible enough so that creators can fix mistakes or create dynamic NFTs (see Beeple’s CROSSROAD NFT). If there comes a time when the NFT metadata should be immortalized, then the creator can call the seal method. Owners, potential owners, or platforms can verify that the NFT was sealed and can check the returned URI. If the sealedURI return value is not hosted on a decentralized storage platform, or the isSealed method does not return true for the given NFT ID then it can be said that one cannot trust that these NFTs will not change at a future date and can then decide if they want to proceed with collecting the given NFT.
There is not a way for the smart contract layer to communicate with a storage layer and as such we need a solution which provides a way for potential NFT collectors on Ethereum to verify that their NFT will not be “rug pulled”. This standard provides a solution for that. By allowing creators to seal their NFTs during or after creation, they are provided with full flexibility when it comes to creating their NFTs. Decentralized storage means permanence - in the fast-moving world of digital marketing campaigns, or art projects mistakes can happen. As such, it is important for creators to have flexibility when creating their projects. Therefore, this standard allows creators to opt in at a time of their choosing. Mistakes do happen and metadata should be flexible enough so that creators can fix mistakes or create dynamic NFTs (see Beeple’s CROSSROAD NFT). If there comes a time when the NFT metadata should be immortalized, then the creator can call the seal method. Owners, potential owners, or platforms can verify that the NFT was sealed and can check the returned URI. If the sealedURI return value is not hosted on a decentralized storage platform, or the isSealed method does not return true for the given NFT ID then it can be said that one cannot trust that these NFTs will not change at a future date and can then decide if they want to proceed with collecting the given NFT.
By including metadata for many NFTs in one JSON file we can eliminate the need for many transactions to set the metadata for multiple NFTs. Given that this file should not change NFT platforms, or explorers can cache the metadata within the file.
https://eips.ethereum.org/EIPS/eip-3584
https://eips.ethereum.org/EIPS/eip-3589
The safest way to do batch swap, is to transform batch swap into atomic swap, i.e. one to one swap. But first we should “assemble” those ether, ERC-20 tokens, ERC-721 tokens and ERC-1155 tokens together, and this is the main purpose of this EIP.
Before using mint or safeMint functions, user should be aware that some implementations of tokens are pausable. If one of the assets get paused after assembled into one NFT, the burn function may not be executed successfully. Platforms using this standard should make support lists or block lists to avoid this situation.
Before using mint or safeMint functions, user should be aware that some implementations of tokens are pausable. If one of the assets get paused after assembled into one NFT, the burn function may not be executed successfully. Platforms using this standard should make support lists or block lists to avoid this situation.
https://eips.ethereum.org/EIPS/eip-3607
However, the yellow paper does not explicitly specify how a client should handle the case where a transaction is sent from an account that already has contract code deployed; presumably because this was considered infeasible at the time. The assumption is that most client would allow this transaction in their current state.
We note that it was always the expected that a contract account’s behaviour is constrained by the code in that contract – which means that the account’s funds should not suddenly be spendable by some private key. It was just implicitly assumed in the past that a 160 bit address length is enough to provide collision resistance, and thus that this case could never occur. In that sense, this EIP should be seen as a clarification of protocol behaviour in a previously undefined case rather than an explicit upgrade of consensus rules.
We note that it was always the expected that a contract account’s behaviour is constrained by the code in that contract – which means that the account’s funds should not suddenly be spendable by some private key. It was just implicitly assumed in the past that a 160 bit address length is enough to provide collision resistance, and thus that this case could never occur. In that sense, this EIP should be seen as a clarification of protocol behaviour in a previously undefined case rather than an explicit upgrade of consensus rules.
Private networks may have deployed contracts which also work as EOAs at genesis and should check that this upgrade does not impact their workflows.
Every transaction sent by the private key corresponding to 0x715656... (
b71c71a67e1177ad4e901695e1b4b9ee17ae16c6668d313eac2f96dbcda3f291) should be rejected.
These transaction must be rejected and not included in a block.
This EIP is a strict security upgrade: It simply makes some transactions that were formerly valid now invalid. There is no legitimate use for such transactions, so there should be no security downsides.
https://eips.ethereum.org/EIPS/eip-3643
Standards should be backwards compatible with ERC-20 and should be able to interact with ERC-735 to validate the claims linked to an ONCHAINID, based on ERC-734 and ERC-735.
The standard defines several interfaces that are described hereunder:
Standards should be backwards compatible with ERC-20 and should be able to interact with ERC-735 to validate the claims linked to an ONCHAINID, based on ERC-734 and ERC-735.
The standard defines several interfaces that are described hereunder:
The token contract should be upgradeable without changing its address on the blockchain, therefore, we decided to make it proxiable through ERC-1822 (Universal Upgradeable Proxy Standard)
https://eips.ethereum.org/EIPS/eip-3651
Direct COINBASE payments are becoming increasingly popular because they allow conditional payments, which provide benefits such as implicit cancellation of transactions that would revert.
But accessing COINBASE is overpriced; the address is initially cold under the access list framework introduced in EIP-2929.
This gas cost mismatch can incentivize alternative payments besides ETH, such as ERC20, but ETH should be the primary means of paying for transactions on Ethereum.
The addresses currently initialized warm are the addresses that should already be loaded at the start of transaction validation.
The ORIGIN address is always loaded to check its balance against the gas limit and the gas price.
The tx.to address is always loaded to begin execution.
The COINBASE address should also be always be loaded because they receive the block reward as well as the transaction fees.
The addresses currently initialized warm are the addresses that should already be loaded at the start of transaction validation.
The ORIGIN address is always loaded to check its balance against the gas limit and the gas price.
The tx.to address is always loaded to begin execution.
The COINBASE address should also be always be loaded because they receive the block reward as well as the transaction fees.
https://eips.ethereum.org/EIPS/eip-3668
callbackFunction is the 4-byte function selector for a function on the original contract to which a callback should be sent.
If the client successfully calls the gateway, the callback function specified in the OffchainLookup error will be invoked by the client, with response set to the value returned by the gateway, and extraData set to the value returned in the contract’s OffchainLookup error. The contract MAY initiate another CCIP read lookup in this callback, though authors should bear in mind that the limits on number of recursive invocations will vary from client to client.
The URLs returned by a contract may be of any schema, but this specification only defines how clients should handle HTTPS URLs.
In order to prevent a malicious client from causing unintended effects when making transactions using CCIP read, contracts MUST implement appropriate checks on the extraData returned to them in the callback. Any sanity/permission checks performed on input data for the initial call MUST be repeated on the data passed through the extraData field in the callback. For example, if a transaction should only be executable by an authorised account, that authorisation check MUST be done in the callback; it is not sufficient to perform it with the initial call and embed the authorised address in the extraData.
https://eips.ethereum.org/EIPS/eip-3670
Each case should be tested for creation transaction, CREATE and CREATE2.
https://eips.ethereum.org/EIPS/eip-3675
https://eips.ethereum.org/EIPS/eip-3690
https://eips.ethereum.org/EIPS/eip-3709
For wallets and providers, if a user submits a transaction for signing with where TransactionType == 0x1, the developer should upgrade the transaction to meet the criteria of transaction of type 2.
https://eips.ethereum.org/EIPS/eip-3722
There was some discussion around whether or not an post ID should also be emitted, whether the content should be a string or bytes, and whether or not anything at all should actually be emitted.
There was some discussion around whether or not an post ID should also be emitted, whether the content should be a string or bytes, and whether or not anything at all should actually be emitted.
There was some discussion around whether or not an post ID should also be emitted, whether the content should be a string or bytes, and whether or not anything at all should actually be emitted.
At the application level, clients should confirm that posts including a "from" field that differs from msg.sender have been authorized by the "from" address via a "permissions" post, otherwise they should be considerred invalid or a post from msg.sender.
At the application level, clients should confirm that posts including a "from" field that differs from msg.sender have been authorized by the "from" address via a "permissions" post, otherwise they should be considerred invalid or a post from msg.sender.
Clients should also be sure to sanitize post data.
https://eips.ethereum.org/EIPS/eip-3754
https://eips.ethereum.org/EIPS/eip-3756
https://eips.ethereum.org/EIPS/eip-3770
https://eips.ethereum.org/EIPS/eip-3772
This specification is to be used by a new smart contract for managing its internal state so that any state mutating calls to it can be cheaper. These compressed values on a smart contract’s state are something that should not be exposed to the external world (other smart contracts or clients). A smart contract should expose a decompressed value if needed.
This specification is to be used by a new smart contract for managing its internal state so that any state mutating calls to it can be cheaper. These compressed values on a smart contract’s state are something that should not be exposed to the external world (other smart contracts or clients). A smart contract should expose a decompressed value if needed.
The CInt64 format is intended only for storage, while dev should convert it to uint256 form using suitable logic (decompress or decompressRoundingUp) to perform any arithmetic on it.
In general, one should follow the rule:
Compression is only useful when writing to storage while doing arithmetic with them should be done very carefully.
It can be a problem for volatile tokens if the coin is extremely volatile wrt user’s native currency. Imagine a very unlikely case where a coin goes 256x up (price went up by 1016 lol). In such cases uint56 might not be enough as even its least significant bit is very valuable. If such insanely volatile tokens are to be stored, you should store more significant bits, i.e. using cint96 or cint128.
https://eips.ethereum.org/EIPS/eip-3779
We can validate the safety of contracts with a static analysis that takes time and space linear in the size of the code, as shown below. And since we can, we should.
https://eips.ethereum.org/EIPS/eip-3788
The configuration set by the node is the main source of truth, and thus should be explicitly used
when deciding how to filter out a transaction. This check should exist in two places, as a filter
on the JSON-RPC (eg: eth_sendTransaction), and strictly enforced on the EVM during transaction
validation.
The configuration set by the node is the main source of truth, and thus should be explicitly used
when deciding how to filter out a transaction. This check should exist in two places, as a filter
on the JSON-RPC (eg: eth_sendTransaction), and strictly enforced on the EVM during transaction
validation.
It should be noted this will not prevent a malicious actor from deploying a network with chainId = 1, or copying any other networks chainId.
https://eips.ethereum.org/EIPS/eip-3855
https://eips.ethereum.org/EIPS/eip-3860
Already deployed contracts should not be effected, but certain transactions (with initcode beyond the proposed limit) would still be includable in a block, but result in an exceptional abort.
For client implementations, this EIP makes attacks based on jumpdest-analysis less problematic, so should increase the robustness of clients.
Tests should include the following cases:
https://eips.ethereum.org/EIPS/eip-3978
Since EIP-3298, the gas refund mechanism works for storage restores only inside the same transaction. But on revert, the gas refund is not increased; it is completely erased.
It can even be cheaper to transfer tokens back at the end of a transaction instead of reverting, to keep the existing gas refund.
This should be changed.
Gas should reflect the cost of use.
The revert cost reflects the cost of access during execution, but not the cost of modification.
https://eips.ethereum.org/EIPS/eip-4200
This functionality does not preclude the EVM from introducing other forms of control flow later on. RJUMP/RJUMPI can efficiently co-exists with a higher-level declaration of functions, where static relative jumps should be used for intra-function control flow.
Because the destinations are validated upfront, the cost of these instructions are less than their dynamic counterparts: RJUMP should cost 5, and RJUMPI should cost 7. This is a reduction of 2 gas, compared to JUMP and JUMPI.
Because the destinations are validated upfront, the cost of these instructions are less than their dynamic counterparts: RJUMP should cost 5, and RJUMPI should cost 7. This is a reduction of 2 gas, compared to JUMP and JUMPI.
Note: EIP-3670 should reject PC.
If we chose absolute addressing, then RJUMP could be viewed similar to the sequence PUSHn JUMP (and RJUMPI similar to PUSHn RJUMPI). In that case one could argue that instead of introducing a new instruction, such sequences should get a discount, because EVMs could optimise them.
Both of these are risky. Furthermore we think that EVM implementations should be free to chose what optimisations they apply, and the savings do not need to be passed down at all cost.
https://eips.ethereum.org/EIPS/eip-4337
To prevent replay attacks (both cross-chain and multiple EntryPoint implementations), the signature should depend on chainid and the EntryPoint address.
The simulated call performs the full validation, calling both wallet.validateUserOp and (if specified) paymaster.validatePaymasterUserOp.
The two operations differ in their opcode banning policy.
In order to distinguish between the two, there is a single call to the NUMBER opcode (block.number), used as a delimiter between wallet validation restrictions and paymaster validation restrictions.
While simulating op validation, the client should make sure that:
During batching, the client should:
After creating the batch, before including the transaction in a block, the client should:
If any of the three conditions is violated, the client should reject the op. If both calls succeed (or, if op.paymaster == ZERO_ADDRESS and the first call succeeds) without violating the three conditions, the client should accept the op. On a bundler node, the storage keys accessed by both calls must be saved as the accessList of the UserOperation
If any of the three conditions is violated, the client should reject the op. If both calls succeed (or, if op.paymaster == ZERO_ADDRESS and the first call succeeds) without violating the three conditions, the client should accept the op. On a bundler node, the storage keys accessed by both calls must be saved as the accessList of the UserOperation
When a bundler includes a bundle in a block it must ensure that earlier transactions in the block don’t make any UserOperation fail. It should either use access lists to prevent conflicts, or place the bundle as the first transaction in the block.
The forbidden opcodes are to be forbidden when depth > 2 (i.e. when it is the wallet, paymaster, or other contracts called by them that are being executed). They are: GASPRICE, GASLIMIT, DIFFICULTY, TIMESTAMP, BASEFEE, BLOCKHASH, NUMBER, SELFBALANCE, BALANCE, ORIGIN, GAS, CREATE, COINBASE. They should only be forbidden during verification, not execution. These opcodes are forbidden because their outputs may differ between simulation and execution, so simulation of calls using these opcodes does not reliably tell what would happen if these calls are later done on-chain.
Non-bundling clients and bundlers should use different settings for the above params:
https://eips.ethereum.org/EIPS/eip-4341
https://eips.ethereum.org/EIPS/eip-4345
https://eips.ethereum.org/EIPS/eip-4353
Staked claims will be unreliable without a locking mechanism enforced, for example, if staked tokens can only be transferred at burn. Otherwise, tokens may be deposited and/or withdrawn at any time via arbitrary methods. Also, contracts that may allow arbitrary transfers without updating the correct balance will result in potential issues. A strict rules-based approach should be taken with these edge cases in mind.
https://eips.ethereum.org/EIPS/eip-4361
Write a specification for how Sign-In with Ethereum should work. The specification should be simple and generally follow existing practices. Avoid feature bloat, particularly the inclusion of lesser-used projects who see getting into the specification as a means of gaining adoption. The core specification should be decentralized, open, non-proprietary, and have long-term viability. It should have no dependence on a centralized server except for the servers already being run by the application that the user is signing in to. The basic specification should include: Ethereum accounts used for authentication, ENS names for usernames (via reverse resolution), and data from the ENS name’s text records for additional profile information (e.g. avatar, social media handles, etc).
Write a specification for how Sign-In with Ethereum should work. The specification should be simple and generally follow existing practices. Avoid feature bloat, particularly the inclusion of lesser-used projects who see getting into the specification as a means of gaining adoption. The core specification should be decentralized, open, non-proprietary, and have long-term viability. It should have no dependence on a centralized server except for the servers already being run by the application that the user is signing in to. The basic specification should include: Ethereum accounts used for authentication, ENS names for usernames (via reverse resolution), and data from the ENS name’s text records for additional profile information (e.g. avatar, social media handles, etc).
Write a specification for how Sign-In with Ethereum should work. The specification should be simple and generally follow existing practices. Avoid feature bloat, particularly the inclusion of lesser-used projects who see getting into the specification as a means of gaining adoption. The core specification should be decentralized, open, non-proprietary, and have long-term viability. It should have no dependence on a centralized server except for the servers already being run by the application that the user is signing in to. The basic specification should include: Ethereum accounts used for authentication, ENS names for usernames (via reverse resolution), and data from the ENS name’s text records for additional profile information (e.g. avatar, social media handles, etc).
Write a specification for how Sign-In with Ethereum should work. The specification should be simple and generally follow existing practices. Avoid feature bloat, particularly the inclusion of lesser-used projects who see getting into the specification as a means of gaining adoption. The core specification should be decentralized, open, non-proprietary, and have long-term viability. It should have no dependence on a centralized server except for the servers already being run by the application that the user is signing in to. The basic specification should include: Ethereum accounts used for authentication, ENS names for usernames (via reverse resolution), and data from the ENS name’s text records for additional profile information (e.g. avatar, social media handles, etc).
Write a specification for how Sign-In with Ethereum should work. The specification should be simple and generally follow existing practices. Avoid feature bloat, particularly the inclusion of lesser-used projects who see getting into the specification as a means of gaining adoption. The core specification should be decentralized, open, non-proprietary, and have long-term viability. It should have no dependence on a centralized server except for the servers already being run by the application that the user is signing in to. The basic specification should include: Ethereum accounts used for authentication, ENS names for usernames (via reverse resolution), and data from the ENS name’s text records for additional profile information (e.g. avatar, social media handles, etc).
https://eips.ethereum.org/EIPS/eip-4393
Before any users can tip an NFT, the holder of the NFT has to give their approval for tipping from the tip token contract. This standard stipulates that holders of the NFTs receive the rewards. It SHOULD be clear in the tip token contract code that it does so, without obfuscation to where the rewards go. Any fee charges SHOULD be made obvious to users before acceptance of their deposit. There is a risk that rogue implementers may attempt to *hijack* potential tip income streams for their own purposes. But additionally the number and frequency of transactions of the tipping process should make this type of fraud quicker to be found out.
https://eips.ethereum.org/EIPS/eip-4396
The current base fee calculation chooses the gas usage of a block as the signal to determine whether demand for block space is too low (indicating that the base fee should be lowered) or too high (indicating that the base fee should be increased). While simple, this choice of signal has drawbacks: it does not take the block time into account. Assuming a relatively constant demand, a proposer constructing a block after 20 seconds will have transactions available with twice the gas of a proposer constructing a block after 10 seconds. Using the same gas target for both is accordingly sub-optimal. In practice, there are several undesirable consequences of this flawed signal:
The current base fee calculation chooses the gas usage of a block as the signal to determine whether demand for block space is too low (indicating that the base fee should be lowered) or too high (indicating that the base fee should be increased). While simple, this choice of signal has drawbacks: it does not take the block time into account. Assuming a relatively constant demand, a proposer constructing a block after 20 seconds will have transactions available with twice the gas of a proposer constructing a block after 10 seconds. Using the same gas target for both is accordingly sub-optimal. In practice, there are several undesirable consequences of this flawed signal:
As discussed in the rationale, a high value for MAX_GAS_TARGET_PERCENT during times of many offline block proposers results in a small remaining signal space for genuine demand increases that should result in base fee increases. This in turn decreases the cost for block proposers for suppresing these base fee increases, instead forcing the fallback to a first-price priority fee auction.
https://eips.ethereum.org/EIPS/eip-4399
Applications may benefit from using the randomness accumulated by the beacon chain. Thus, randomness outputs produced by the beacon chain should be accessible in the EVM.
The renaming should be done to make the field and the opcode names semantically sound.
https://eips.ethereum.org/EIPS/eip-4400
Implementors of the EIP721Consumable standard must consider thoroughly the permissions they give to consumers. Even if they implement the standard correctly and do not allow transfer/burning of NFTs, they might still provide permissions to the consumers that they might not want to provide otherwise and should be restricted to owners only.
https://eips.ethereum.org/EIPS/eip-4430
The human-readable description can be shown in any client which supports
user interaction for approval, while the execcode is the data that
should be included in a transaction to the contract to perform that operation.
When executing the bytecode, best efforts should be made to ensure BLOCKHASH,
NUMBER, TIMESTAMP and DIFFICULTY match the "latest" block. The
COINBASE should be the zero address.
When executing the bytecode, best efforts should be made to ensure BLOCKHASH,
NUMBER, TIMESTAMP and DIFFICULTY match the "latest" block. The
COINBASE should be the zero address.
https://eips.ethereum.org/EIPS/eip-4444
Clients should allow importing and exporting of historical data. Clients can provide scripts that fetch/verify data and automatically import them.
After this proposal is implemented, certain JSON-RPC endpoints (e.g. like getBlockByHash) won’t be able to tell whether a given hash is invalid or just too old. Other endpoints like getLogs will simply no longer have the data the user is requesting. The way this regression should be handled by applications or clients is out-of-scope for this proposal.
It’s important that Ethereum historical data are preserved and seeded by independent organizations, and their availability should be checked frequently. We consider these mechanisms as out-of-scope for this proposal.
https://eips.ethereum.org/EIPS/eip-4488
https://eips.ethereum.org/EIPS/eip-4494
In general, test suites should assert at least the following about any implementation of this EIP:
Extra care should be taken when creating transfer functions in which permit and a transfer function can be used in one function to make sure that invalid permits cannot be used in any way. This is especially relevant for automated NFT platforms, in which a careless implementation can result in the compromise of a number of user assets.
https://eips.ethereum.org/EIPS/eip-4519
The SmartNFT attributes addressAsset and addressUser are, respectively, the Ethereum addresses of the physical asset and the user. They are optional attributes but at least one of them should be used in a SmartNFT. In the case of using only the attribute addressUser, two states define if the token is assigned or not to a user. Figure 1 shows these states in a flow chart. When a token is created, transferred or unassigned, the token state is set to notAssigned. If the token is assigned to a valid user, the state is set to userAssigned.
Since the establishment of a shared secret key is very important for a secure communication, SmartNFTs include the attributes
hashK_OA, hashK_UA and dataEngagement. The first two attributes define, respectively, the hash of the secret key shared between the asset and its owner and between the asset and its user. Assets, owners and users should check they are using the correct shared secret keys. The attribute dataEngagement defines the public data needed for the agreement.
In this EIP, a generic system has been proposed for the creation of non-fungible tokens tied to physical assets. A generic point of view based on the improvements of the current ERC-721 NFT is provided, such as the implementation of the user management mechanism, which does not affect the token’s ownership. The physical asset should have the ability to generate an Ethereum address from itself in a totally random way so that only the asset is able to know the secret from which the Ethereum address is generated. In this way, identity theft is avoided and the asset can be proven to be completely genuine. In order to ensure this, it is recommended that only the manufacturer of the asset has the ability to create its associated token. In the case of an IoT device, the device firmware will be unable to share and modify the secret. Instead of storing the secrets, it is recommended that assets reconstruct their secrets from non-sensitive information such as the helper data associated with Physical Unclonable Functions (PUFs). Although a secure key exchange protocol based on elliptic curves has been proposed, the token is open to coexist with other types of key exchange.
https://eips.ethereum.org/EIPS/eip-4520
https://eips.ethereum.org/EIPS/eip-4521
This standard proposes a simple extension to allow NFTs to work with contracts designed to manage ERC-20s and many consumer wallets which expect to be able to execute a token transfer(). For example, if an NFT is inadvertently sent to a contract that typically handles ERC-20, that NFT will be locked. It should also simplify the task for contract programmers if they can rely on transfer() to both handle ERC-20 and NFTs.
https://eips.ethereum.org/EIPS/eip-4524
onERC20Received is a callback function. Callback functions have been exploited in the past as a reentrancy vector, and care should be taken to make sure implementations are not vulnerable.
https://eips.ethereum.org/EIPS/eip-4527
Due to these advantages, QR Code data transmissions is a better choice. Unfortunately, there is no modern standard for how offline signers should work with watch-only wallets nor how data should be encoded.
This EIP presents a standard process and data transmission protocol for offline signers to work with watch-only wallets.
Due to these advantages, QR Code data transmissions is a better choice. Unfortunately, there is no modern standard for how offline signers should work with watch-only wallets nor how data should be encoded.
This EIP presents a standard process and data transmission protocol for offline signers to work with watch-only wallets.
In order to work with offline signers, the watch-only wallet should follow the following process.
Since a single QR Code can only contain a limited amount of data, animated QR Codes should be utilized for data transmission. The BlockchainCommons have published a series of data transmission protocol called Uniform Resources (UR). It provides a basic method to encode data into animated QR Codes. This EIP will use UR and extend its current definition. For more info about UR, please check it out here.
In such a case, offline signers should provide the extended public keys and derivation path. The UR Type called crypto-hdkey will be used to encode this data and the derivation path will be encoded as crypto-keypath.
After the data is signed, the offline signer should send the signature back to the watch-only wallet. The new UR type called eth-signature is introduced here to encode this data.
The offline signer should decode all the data from eth-sign-request and show them to the user for confirmation prior to signing. It is recommended to provide an address field in the eth-sign-request. If provided, the offline signer should verify the address being the same one as the address associated with the signing key.
The offline signer should decode all the data from eth-sign-request and show them to the user for confirmation prior to signing. It is recommended to provide an address field in the eth-sign-request. If provided, the offline signer should verify the address being the same one as the address associated with the signing key.
https://eips.ethereum.org/EIPS/eip-4546
Upgraded contracts can allow deposits using both the old system (approving the contract itself) and the proposed deposit system to preserve existing approvals. New users should be prompted to use the proposed deposit system.
The wrapped deposit implementation should be as small as possible to reduce the risk of bugs. The contract should be small enough that an engineer can read and understand it in a few minutes.
The wrapped deposit implementation should be as small as possible to reduce the risk of bugs. The contract should be small enough that an engineer can read and understand it in a few minutes.
https://eips.ethereum.org/EIPS/eip-4573
This proposal adds new EVM opcodes. It doesn’t remove or change the semantics of any existing opcodes, so there should be no backwards compatibility issues.
Safe use of these constructs must be checked completely at validation time – per EIP-3779 – so there should be no security issues at runtime.
https://eips.ethereum.org/EIPS/eip-4626
This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and from.
This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and from.
This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and from.
This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and from.
MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.
MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called in the same transaction.
MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the deposit would be accepted, regardless if the user has enough tokens approved, etc.
MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.
MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the same transaction.
MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint would be accepted, regardless if the user has enough tokens approved, etc.
MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
MUST return the maximum amount of assets that could be transferred from owner through withdraw and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if called in the same transaction.
MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though the withdrawal would be accepted, regardless if the user has enough shares, etc.
MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
SHOULD check msg.sender can spend owner funds, assets needs to be converted to shares and shares should be checked for allowance.
Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed. Those methods should be performed separately.
MUST return the maximum amount of shares that could be transferred from owner through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the same transaction.
MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the redemption would be accepted, regardless if the user has enough shares, etc.
MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed. Those methods should be performed separately.
If implementors intend to support EOA account access directly, they should consider adding an additional function call for deposit/mint/withdraw/redeem with the means to accommodate slippage loss or unexpected deposit/withdrawal limits, since they have no other means to revert the transaction if the exact output amount is not achieved.
Integrators of EIP-4626 Vaults should be aware of the difference between these view methods when integrating with this standard. Additionally, note that the amount of underlying assets a user may receive from redeeming their Vault shares (previewRedeem) can be significantly different than the amount that would be taken from them when minting the same quantity of shares (previewMint). The differences may be small (like if due to rounding error), or very significant (like if a Vault implements withdrawal or deposit fees, etc). Therefore integrators should always take care to use the preview function most relevant to their use case, and never assume they are interchangeable.
Integrators of EIP-4626 Vaults should be aware of the difference between these view methods when integrating with this standard. Additionally, note that the amount of underlying assets a user may receive from redeeming their Vault shares (previewRedeem) can be significantly different than the amount that would be taken from them when minting the same quantity of shares (previewMint). The differences may be small (like if due to rounding error), or very significant (like if a Vault implements withdrawal or deposit fees, etc). Therefore integrators should always take care to use the preview function most relevant to their use case, and never assume they are interchangeable.
Finally, EIP-4626 Vault implementers should be aware of the need for specific, opposing rounding directions across the different mutable and view methods, as it is considered most secure to favor the Vault itself during calculations over its users:
Although the convertTo functions should eliminate the need for any use of an EIP-4626 Vault’s decimals variable, it is still strongly recommended to mirror
the underlying token’s decimals if at all possible, to eliminate possible sources of confusion and simplify integration across front-ends and for other off-chain users.
https://eips.ethereum.org/EIPS/eip-4671
https://eips.ethereum.org/EIPS/eip-4675
To receive Non-Fungible Token on safe Transfer the contract should include onERC721Received().
Including onERC721Received() is needed to be compatible with Safe Transfer Rules.
To fractionalize an already minted NFT, it is evident that ownership of NFT should be given to token contracts before fractionalization.
In the case of fractionalizing NFT, the token contract should thoroughly verify the ownership of NFT before fractionalizing it to prevent tokens from being a separate tokens with the NFT.
To fractionalize an already minted NFT, it is evident that ownership of NFT should be given to token contracts before fractionalization.
In the case of fractionalizing NFT, the token contract should thoroughly verify the ownership of NFT before fractionalizing it to prevent tokens from being a separate tokens with the NFT.
If an arbitrary account has the right to call setParentNFT() there might be a front-running issue. The caller of setParentNFT() might be different from the real NFT sender.
To prevent this issue, implementors should just allow admin to call, or fractionalize and receive NFT in an atomic transaction similar to flash loan(swap).
https://eips.ethereum.org/EIPS/eip-4736
https://eips.ethereum.org/EIPS/eip-4747
https://eips.ethereum.org/EIPS/eip-4750
https://eips.ethereum.org/EIPS/eip-4758
https://eips.ethereum.org/EIPS/eip-4760
Few applications are affected by this change. The only use that breaks is where a contract is re-created at the same address using CREATE2 (after a SELFDESTRUCT). The only application that is significantly affected (and where code can be analyzed) is able to switch to a different model, and should have ample time to do so.
https://eips.ethereum.org/EIPS/eip-4762
We define write events as follows. Note that when a write takes place, an access event also takes place (so the definition below should be a subset of the definition of access lists) A write event is of the form (address, sub_key, leaf_key), determining what data is being written to.
https://eips.ethereum.org/EIPS/eip-4788
The method of injecting the beacon state root in this EIP follows the general strategy of EIP-4399 to make a post-merge change to the EVM integrating information from the beacon chain. This EIP along with EIP-3675 should be taken as relevant background to understand the particular approach of this EIP.
This EIP requires the consensus layer and execution layer to execute a network upgrade in lockstep.
To carry out this task, a FORK_EPOCH (of the beacon chain) will be chosen and then used to compute a timestamp FORK_TIMESTAMP.
This FORK_TIMESTAMP can be used in the execution layer to identify when the protocol change should be deployed.
https://eips.ethereum.org/EIPS/eip-4799
https://eips.ethereum.org/EIPS/eip-4803
While this is a breaking change, no actual effect should be visible.
https://eips.ethereum.org/EIPS/eip-4804
https://eips.ethereum.org/EIPS/eip-4834
Unlike ENS, any program that resolves domains should treat domains as equivalent to their resolved addresses. In practice, this means users of DApps that implement this EIP’s name resolution may specify an address that looks like dai.token instead of 0x6b175474e89094c44da98b954eedeac495271d0f. In this instance, dai.token and 0x6b175474e89094c44da98b954eedeac495271d0f are not different, unlike ENS, where names are simply keys to be hashed and inputted into a storage contract that then resolves the name to an address.
Clients should help by warning if canMoveSubdomain or canDeleteSubdomain for the new subdomain changes to false. It is important to note, however, that since these are functions, it is possible for the value to change depending on whether or not it has already been linked. It is also still possible for it to unexpectedly return true. It is therefore recommended to always audit the new subdomain’s source code before calling setDomain.
https://eips.ethereum.org/EIPS/eip-4844
The sustained load of this EIP is much lower than alternatives that reduce calldata costs, even if the calldata is limited,
because there is no existing software that stores the blobs indefinitely and there is no expectation that they need to be stored for as long as an execution payload.
This makes it easier to implement a policy that these blobs should be deleted after e.g. 30-60 days,
a much shorter delay compared to proposed (but yet to be implemented) one-year rotation times for execution payload history.
https://eips.ethereum.org/EIPS/eip-4863
When processing a transaction with WITHDRAWAL_TX_TYPE type, the implementation should increase the balance of the address specified by
the WithdrawalTransaction by the amount of wei specified.
https://eips.ethereum.org/EIPS/eip-4881
https://eips.ethereum.org/EIPS/eip-4883
https://eips.ethereum.org/EIPS/eip-4885
Use of subscription tokens is in effect an indirect way to control the lifetime of an NFT. As such it is assumed that this arrangement would work best when the NFTs and subscription token contracts subscribing to the NFTs, are deployed by the same platform or decentralised app. It MUST NOT have an impact or dependencies to existing NFTs that have not approved the subscription token as an operator. Indeed in this case, any other parties wouldn’t be aware of and any NFT lifetime dependencies will be ignored, hence should not work anyway. To this end, this proposal specifies that the ‘nft’ MUST have approved the subscriptionToken contract address as operator.
https://eips.ethereum.org/EIPS/eip-4886
Ethereum is amazing at providing trustless proofs. The only time a user should need to interact using the wallet that holds an asset is if they intend to sell or transfer that asset. If a user merely wishes to prove ownership (to access a resource, get an airdrop, mint an NFT, or vote in a DAO), they should do this through a trustless proof stored on-chain.
Ethereum is amazing at providing trustless proofs. The only time a user should need to interact using the wallet that holds an asset is if they intend to sell or transfer that asset. If a user merely wishes to prove ownership (to access a resource, get an airdrop, mint an NFT, or vote in a DAO), they should do this through a trustless proof stored on-chain.
Furthermore, users should be able to decide where new assets are delivered, rather than them being delivered to the wallet providing the interaction. This allows hot wallets to acquire assets sent directly to a cold wallet ‘vault’, possibly even the one they are representing in terms of asset ownership.
https://eips.ethereum.org/EIPS/eip-4895
For each withdrawal in the list of block.withdrawals, the implementation should increase the balance of the address specified by the amount given.
https://eips.ethereum.org/EIPS/eip-4906
https://eips.ethereum.org/EIPS/eip-4907
Some NFTs have certain utilities. For example, virtual land can be “used” to build scenes, and NFTs representing game assets can be “used” in-game. In some cases, the owner and user may not always be the same. There may be an owner of the NFT that rents it out to a “user”. The actions that a “user” should be able to take with an NFT would be different from the “owner” (for instance, “users” usually shouldn’t be able to sell ownership of the NFT).  In these situations, it makes sense to have separate roles that identify whether an address represents an “owner” or a “user” and manage permissions to perform actions accordingly.
Some NFTs have certain utilities. For example, virtual land can be “used” to build scenes, and NFTs representing game assets can be “used” in-game. In some cases, the owner and user may not always be the same. There may be an owner of the NFT that rents it out to a “user”. The actions that a “user” should be able to take with an NFT would be different from the “owner” (for instance, “users” usually shouldn’t be able to sell ownership of the NFT).  In these situations, it makes sense to have separate roles that identify whether an address represents an “owner” or a “user” and manage permissions to perform actions accordingly.
https://eips.ethereum.org/EIPS/eip-4931
https://eips.ethereum.org/EIPS/eip-4938
At this time, some client implementations cannot serve GetNodeData requests because they do not store the state in a compatible way. The Ethereum Wire Protocol should accurately reflect the capabilities of clients, and should not contain messages which are impossible to implement in some clients.
At this time, some client implementations cannot serve GetNodeData requests because they do not store the state in a compatible way. The Ethereum Wire Protocol should accurately reflect the capabilities of clients, and should not contain messages which are impossible to implement in some clients.
https://eips.ethereum.org/EIPS/eip-4944
The constructor should mint the unique token of the contract, and then the mint function should add a restriction to avoid further minting.
The constructor should mint the unique token of the contract, and then the mint function should add a restriction to avoid further minting.
Also, a tokenTransfer function should be added in order to allow the contract owner to transact with the ERC20 tokens owned by the contract/NFT itself. So that if the contract receives a transfer of ERC20 tokens, the owner of the NFT could spend it from the contract wallet.
https://eips.ethereum.org/EIPS/eip-4950
https://eips.ethereum.org/EIPS/eip-4955
https://eips.ethereum.org/EIPS/eip-4972
The name should be human-readable and can be easily recognized socially. An example is the username of a centralized platform such as FB, Twitter. The name-derived address (NDA) is a normal Ethereum address that should not collide with the existing addresses of EOA/CA. Since we cannot use NDA as msg.sender, the right to transfer the tokens of the NDA is controlled by the owner/owners of the name. The name to owner/owners mapping is managed by an on-chain name service, and the owner/owners are EOA/CA, which can be the addresses of 3-rd custodians (e.g. FB) or self-custodian. By changing the owner of the name to the EOA of the user (can be done by requesting the custodian), the NDA becomes self-custodian, and no one should be able to transfer the assets unless the approved by the self-custodian user.
The name should be human-readable and can be easily recognized socially. An example is the username of a centralized platform such as FB, Twitter. The name-derived address (NDA) is a normal Ethereum address that should not collide with the existing addresses of EOA/CA. Since we cannot use NDA as msg.sender, the right to transfer the tokens of the NDA is controlled by the owner/owners of the name. The name to owner/owners mapping is managed by an on-chain name service, and the owner/owners are EOA/CA, which can be the addresses of 3-rd custodians (e.g. FB) or self-custodian. By changing the owner of the name to the EOA of the user (can be done by requesting the custodian), the NDA becomes self-custodian, and no one should be able to transfer the assets unless the approved by the self-custodian user.
The name should be human-readable and can be easily recognized socially. An example is the username of a centralized platform such as FB, Twitter. The name-derived address (NDA) is a normal Ethereum address that should not collide with the existing addresses of EOA/CA. Since we cannot use NDA as msg.sender, the right to transfer the tokens of the NDA is controlled by the owner/owners of the name. The name to owner/owners mapping is managed by an on-chain name service, and the owner/owners are EOA/CA, which can be the addresses of 3-rd custodians (e.g. FB) or self-custodian. By changing the owner of the name to the EOA of the user (can be done by requesting the custodian), the NDA becomes self-custodian, and no one should be able to transfer the assets unless the approved by the self-custodian user.
https://eips.ethereum.org/EIPS/eip-4973
If an implementer of EIP-721 properly built EIP-165’s function supportsInterface(bytes4 interfaceID) function, already by recognizing that EIP-721’s track and transfer interface component with the identifier 0x80ac58cd is not implemented, transferring of a token should not be suggested as a user interface option.
Still, since ABTs support EIP-721’s ERC721Metadata extension, wallets and marketplaces should display an account-bound token with no changes needed.
Given the non-transferable between accounts property of ABTs, if a user’s keys to an account or a contract get compromised or rotated, a user may lose the ability to associate themselves with the token. In some cases, this can be the desired effect. Therefore, ABT implementers should build re-issuance and revocation processes to enable recourse. We recommend implementing strictly decentralized, permissionless, and censorship-resistant re-issuance processes.
ABTs can be indexed by tracking the emission of event Transfer(address indexed from, address indexed to, uint256 indexed tokenId). As with EIP-721, transfers between two accounts are represented by address from and address to being non-zero addresses. Unequipping a token is represented through emitting a transfer with address to being set to the zero address. Mint operations where address from is set to zero don’t exist. To avoid being spoofed by maliciously-implemented event Transfer emitting contracts, an indexer should ensure that the transaction’s sender is equal to event Transfer’s from value.
https://eips.ethereum.org/EIPS/eip-4974
EXP, shorthand for “experience points”, may represent accumulated recognition within a smart contract. Like experience points in video games, citations on an academic paper, or Reddit Karma, EXP is bestowed for useful contributions, accumulates as indistinguishable units, and should only be reallocated or destroyed by a reliable authority so empowered.
EXP SHOULD allow burning tokens by contract operators. If Bob has contributed greatly to the community, but then is caught stealing from Alice, the community may decide this should lower Bob’s standing and influence in the community. Again, while this does not ensure an ethical standard within the community, it opens the door.
https://eips.ethereum.org/EIPS/eip-4987
Consumers of this standard should be cautious when using ownership information from unknown contracts. A bad actor could implement the interface, but report invalid or malicious information with the goal of manipulating a governance system, game, membership program, etc.
Consumers should also verify the overall token balance and ownership of the holder contract as a sanity check.
https://eips.ethereum.org/EIPS/eip-5000
https://eips.ethereum.org/EIPS/eip-5003
Contracts using ECDSA signatures outside of transactions will not be aware that the usurped account is no longer controlled by a private key. This means that, for example, the private key will always have access to the permit function on token contracts. This can—and should—be mitigated by modifying the ecrecover pre-compiled contract.
https://eips.ethereum.org/EIPS/eip-5005
There are some considerations that module developers and users should take into account.
https://eips.ethereum.org/EIPS/eip-5006
https://eips.ethereum.org/EIPS/eip-5007
https://eips.ethereum.org/EIPS/eip-5008
https://eips.ethereum.org/EIPS/eip-5018
Removes a chunk of the file name and returns false if such chunk does not exist. The method should be called by an account with write permission.
read method should return the concatenated chunked data written by writeChunk method. The following gives some examples of the interactions:
https://eips.ethereum.org/EIPS/eip-5022
Whereas solutions like state rent, or state expiry have been researched for a long time, they will not be ready on the short to medium term. So, it is desirable to patch pricing for the short term. Opcode repricing has been done before, so it should not impose a large development time investment for clients.
The current pricing was made off a naive approach of benchmarking opcodes in a laptop. Not only it did not consider the long term problem of having the same price for a resource that costs more over time, the benchmark itself was wrong. This price is closer to what the naive original benchmark should have been. It could go higher, but that may be too disruptive.
It is a gas schedule change, so transactions from an epoch before FORK_BLOCK should be treated with previous gas costs.
https://eips.ethereum.org/EIPS/eip-5027
https://eips.ethereum.org/EIPS/eip-5050
https://eips.ethereum.org/EIPS/eip-5058
https://eips.ethereum.org/EIPS/eip-5065
Add a new instruction that transfers ether to a destination address without handing over the flow of execution to it. It should work similarly to how SELFDESTRUCT (0xFF) transfers ether to the destination without making a call to it.
From an architectural point of view, execution flow should never be handed over to an untrusted contract. Ethereum currently does not have any ideal way to transfer ether without transferring the flow of execution. People have come up with reentrancy guards and similar solutions to prevent some types of attacks but it’s not an ideal solution. The only way to transfer ether from smart contracts without triggering a call is to create a dummy contract, send the precise amount of ether to it and then call SELFDESTRUCT (0xFF) from it.
The total gas cost should be the sum of a static cost + address_access_cost + value_to_empty_account_cost.
https://eips.ethereum.org/EIPS/eip-5069
https://eips.ethereum.org/EIPS/eip-5081
https://eips.ethereum.org/EIPS/eip-5094
https://eips.ethereum.org/EIPS/eip-5095
This calculation MAY NOT reflect the “per-user” price-per-principal-token, and instead should reflect the “average-user’s” price-per-principal-token, meaning what the average user should expect to see when exchanging to and from.
This calculation MAY NOT reflect the “per-user” price-per-principal-token, and instead should reflect the “average-user’s” price-per-principal-token, meaning what the average user should expect to see when exchanging to and from.
This calculation MAY NOT reflect the “per-user” price-per-principal-token, and instead should reflect the “average-user’s” price-per-principal-token, meaning what the average user should expect to see when redeeming.
This calculation MAY NOT reflect the “per-user” price-per-principal-token, and instead should reflect the “average-user’s” price-per-principal-token, meaning what the average user should expect to see when redeeming.
MUST return the maximum amount of principal tokens that could be transferred from holder through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST return as close to and no more than the exact amount of underliyng that would be obtained in a redeem call in the same transaction. I.e. redeem should return the same or more underlyingAmount as previewRedeem if called in the same transaction.
MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the redemption would be accepted, regardless if the user has enough principal tokens, etc.
MUST be inclusive of redemption fees. Integrators should be aware of the existence of redemption fees.
Note that some implementations will require pre-requesting to the Principal Token before a withdrawal may be performed. Those methods should be performed separately.
MUST return the maximum amount of underlying tokens that could be redeemed from holder through withdraw and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST return as close to and no fewer than the exact amount of principal tokens that would be burned in a withdraw call in the same transaction. I.e. withdraw should return the same or fewer principalAmount as previewWithdraw if called in the same transaction.
MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though the withdrawal would be accepted, regardless if the user has enough principal tokens, etc.
MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
Note that some implementations will require pre-requesting to the principal token contract before a withdrawal may be performed. Those methods should be performed separately.
https://eips.ethereum.org/EIPS/eip-5114
The format of the data pointed to by collectionUri() and tokenUri(uint256) is intentionally left out of this standard in favor of separate standards that can be iterated on in the future.
The immutability constraints are the only thing defined by this to ensure that the spirit of this token is maintained, regardless of the specifics of the data format.
The metadataFormat function can be used to inform a caller what type/format/version of data they should expect at the URIs, so the caller can parse the data directly without first having to deduce its format via inspection.
It should also be made clear that soulbound tokens are not bound to a human, they are bound to a persona.
A persona is any actor (which could be a group of humans) that collects multiple soulbound tokens over time to build up a collection of badges.
This persona may transfer to another human, or to another group of humans, and anyone interacting with a persona should not assume that there is a single permanent human behind that persona.
It should also be made clear that soulbound tokens are not bound to a human, they are bound to a persona.
A persona is any actor (which could be a group of humans) that collects multiple soulbound tokens over time to build up a collection of badges.
This persona may transfer to another human, or to another group of humans, and anyone interacting with a persona should not assume that there is a single permanent human behind that persona.
It is possible for a soulbound token to be bound to another soulbound token.
In theory, if all tokens in the chain are created at the same time they could form a loop.
Software that tries to walk such a chain should take care to have an exit strategy if a loop is detected.
https://eips.ethereum.org/EIPS/eip-5115
The method exchangeRateStored returns an outdated estimated value and does not confer the exact current exchange rate of asset per share. Should accuracy be needed, exchangeRateCurrent should be used instead (which additionally updates exchangeRateStored.)
https://eips.ethereum.org/EIPS/eip-5131
Instead, one should be able to approve multiple wallets to authenticate on behalf of a given wallet.
https://eips.ethereum.org/EIPS/eip-5133
https://eips.ethereum.org/EIPS/eip-5139
https://eips.ethereum.org/EIPS/eip-5143
Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed. Those methods should be performed separately.
Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed. Those methods should be performed separately.
https://eips.ethereum.org/EIPS/eip-5169
https://eips.ethereum.org/EIPS/eip-5173
NFTs, in contrast to physical art and collectibles in the physical world, are not currently reflecting the contributions of their owners to their value. Since each EIP-721 token can be tracked individually, and may be modified to record every change in the price of any specific NFT token, there is no reason that a Future Rewards program of this type should not be established.
In a single generation reward, the new buyer/owner receives a share of the next single generation’s realized profit only. In a multigenerational reward system, buyers will have future rewards years after their purchase. The NFT should have a long-term growth potential and a substantial dividend payout would be possible in this case.
We agree that artists’ royalties should be uniform and on-chain. We support EIP-2981 NFT royalty Standard proposal.
Many of these companies engage in wash trading on their own or collude with certain users, and royalties and FR payments are reimbursed under the table. It is crucial that all exchanges have robust features to prevent self-trading. Users should be able to observe watchers transparently. Marketplaces should provide their customers with free access to an on-chain transaction monitoring service like Chainalysis Reactor.
Many of these companies engage in wash trading on their own or collude with certain users, and royalties and FR payments are reimbursed under the table. It is crucial that all exchanges have robust features to prevent self-trading. Users should be able to observe watchers transparently. Marketplaces should provide their customers with free access to an on-chain transaction monitoring service like Chainalysis Reactor.
https://eips.ethereum.org/EIPS/eip-5185
Most use cases have chosen intermediate solutions like IPFS or arweave to provide some permanence or partial/full immutability of metadata. This is a good solution when an NFT represents a static asset whose characteristics are by nature permanent and immutable (like in the art world) but less so with other use cases like gaming or NFT representing a deed or title. Distinguishable assets in a game often should be allowed to evolve and change over time in a controlled way and titles need to record real life changes.
The number of updates defined by each event is to be determined by the smart contract logic and use case, but it can easily scale to thousands or millions of updates per event. The function(s) that should emit MetadataUpdates and the frequency of these on-chain updates is left at the discretion of this standard implementation.
Smart contracts should be careful and conscious of using this extension and still allow the metadata URI to be updated in some contexts (by not having the same URI returned by tokenURI or uri for a given tokenId over time). They need to take into account if previous changes could have been already broadcasted for that NFT by the contract, if these changes are compatible with the new “original metadata” and what semantic they decide to associate by combining these two kinds of “updates”.
https://eips.ethereum.org/EIPS/eip-5187
https://eips.ethereum.org/EIPS/eip-5189
This EIP proposes a form of account abstraction that ensures compatibility with existing smart contract wallets and provides flexibility for alternative designs while avoiding introducing changes to the consensus layer. Instead of defining a strict structure for meta-transactions, this proposal introduces the figure of endorser contracts. These smart contract instances are tasked with determining the quality of the submitted meta-transactions, thus safely helping bundlers determine if a meta-transaction should be kept in the mempool or not. Developers that intend to make their smart contract wallet compatible with this EIP must create and deploy an instance of an endorser; this instance must be seeded with a small amount of ETH to be burnt that incentivizes its good behavior.
It should also be registered in the EndorserRegistry with a minimum amount of burned ETH (Mempool operators are free to accept operations from endorsers without any burn, but they would increase their risk exposing themselves to denial of service attacks).
| Field | Type | Description |
| ——– | ——– | ——– |
| addr | address | Contract address of the dependencies entry (only one entry per address should be allowed). |
| balance | bool | true if the balance of addr should be considered a dependency of the operation. |
| code | bool | true if the code of addr should be considered a dependency of the operation. |
| nonce | bool | true if the nonce of addr should be considered a dependency of the operation. |
| slots | bytes32[] | List of all storage slots of addr that should be considered dependencies of operation. |
| Field | Type | Description |
| ——– | ——– | ——– |
| addr | address | Contract address of the dependencies entry (only one entry per address should be allowed). |
| balance | bool | true if the balance of addr should be considered a dependency of the operation. |
| code | bool | true if the code of addr should be considered a dependency of the operation. |
| nonce | bool | true if the nonce of addr should be considered a dependency of the operation. |
| slots | bytes32[] | List of all storage slots of addr that should be considered dependencies of operation. |
| Field | Type | Description |
| ——– | ——– | ——– |
| addr | address | Contract address of the dependencies entry (only one entry per address should be allowed). |
| balance | bool | true if the balance of addr should be considered a dependency of the operation. |
| code | bool | true if the code of addr should be considered a dependency of the operation. |
| nonce | bool | true if the nonce of addr should be considered a dependency of the operation. |
| slots | bytes32[] | List of all storage slots of addr that should be considered dependencies of operation. |
| Field | Type | Description |
| ——– | ——– | ——– |
| addr | address | Contract address of the dependencies entry (only one entry per address should be allowed). |
| balance | bool | true if the balance of addr should be considered a dependency of the operation. |
| code | bool | true if the code of addr should be considered a dependency of the operation. |
| nonce | bool | true if the nonce of addr should be considered a dependency of the operation. |
| slots | bytes32[] | List of all storage slots of addr that should be considered dependencies of operation. |
| Field | Type | Description |
| ——– | ——– | ——– |
| addr | address | Contract address of the dependencies entry (only one entry per address should be allowed). |
| balance | bool | true if the balance of addr should be considered a dependency of the operation. |
| code | bool | true if the code of addr should be considered a dependency of the operation. |
| nonce | bool | true if the nonce of addr should be considered a dependency of the operation. |
| slots | bytes32[] | List of all storage slots of addr that should be considered dependencies of operation. |
If, when simulating the final inclusion of the operation, the bundler discovers that it does not result in correct payment (either because the transaction fails, or transferred amount is below the defined fee), then it should proceed to ban the endorser for one of the following reasons:
After an endorser is banned, the mempool operator should drop all operations related to such endorser.
If these rules are widely adopted, wallet developers should keep usage of dependencies to the lowest possible levels.
If the call succeeds and returns ready == true, then the operation can be kept in the mempool and used when constructing the next block. The client must keep track of all fields returned as dependencies. If any of these register a change, then readiness should be reevaluated.
https://eips.ethereum.org/EIPS/eip-5192
https://eips.ethereum.org/EIPS/eip-5202
https://eips.ethereum.org/EIPS/eip-5216
Implementors of the ERC1155ApprovalByAmount standard must consider thoroughly the amount of tokens they give permission to operators. They should also revoke the rest.
https://eips.ethereum.org/EIPS/eip-5218
The full log of license creation, transfer, and revocation must be traceable via event logs. Therefore, all license creations and transfers must emit a corresponding log event. Revocation may differ a bit. An implementation of this EIP may emit a Revoke event only when a license is revoked in a function call, or for every revoked license, both are sufficient to trace the status of all licenses. The former costs less gas if revoking a license automatically revokes all sublicenses under it, while the latter is efficient in terms of interrogation of a license status. Implementers should make the tradeoffs depending on their license terms.
The revoker of a license may be the licensor, the license holder, or a smart contract address which calls the revokeLicense function when some conditions are met. Implementers should be careful with the authorization, and may make the revoker smart contract forward compatible with transfers by not hardcoding the addresses of licensor or licenseHolder.
Note that this EIP doesn’t include a function to update license URI so the license terms should be persistent by default. It is recommended to store the license metadata on a decentralized storage service such as IPFS or adopt the IPFS-style URI which encodes the hash of the metadata for integrity verification. On the other hand, license updatability, if necessary in certain scenarios, can be realized by revoking the original license and creating a new license, or adding a updating function, the eligibile caller of which must be carefully specified in the license and securely implemented in the smart contract.
Implementors of the IERC5218 standard must consider thoroughly the permissions they give to licenseHolder and revoker. If the license is ever to be transferred to a different license holder, the revoker smart contract should not hardcode the licenseHolder address to avoid undesirable scenarios.
https://eips.ethereum.org/EIPS/eip-5219
The request method was chosen to be readonly because all data should be sent to the contract from the parsed DApp. Here are some reasons why:
https://eips.ethereum.org/EIPS/eip-5247
https://eips.ethereum.org/EIPS/eip-5267
This EIP complements EIP-712 by standardizing how contracts should publish the fields and values that describe their domain. This enables applications to retrieve this description and generate appropriate domain separators in a general way, and thus integrate EIP-712 signatures securely and scalably.
A notable application of EIP-712 signatures is found in EIP-2612 (permit), which specifies a DOMAIN_SEPARATOR function that returns a bytes32 value (the actual domain separator, i.e., the result of hashStruct(eip712Domain)). This value does not suffice for the purposes of integrating with EIP-712, as the RPC methods defined there receive an object describing the domain and not just the separator in hash form. Note that this is not a flaw of the RPC methods, it is indeed part of the security proposition that the domain should be validated and informed to the user as part of the signing process. On its own, a hash does not allow this to be implemented, given it is opaque. The present EIP fills this gap in both EIP-712 and EIP-2612.
Extensions are described by their EIP numbers because EIP-712 states: “Future extensions to this standard can add new fields […] new fields should be proposed through the EIP process.”
While this EIP allows a contract to specify a verifyingContract other than itself, as well as a chainId other than that of the current chain, user-agents and applications should in general validate that these do match the contract and chain before requesting any user signatures for the domain. This may not always be a valid assumption.
https://eips.ethereum.org/EIPS/eip-5269
https://eips.ethereum.org/EIPS/eip-5283
https://eips.ethereum.org/EIPS/eip-5289
https://eips.ethereum.org/EIPS/eip-5313
https://eips.ethereum.org/EIPS/eip-5334
Some NFTs have certain utilities. For example, virtual land can be “used” to build scenes, and NFTs representing game assets can be “used” in-game. In some cases, the owner and user may not always be the same. There may be an owner of the NFT that rents it out to a “user”. The actions that a “user” should be able to take with an NFT would be different from the “owner” (for instance, “users” usually shouldn’t be able to sell ownership of the NFT).  In these situations, it makes sense to have separate roles that identify whether an address represents an “owner” or a “user” and manage permissions to perform actions accordingly.
Some NFTs have certain utilities. For example, virtual land can be “used” to build scenes, and NFTs representing game assets can be “used” in-game. In some cases, the owner and user may not always be the same. There may be an owner of the NFT that rents it out to a “user”. The actions that a “user” should be able to take with an NFT would be different from the “owner” (for instance, “users” usually shouldn’t be able to sell ownership of the NFT).  In these situations, it makes sense to have separate roles that identify whether an address represents an “owner” or a “user” and manage permissions to perform actions accordingly.
https://eips.ethereum.org/EIPS/eip-5345
Sending RPC requests between application and wallet can be as usual. For example browser extension wallets can use these new methods easily. Even hardware wallets can implement this too. But for mobile wallets extra communication techniques should be considered. Because mobile wallets can be inactive when it is not in use.
https://eips.ethereum.org/EIPS/eip-5375
https://eips.ethereum.org/EIPS/eip-5409
ownerOf does not throw when a token does not exist (or does not have an owner). This simplifies the handling of such a case. Since it would be a security risk to assume all EIP-721 implementation would throw, it should not break compatibility with contract handling EIP-721 when dealing with this EIP-1155 extension.
https://eips.ethereum.org/EIPS/eip-5437
Implementors should properly follow security practices required by the encryption scheme to ensure the security of the chosen communication channel. Some best practices are as follows:
https://eips.ethereum.org/EIPS/eip-5450
https://eips.ethereum.org/EIPS/eip-5453
https://eips.ethereum.org/EIPS/eip-5484
https://eips.ethereum.org/EIPS/eip-5485
https://eips.ethereum.org/EIPS/eip-5489
https://eips.ethereum.org/EIPS/eip-5496

Process finished with exit code 0
