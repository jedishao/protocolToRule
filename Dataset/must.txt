https://eips.ethereum.org/EIPS/eip-1
References to other EIPs should follow the format EIP-N where N is the EIP number you are referring to. Each EIP that is referenced in an EIP MUST be accompanied by a relative markdown link the first time it is referenced, and MAY be accompanied by a link on subsequent references. The link MUST always be done via relative paths so that the links work in this GitHub repository, forks of this repository, the main EIPs site, mirrors of the main EIP site, etc. For example, you would link to this EIP with [EIP-1](/EIPS/eip-1).
References to other EIPs should follow the format EIP-N where N is the EIP number you are referring to. Each EIP that is referenced in an EIP MUST be accompanied by a relative markdown link the first time it is referenced, and MAY be accompanied by a link on subsequent references. The link MUST always be done via relative paths so that the links work in this GitHub repository, forks of this repository, the main EIPs site, mirrors of the main EIP site, etc. For example, you would link to this EIP with [EIP-1](/EIPS/eip-1).
https://eips.ethereum.org/EIPS/eip-20
OPTIONAL - This method can be used to improve usability,
but interfaces and other contracts MUST NOT expect these values to be present.
OPTIONAL - This method can be used to improve usability,
but interfaces and other contracts MUST NOT expect these values to be present.
OPTIONAL - This method can be used to improve usability,
but interfaces and other contracts MUST NOT expect these values to be present.
Transfers _value amount of tokens to address _to, and MUST fire the Transfer event.
The function SHOULD throw if the message caller’s account balance does not have enough tokens to spend.
Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.
Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.
Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.
MUST trigger when tokens are transferred, including zero value transfers.
MUST trigger on any successful call to approve(address _spender, uint256 _value).
https://eips.ethereum.org/EIPS/eip-137
Resolvers may implement any subset of the record types specified here. Where a record types specification requires a resolver to provide multiple functions, the resolver MUST implement either all or none of them. Resolvers MUST specify a fallback function that throws.
Resolvers may implement any subset of the record types specified here. Where a record types specification requires a resolver to provide multiple functions, the resolver MUST implement either all or none of them. Resolvers MUST specify a fallback function that throws.
If the resolver supports addr lookups but the requested node does not have an addr record, the resolver MUST return the zero address.
Clients resolving the addr record MUST check for a zero return value, and treat this in the same manner as a name that does not have a resolver specified - that is, refuse to send funds to or interact with the address. Failure to do this can result in users accidentally sending funds to the 0 address.
Changes to an address MUST trigger the following event:
https://eips.ethereum.org/EIPS/eip-155
If block.number >= FORK_BLKNUM and CHAIN_ID is available, then when computing the hash of a transaction for the purposes of signing, instead of hashing only six rlp encoded elements (nonce, gasprice, startgas, to, value, data), you SHOULD hash nine rlp encoded elements (nonce, gasprice, startgas, to, value, data, chainid, 0, 0). If you do, then the v of the signature MUST be set to {0,1} + CHAIN_ID * 2 + 35 where {0,1} is the parity of the y value of the curve point for which r is the x-value in the secp256k1 signing process. If you choose to only hash 6 values, then v continues to be set to {0,1} + 27 as previously.
https://eips.ethereum.org/EIPS/eip-681
Note that a number can be expressed in scientific notation, with a multiplier of a power of 10. Only integer numbers are allowed, so the exponent MUST be greater or equal to the number of decimals after the point.
If key in the parameter list is value, gasLimit, gasPrice or gas then value MUST be a number. Otherwise, it must correspond to the TYPE string used as key.
https://eips.ethereum.org/EIPS/eip-721
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.
The 0.4.20 Solidity interface grammar is not expressive enough to document the ERC-721 standard. A contract which complies with ERC-721 MUST also abide by the following:
Every NFT is identified by a unique uint256 ID inside the ERC-721 smart contract. This identifying number SHALL NOT change for the life of the contract. The pair (contract address, uint256 tokenId) will then be a globally unique and fully-qualified identifier for a specific asset on an Ethereum chain. While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a “black box”. Also note that NFTs MAY become invalid (be destroyed). Please see the enumeration functions for a supported enumeration interface.
The transfer and accept functions’ documentation only specify conditions when the transaction MUST throw. Your implementation MAY also throw in other situations. This allows implementations to achieve interesting results:
https://eips.ethereum.org/EIPS/eip-725
Executes a call on any other smart contracts, transfers the blockchains native token, or deploys a new smart contract.
MUST only be called by the current owner of the contract.
MUST be triggered when execute creates a new call using the operationType 0, 3, 4.
MUST be triggered when execute creates a new contract using the operationType 1, 2.
Sets data as bytes in the storage for a single key. MUST only be called by the current owner of the contract.
Sets array of data at multiple keys. MUST only be called by the current owner of the contract.
MUST be triggered when setData was successfully called.
https://eips.ethereum.org/EIPS/eip-777
The token contract MUST implement the above interface.
The implementation MUST follow the specifications described below.
The token contract MUST implement the above interface.
The implementation MUST follow the specifications described below.
The token contract MUST register the ERC777Token interface with its own address via ERC-1820.
If the contract has a switch to enable or disable ERC777 functions, every time the switch is triggered,
the token MUST register or unregister the ERC777Token interface for its own address accordingly via ERC1820.
Unregistering implies calling the setInterfaceImplementer with the token contract address as the address,
the keccak256 hash of ERC777Token as the interface hash and 0x0 as the implementer.
(See Set An Interface For An Address in ERC-1820 for more details.)
When interacting with the token contract, all amounts and balances MUST be unsigned integers.
I.e. internally, all values are stored as a denomination of 1E-18 of a token.
The display denomination—to display any amount to the end user—MUST
be 1018 of the internal denomination.
When interacting with the token contract, all amounts and balances MUST be unsigned integers.
I.e. internally, all values are stored as a denomination of 1E-18 of a token.
The display denomination—to display any amount to the end user—MUST
be 1018 of the internal denomination.
In other words, the internal denomination is similar to a wei
and the display denomination is similar to an ether.
It is equivalent to an ERC-20’s decimals function returning 18.
E.g. if a token contract returns a balance of 500,000,000,000,000,000 (0.5×1018) for a user,
the user interface MUST show 0.5 tokens to the user.
If the user wishes to send 0.3 tokens,
the contract MUST be called with an amount of 300,000,000,000,000,000 (0.3×1018).
In other words, the internal denomination is similar to a wei
and the display denomination is similar to an ether.
It is equivalent to an ERC-20’s decimals function returning 18.
E.g. if a token contract returns a balance of 500,000,000,000,000,000 (0.5×1018) for a user,
the user interface MUST show 0.5 tokens to the user.
If the user wishes to send 0.3 tokens,
the contract MUST be called with an amount of 300,000,000,000,000,000 (0.3×1018).
User Interfaces which are generated programmatically from the ABI of the token contract
MAY use and display the internal denomination.
But this MUST be made clear, for example by displaying the uint256 type.
The view functions detailed below MUST be implemented.
NOTE: The total supply MUST be equal to the sum of the balances of all addresses—as
returned by the balanceOf function.
NOTE: The total supply MUST be equal to the sum of all the minted tokens
as defined in all the Minted events minus the sum of all the burned tokens as defined in all the Burned events.
The balance MUST be zero (0) or higher.
The following rules MUST be applied regarding the granularity:
ERC-20 compatibility requirement:
The decimals of the token MUST always be 18.
For a pure ERC777 token the ERC-20 decimals function is OPTIONAL,
and its existence SHALL NOT be relied upon when interacting with the token contract.
(The decimal value of 18 is implied.)
For an ERC-20 compatible token, the decimals function is REQUIRED and MUST return 18.
(In ERC-20, the decimals function is OPTIONAL.
If the function is not present, the decimals value is not clearly defined and may be assumed to be 0.
Hence for compatibility reasons, decimals MUST be implemented for ERC-20 compatible tokens.)
ERC-20 compatibility requirement:
The decimals of the token MUST always be 18.
For a pure ERC777 token the ERC-20 decimals function is OPTIONAL,
and its existence SHALL NOT be relied upon when interacting with the token contract.
(The decimal value of 18 is implied.)
For an ERC-20 compatible token, the decimals function is REQUIRED and MUST return 18.
(In ERC-20, the decimals function is OPTIONAL.
If the function is not present, the decimals value is not clearly defined and may be assumed to be 0.
Hence for compatibility reasons, decimals MUST be implemented for ERC-20 compatible tokens.)
ERC-20 compatibility requirement:
The decimals of the token MUST always be 18.
For a pure ERC777 token the ERC-20 decimals function is OPTIONAL,
and its existence SHALL NOT be relied upon when interacting with the token contract.
(The decimal value of 18 is implied.)
For an ERC-20 compatible token, the decimals function is REQUIRED and MUST return 18.
(In ERC-20, the decimals function is OPTIONAL.
If the function is not present, the decimals value is not clearly defined and may be assumed to be 0.
Hence for compatibility reasons, decimals MUST be implemented for ERC-20 compatible tokens.)
When an address becomes an operator for a holder, an AuthorizedOperator event MUST be emitted.
The AuthorizedOperator’s operator (topic 1) and holder (topic 2)
MUST be the addresses of the operator and the holder respectively.
When an address becomes an operator for a holder, an AuthorizedOperator event MUST be emitted.
The AuthorizedOperator’s operator (topic 1) and holder (topic 2)
MUST be the addresses of the operator and the holder respectively.
When a holder revokes an operator, a RevokedOperator event MUST be emitted.
The RevokedOperator’s operator (topic 1) and holder (topic 2)
MUST be the addresses of the operator and the holder respectively.
When a holder revokes an operator, a RevokedOperator event MUST be emitted.
The RevokedOperator’s operator (topic 1) and holder (topic 2)
MUST be the addresses of the operator and the holder respectively.
The token MAY define default operators.
A default operator is an implicitly authorized operator for all holders.
AuthorizedOperator events MUST NOT be emitted when defining the default operators.
The rules below apply to default operators:
NOTE: A holder MAY authorize an already authorized operator.
An AuthorizedOperator MUST be emitted each time.
NOTE: A holder MAY revoke an already revoked operator.
A RevokedOperator MUST be emitted each time.
NOTE: This event MUST NOT be emitted outside of an operator authorization process.
NOTE: This event MUST NOT be emitted outside of an operator revocation process.
The defaultOperators, authorizeOperator, revokeOperator and isOperatorFor functions described below
MUST be implemented to manage operators.
Token contracts MAY implement other functions to manage operators.
NOTE: If the token contract does not have any default operators, this function MUST return an empty list.
NOTE: The holder (msg.sender) is always an operator for itself.
This right SHALL NOT be revoked.
Hence this function MUST revert if it is called to authorize the holder (msg.sender)
as an operator for itself (i.e. if operator is equal to msg.sender).
NOTE: The holder (msg.sender) is always an operator for itself.
This right SHALL NOT be revoked.
Hence this function MUST revert if it is called to revoke the holder (msg.sender)
as an operator for itself (i.e., if operator is equal to msg.sender).
NOTE: To know which addresses are operators for a given holder,
one MUST call isOperatorFor with the holder for each default operator
and parse the AuthorizedOperator, and RevokedOperator events for the holder in question.
When an operator sends an amount of tokens from a holder to a recipient
with the associated data and operatorData, the token contract MUST apply the following rules:
The token contract MUST revert when sending in any of the following cases:
NOTE: Sending an amount of zero (0) tokens is valid and MUST be treated as a regular send.
The operatorData MUST only be provided by the operator.
It is intended more for logging purposes and particular cases.
(Examples include payment references, cheque numbers, countersignatures and more.)
In most of the cases the recipient would ignore the operatorData, or at most, it would log the operatorData.
NOTE: This event MUST NOT be emitted outside of a send or an ERC-20 transfer process.
The send and operatorSend functions described below MUST be implemented to send tokens.
Token contracts MAY implement other functions to send tokens.
The operator and the holder MUST both be the msg.sender.
Reminder: If the operator address is not an authorized operator of the from address,
then the send process MUST revert.
NOTE: from and msg.sender MAY be the same address.
I.e., an address MAY call operatorSend for itself.
This call MUST be equivalent to send with the addition
that the operator MAY specify an explicit value for operatorData
(which cannot be done with the send function).
Nonetheless, the rules below MUST be respected when minting for a recipient:
The token contract MUST revert when minting in any of the following cases:
NOTE: The initial token supply at the creation of the token contract MUST be considered as minting
for the amount of the initial supply to the address(es) receiving the initial supply.
This means one or more Minted events must be emitted
and the tokensReceived hook of the recipient(s) MUST be called.
NOTE: The initial token supply at the creation of the token contract MUST be considered as minting
for the amount of the initial supply to the address(es) receiving the initial supply.
This means one or more Minted events must be emitted
and the tokensReceived hook of the recipient(s) MUST be called.
ERC-20 compatibility requirement:
While a Sent event MUST NOT be emitted when minting,
if the token contract is ERC-20 backward compatible,
a Transfer event with the from parameter set to 0x0 SHOULD be emitted as defined in the ERC-20 standard.
NOTE: Minting an amount of zero (0) tokens is valid and MUST be treated as a regular mint.
NOTE: This event MUST NOT be emitted outside of a mint process.
The rules below MUST be respected when burning the tokens of a holder:
The token contract MUST revert when burning in any of the following cases:
ERC-20 compatibility requirement:
While a Sent event MUST NOT be emitted when burning;
if the token contract is ERC-20 enabled, a Transfer event with the to parameter set to 0x0 SHOULD be emitted.
The ERC-20 standard does not define the concept of burning tokens, but this is a commonly accepted practice.
NOTE: Burning an amount of zero (0) tokens is valid and MUST be treated as a regular burn.
NOTE: This event MUST NOT be emitted outside of a burn process.
The burn and operatorBurn functions described below MUST be implemented to burn tokens.
Token contracts MAY implement other functions to burn tokens.
The operator and the holder MUST both be the msg.sender.
Reminder: If the operator address is not an authorized operator of the from address,
then the burn process MUST revert.
NOTE: The operator MAY pass any information via operatorData.
The operatorData MUST only be provided by the operator.
NOTE: from and msg.sender MAY be the same address.
I.e., an address MAY call operatorBurn for itself.
This call MUST be equivalent to burn
with the addition that the operator MAY specify an explicit value for operatorData
(which cannot be done with the burn function).
NOTE: A regular address MAY register a different address—the address of a contract—implementing
the interface on its behalf.
A contract MAY register either its address or the address of another contract
but said address MUST implement the interface on its behalf.
NOTE: This function MUST NOT be called outside of a burn, send or ERC-20 transfer process.
NOTE: An address can register at most one implementation at any given time for all ERC-777 tokens.
Hence the ERC777TokensSender MUST expect to be called by different token contracts.
The msg.sender of the tokensToSend call is expected to be the address of the token contract.
ERC-20 compatibility requirement:
This hook takes precedence over ERC-20 and MUST be called (if registered)
when calling ERC-20’s transfer and transferFrom event.
When called from a transfer, operator MUST be the same value as the from.
When called from a transferFrom, operator MUST be the address which issued the transferFrom call.
ERC-20 compatibility requirement:
This hook takes precedence over ERC-20 and MUST be called (if registered)
when calling ERC-20’s transfer and transferFrom event.
When called from a transfer, operator MUST be the same value as the from.
When called from a transferFrom, operator MUST be the address which issued the transferFrom call.
ERC-20 compatibility requirement:
This hook takes precedence over ERC-20 and MUST be called (if registered)
when calling ERC-20’s transfer and transferFrom event.
When called from a transfer, operator MUST be the same value as the from.
When called from a transferFrom, operator MUST be the address which issued the transferFrom call.
NOTE: A regular address MAY register a different address—the address of a contract—implementing
the interface on its behalf.
A contract MUST register either its address or the address of another contract
but said address MUST implement the interface on its behalf.
NOTE: A regular address MAY register a different address—the address of a contract—implementing
the interface on its behalf.
A contract MUST register either its address or the address of another contract
but said address MUST implement the interface on its behalf.
NOTE: This function MUST NOT be called outside of a mint, send or ERC-20 transfer process.
NOTE: An address can register at most one implementation at any given time for all ERC-777 tokens.
Hence the ERC777TokensRecipient MUST expect to be called by different token contracts.
The msg.sender of the tokensReceived call is expected to be the address of the token contract.
ERC-20 compatibility requirement:
This hook takes precedence over ERC-20 and MUST be called (if registered)
when calling ERC-20’s transfer and transferFrom event.
When called from a transfer, operator MUST be the same value as the from.
When called from a transferFrom, operator MUST be the address which issued the transferFrom call.
ERC-20 compatibility requirement:
This hook takes precedence over ERC-20 and MUST be called (if registered)
when calling ERC-20’s transfer and transferFrom event.
When called from a transfer, operator MUST be the same value as the from.
When called from a transferFrom, operator MUST be the address which issued the transferFrom call.
ERC-20 compatibility requirement:
This hook takes precedence over ERC-20 and MUST be called (if registered)
when calling ERC-20’s transfer and transferFrom event.
When called from a transfer, operator MUST be the same value as the from.
When called from a transferFrom, operator MUST be the address which issued the transferFrom call.
The logo MUST NOT be used to advertise, promote or associate in any way technology—such
as tokens—which is not ERC-777 compliant.
The token MAY implement decimals() for backward compatibility with ERC-20.
If implemented, it MUST always return 18.
Therefore a token contract MAY implement both ERC-20 and ERC-777 in parallel.
The specification of the view functions (such as name, symbol, balanceOf, totalSupply) and internal data
(such as the mapping of balances) overlap without problems.
Note however that the following functions are mandatory in ERC-777 and MUST be implemented:
name, symbol balanceOf and totalSupply
(decimals is not part of the ERC-777 standard).
If the token implements ERC-20,
it MUST register the ERC20Token interface with its own address via ERC-1820.
This is done by calling the setInterfaceImplementer function on the ERC1820 registry
with the token contract address as both the address and the implementer
and the keccak256 hash of ERC20Token (0xaea199e31a596269b42cdafd93407f14436db6e4cad65417994c2eb37381e05a)
as the interface hash.
If the contract has a switch to enable or disable ERC20 functions, every time the switch is triggered,
the token MUST register or unregister the ERC20Token interface for its own address accordingly via ERC1820.
Unregistering implies calling the setInterfaceImplementer with the token contract address as the address,
the keccak256 hash of ERC20Token as the interface hash and 0x0 as the implementer.
(See Set An Interface For An Address in ERC-1820 for more details.)
The difference for new contracts implementing ERC-20 is that
tokensToSend and tokensReceived hooks take precedence over ERC-20.
Even with an ERC-20 transfer and transferFrom call, the token contract MUST check via ERC-1820
if the from and the to address implement tokensToSend and tokensReceived hook respectively.
If any hook is implemented, it MUST be called.
Note that when calling ERC-20 transfer on a contract, if the contract does not implement tokensReceived,
the transfer call SHOULD still be accepted even if this means the tokens will probably be locked.
The difference for new contracts implementing ERC-20 is that
tokensToSend and tokensReceived hooks take precedence over ERC-20.
Even with an ERC-20 transfer and transferFrom call, the token contract MUST check via ERC-1820
if the from and the to address implement tokensToSend and tokensReceived hook respectively.
If any hook is implemented, it MUST be called.
Note that when calling ERC-20 transfer on a contract, if the contract does not implement tokensReceived,
the transfer call SHOULD still be accepted even if this means the tokens will probably be locked.
The table below summarizes the different actions the token contract MUST take
when sending, minting and transferring token via ERC-777 and ERC-20:
There is no particular action to take if tokensToSend is not implemented.
The movement MUST proceed and only be canceled if another condition is not respected
such as lack of funds or a revert in tokensReceived (if present).
During a send, mint and burn, the respective Sent, Minted and Burned events MUST be emitted.
Furthermore, if the token contract declares that it implements ERC20Token via ERC-1820,
the token contract SHOULD emit a Transfer event for minting and burning
and MUST emit a Transfer event for sending (as specified in the ERC-20 standard).
During an ERC-20’s transfer or transferFrom functions, a valid Sent event MUST be emitted.
During a send, mint and burn, the respective Sent, Minted and Burned events MUST be emitted.
Furthermore, if the token contract declares that it implements ERC20Token via ERC-1820,
the token contract SHOULD emit a Transfer event for minting and burning
and MUST emit a Transfer event for sending (as specified in the ERC-20 standard).
During an ERC-20’s transfer or transferFrom functions, a valid Sent event MUST be emitted.
During a send, mint and burn, the respective Sent, Minted and Burned events MUST be emitted.
Furthermore, if the token contract declares that it implements ERC20Token via ERC-1820,
the token contract SHOULD emit a Transfer event for minting and burning
and MUST emit a Transfer event for sending (as specified in the ERC-20 standard).
During an ERC-20’s transfer or transferFrom functions, a valid Sent event MUST be emitted.
Hence for any movement of tokens, two events MAY be emitted:
an ERC-20 Transfer and an ERC-777 Sent, Minted or Burned (depending on the type of movement).
Third-party developers MUST be careful not to consider both events as separate movements.
As a general rule, if an application considers the token as an ERC20 token,
then only the Transfer event MUST be taken into account.
If the application considers the token as an ERC777 token,
then only the Sent, Minted and Burned events MUST be considered.
Hence for any movement of tokens, two events MAY be emitted:
an ERC-20 Transfer and an ERC-777 Sent, Minted or Burned (depending on the type of movement).
Third-party developers MUST be careful not to consider both events as separate movements.
As a general rule, if an application considers the token as an ERC20 token,
then only the Transfer event MUST be taken into account.
If the application considers the token as an ERC777 token,
then only the Sent, Minted and Burned events MUST be considered.
Hence for any movement of tokens, two events MAY be emitted:
an ERC-20 Transfer and an ERC-777 Sent, Minted or Burned (depending on the type of movement).
Third-party developers MUST be careful not to consider both events as separate movements.
As a general rule, if an application considers the token as an ERC20 token,
then only the Transfer event MUST be taken into account.
If the application considers the token as an ERC777 token,
then only the Sent, Minted and Burned events MUST be considered.
https://eips.ethereum.org/EIPS/eip-779
Blocks with block numbers in the range [1_920_000, 1_920_009] MUST have 0x64616f2d686172642d666f726b (hex encoded ASCII string dao-hard-fork) in the extraData field of the block.
https://eips.ethereum.org/EIPS/eip-801
MUST trigger when the contract is called the first time after the canary died.
https://eips.ethereum.org/EIPS/eip-820
Below is the raw transaction which MUST be used to deploy the smart contract on any chain.
If the interface is part of an approved ERC, it MUST be named ERC###XXXXX where ### is the number of the ERC and XXXXX should be the name of the interface in CamelCase. The meaning of this interface SHOULD be defined in the specified ERC.
NOTE: The result is cached. If the cache is out of date, it MUST be updated by calling updateERC165Cache. (See ERC165 Cache for more details.)
If a contract dynamically changes its interface and relies on the ERC-165 cache of the ERC-820 registry, the cache MUST be updated manually—there is no automatic cache invalidation or cache update. Ideally the contract SHOULD automatically update the cache when changing its interface. However anyone MAY update the cache on the contract’s behalf.
The cache update MUST be done using the updateERC165Cache function:
This scheme is extensible. You MAY make up your own interface name and raise awareness to get other people to implement it and then check for those implementations. Have fun but please, you MUST not conflict with the reserved designations above.
NOTE: The _interfaceHash MUST NOT be an ERC-165 interface—it MUST NOT end with 28 zeroes (0).
NOTE: The _interfaceHash MUST NOT be an ERC-165 interface—it MUST NOT end with 28 zeroes (0).
Any contract being registered as the implementation of an interface for a given address MUST implement said interface. In addition if it implements an interface on behalf of a different address, the contract MUST implement the ERC820ImplementerInterface shown above.
Any contract being registered as the implementation of an interface for a given address MUST implement said interface. In addition if it implements an interface on behalf of a different address, the contract MUST implement the ERC820ImplementerInterface shown above.
If a contract implements the interface (interfaceHash) for a given address (addr), it MUST return ERC820_ACCEPT_MAGIC when called with the addr and the interfaceHash. If it does not implement the interfaceHash for a given address (addr), it MUST NOT return ERC820_ACCEPT_MAGIC.
If a contract implements the interface (interfaceHash) for a given address (addr), it MUST return ERC820_ACCEPT_MAGIC when called with the addr and the interfaceHash. If it does not implement the interfaceHash for a given address (addr), it MUST NOT return ERC820_ACCEPT_MAGIC.
https://eips.ethereum.org/EIPS/eip-823
NOTE: Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!
NOTE: Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!
NOTE: Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!
NOTE: Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!
https://eips.ethereum.org/EIPS/eip-900
Stakes a certain amount of tokens, this MUST transfer the given amount from the user.
MUST trigger Staked event.
Stakes a certain amount of tokens, this MUST transfer the given amount from the caller.
MUST trigger Staked event.
Unstakes a certain amount of tokens, this SHOULD return the given amount of tokens to the user, if unstaking is currently not possible the function MUST revert.
MUST trigger Unstaked event.
MUST return true if the optional history functions are implemented, otherwise false.
https://eips.ethereum.org/EIPS/eip-902
This event MUST be fired on return from a call to a TokenValidator.check/2.
This event MUST be fired on return from a call to a TokenValidator.check/4.
https://eips.ethereum.org/EIPS/eip-926
Providers may implement any subset of the metadata record types specified here. Where a record types specification requires a provider to provide multiple functions, the provider MUST implement either all or none of them. Providers MUST throw if called with an unsupported function ID.
Providers may implement any subset of the metadata record types specified here. Where a record types specification requires a provider to provide multiple functions, the provider MUST implement either all or none of them. Providers MUST throw if called with an unsupported function ID.
The first argument to all provider functions MUST be the address being queried; this facilitates the creation of multi-user provider contracts.
https://eips.ethereum.org/EIPS/eip-927
Arguments have the same meaning as in canCall. Implementing contracts MUST ensure that msg.sender is authorised to call authoriseCaller or revokeCaller on behalf of owner; this MUST always be true if owner == msg.sender. Implementing contracts SHOULD use the standard specified here to determine if other callers may provide authorisations as well.
Arguments have the same meaning as in canCall. Implementing contracts MUST ensure that msg.sender is authorised to call authoriseCaller or revokeCaller on behalf of owner; this MUST always be true if owner == msg.sender. Implementing contracts SHOULD use the standard specified here to determine if other callers may provide authorisations as well.
https://eips.ethereum.org/EIPS/eip-998
This function transfers an amount of tokens from a user address to an ERC721 token. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address. This function MUST emit the TransferToParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the _from account balance does not have enough tokens to spend.
This function transfers an amount of tokens from a user address to an ERC721 token. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address. This function MUST emit the TransferToParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the _from account balance does not have enough tokens to spend.
This function transfers an amount of tokens from a user address to an ERC721 token. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address. This function MUST emit the TransferToParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the _from account balance does not have enough tokens to spend.
This function transfers an amount of tokens from an ERC721 token to an address. This function MUST emit the TransferFromParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise.
This function transfers an amount of tokens from an ERC721 token to an address. This function MUST emit the TransferFromParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise.
This function transfers an amount of tokens from an ERC721 token to an address. This function MUST emit the TransferFromParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise.
This function transfers an amount of tokens from an ERC721 token to an address. This function MUST emit the TransferFromParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise.
This function transfers an amount of tokens from an ERC721 token to an address. This function has identical requirements to transferFromParent, except that it additionally MUST invoke tokenFallback on the recipient address, if the address is a contract, as specified by ERC223.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
For backwards-compatibility, implementations MUST emit the standard ERC20 Transfer event when a transfer occurs, regardless of whether the sender and recipient are addresses or ERC721 tokens. In the case that either sender or recipient are tokens, the corresponding parameter in the Transfer event SHOULD be the contract address of the token.
Implementations MUST implement all ERC20 and ERC223 functions in addition to the functions specified in this interface.
https://eips.ethereum.org/EIPS/eip-1056
MUST be triggered when changeOwner or changeOwnerSigned was successfully called.
MUST be triggered when a change to a delegate was successfully made.
MUST be triggered when a change to an attribute was successfully made.
https://eips.ethereum.org/EIPS/eip-1077
The message MUST be signed as EIP-191 standard, and the called contract MUST also implement EIP-1271 which must validate the signed messages.
The message MUST be signed as EIP-191 standard, and the called contract MUST also implement EIP-1271 which must validate the signed messages.
Messages MUST be signed by the owner of the account contract executing. If the owner is a contract, it must implement EIP-1271 interface and forward validation to it.
In order to be compliant, the transaction MUST request to sign a “messageHash” that is a concatenation of multiple fields.
The fields MUST be constructed as this method:
If _gasRelayer is zero, then the funds MUST go to block.coinbase.
If there are not enough funds, or if the total surpasses gasLimit then the transaction MUST revert.
https://eips.ethereum.org/EIPS/eip-1080
Reports the lostAccount address as being lost. MUST trigger the AccountClaimedLost event.
After the time configured in getLostAccountRecoveryTimeInMinutes the implementer MUST provide a mechanism for determining the correct owner of the tokens held and moving the tokens to a new account.
Reports the msg.sender’s account as being not being lost. MUST trigger the AccountClaimedLostCanceled event.
MUST fail if an account recovery process has already begun.
Otherwise, this method MUST stop a dispute from being started to recover funds.
Reports the current address as being stolen. MUST trigger the AccountFrozen event.
Successful calls MUST result in the msg.sender’s tokens being frozen.
Reports the current address as being stolen. MUST trigger the AccountFrozen event.
Successful calls MUST result in the msg.sender’s tokens being frozen.
The implementer MUST provide a mechanism for determining the correct owner of the tokens held and moving the tokens to a new account.
The implementer MUST provide a mechanism for determining the correct owner of the tokens disputed and moving the tokens to the correct account.
MUST comply with sender’s chargeback window as value configured by setPendingTransferTimeInMinutes.
MUST NOT change the time if the account has any pending transfers.
MUST NOT change the time if the account has open disputes.
A record of an account being frozen. MUST trigger when an account is frozen.
https://eips.ethereum.org/EIPS/eip-1102
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
Dapps MUST request accounts by calling the eth_requestAccounts RPC method on the provider exposed at window.ethereum. Calling this method MAY trigger a user interface that allows the user to approve or reject account access for a given dapp. This method MUST return a Promise that is resolved with an array of one or more user accounts or rejected if no accounts are available (e.g., the user rejected account access).
Dapps MUST request accounts by calling the eth_requestAccounts RPC method on the provider exposed at window.ethereum. Calling this method MAY trigger a user interface that allows the user to approve or reject account access for a given dapp. This method MUST return a Promise that is resolved with an array of one or more user accounts or rejected if no accounts are available (e.g., the user rejected account access).
The Promise returned when calling the eth_requestAccounts RPC method MUST be resolved with an Array of user accounts.
The Promise returned when calling the eth_requestAccounts RPC method MUST be rejected with an informative Error if no accounts are available for any reason.
https://eips.ethereum.org/EIPS/eip-1109
A PRECOMPILEDCALL to a regular address or regular smart contract, is considered a call to an “undefined smart contract”, so the VM MUST not execute it and the opcode must return 0x0 .
https://eips.ethereum.org/EIPS/eip-1123
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-1129
MUST trigger when new announcement is created.
MUST trigger when an announcement is removed.
https://eips.ethereum.org/EIPS/eip-1154
receiveResult MUST revert if the msg.sender is not an oracle authorized to provide the result for that id.
receiveResult MUST revert if receiveResult has been called with the same id before.
Consumers MUST coordinate with oracles to determine how to encode/decode results to and from bytes. For example, abi.encode and abi.decode may be used to implement a codec for results in Solidity. receiveResult SHOULD revert if the consumer receives a unexpected result format from the oracle.
resultFor MUST revert if the result for an id is not available yet.
resultFor MUST return the same result for an id after that result is available.
https://eips.ethereum.org/EIPS/eip-1155
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Smart contracts implementing the ERC-1155 standard MUST implement all of the functions in the ERC1155 interface.
Smart contracts implementing the ERC-1155 standard MUST implement the ERC-165 supportsInterface function and MUST return the constant value true if 0xd9b67a26 is passed through the interfaceID argument.
Smart contracts implementing the ERC-1155 standard MUST implement the ERC-165 supportsInterface function and MUST return the constant value true if 0xd9b67a26 is passed through the interfaceID argument.
Smart contracts MUST implement all of the functions in the ERC1155TokenReceiver interface to accept transfers. See “Safe Transfer Rules” for further detail.
Smart contracts MUST implement the ERC-165 supportsInterface function and signify support for the ERC1155TokenReceiver interface to accept transfers. See “ERC1155TokenReceiver ERC-165 rules” for further detail.
To be more explicit about how the standard safeTransferFrom and safeBatchTransferFrom functions MUST operate with respect to the ERC1155TokenReceiver hook functions, a list of scenarios and rules follows.
The URI value allows for ID substitution by clients. If the string {id} exists in any URI, clients MUST replace this with the actual token ID in hexadecimal form. This allows for a large number of tokens to use the same on-chain string by defining a URI once, for that large number of tokens.
This JSON schema is loosely based on the “ERC721 Metadata JSON Schema”, but includes optional formatting to allow for ID substitution by clients. If the string {id} exists in any JSON value, it MUST be replaced with the actual token ID, by all client software that follows this standard.
Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains a localization attribute, its content MAY be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three attributes: uri, default and locales. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.
The requirement to emit TransferSingle or TransferBatch on balance change implies that a valid implementation of ERC-1155 redeploying to a new contract address MUST emit events from the new contract address to replicate the deprecated contract final state. It is valid to only emit a minimal number of events to reflect only the final balance and omit all the transactions that led to that state. The event emit requirement is to ensure that the current state of the contract can always be traced only through events. To alleviate the need to emit events when changing contract address, consider using the proxy pattern, such as described in EIP-2535. This will also have the added benefit of providing a stable contract address for users.
Hence in a hybrid ERC-1155 contract implementation an extra call MUST be made on the recipient contract and checked before any hook calls to onERC1155Received or onERC1155BatchReceived are made.
Order of operation MUST therefore be:
Hence in a hybrid ERC-1155 contract implementation an extra call MUST be made on the recipient contract and checked before any hook calls to onERC1155Received or onERC1155BatchReceived are made.
Order of operation MUST therefore be:
An important consideration is that even if the tokens are sent with another standard’s rules the ERC-1155 transfer events MUST still be emitted. This is so the balances can still be determined via events alone as per ERC-1155 standard rules.
https://eips.ethereum.org/EIPS/eip-1178
OPTIONAL - It is recommended that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method.
OPTIONAL - It is recommended that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method.
OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method.
Grants approval for address _to to take possession quantity amount of the MCFT with ID _classId. This method MUST throw if balanceOf(msg.sender, _classId) < quantity, or if _classId does not represent an MCFT class currently tracked by this contract, or if msg.sender == _to.
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Assigns the ownership of quantity MCFT’s with ID _classId to _to if and only if quantity == balanceOf(msg.sender, _classId). A successful transfer MUST fire the Transfer event (defined below).
This method MUST transfer ownership to _to or throw, no other outcomes can be possible. Reasons for failure include (but are not limited to):
A conforming contract MUST allow the current owner to “transfer” a token to themselves, as a way of affirming ownership in the event stream. (i.e. it is valid for _to == msg.sender if balanceOf(msg.sender, _classId) >= balance.) This “no-op transfer” MUST be considered a successful transfer, and therefore MUST fire a Transfer event (with the same address for _from and _to).
A conforming contract MUST allow the current owner to “transfer” a token to themselves, as a way of affirming ownership in the event stream. (i.e. it is valid for _to == msg.sender if balanceOf(msg.sender, _classId) >= balance.) This “no-op transfer” MUST be considered a successful transfer, and therefore MUST fire a Transfer event (with the same address for _from and _to).
A conforming contract MUST allow the current owner to “transfer” a token to themselves, as a way of affirming ownership in the event stream. (i.e. it is valid for _to == msg.sender if balanceOf(msg.sender, _classId) >= balance.) This “no-op transfer” MUST be considered a successful transfer, and therefore MUST fire a Transfer event (with the same address for _from and _to).
This event MUST trigger when MCFT ownership is transferred via any mechanism.
Additionally, the creation of new MCFTs MUST trigger a Transfer event for each newly created MCFTs, with a _from address of 0 and a _to address matching the owner of the new MCFT (possibly the smart contract itself). The deletion (or burn) of any MCFT MUST trigger a Transfer event with a _to address of 0 and a _from address of the owner of the MCFT (now former owner!).
Additionally, the creation of new MCFTs MUST trigger a Transfer event for each newly created MCFTs, with a _from address of 0 and a _to address matching the owner of the new MCFT (possibly the smart contract itself). The deletion (or burn) of any MCFT MUST trigger a Transfer event with a _to address of 0 and a _from address of the owner of the MCFT (now former owner!).
Approval
This event MUST trigger on any successful call to approve(_to, _classId, quantity) (unless the caller is attempting to clear approval when there is no pending approval).
https://eips.ethereum.org/EIPS/eip-1193
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The Provider MUST implement and expose the API defined in this section.
All API entities MUST adhere to the types and interfaces defined in this section.
The Provider MUST implement and expose the API defined in this section.
All API entities MUST adhere to the types and interfaces defined in this section.
The Provider MUST identify the requested RPC method by the value of RequestArguments.method.
If the requested RPC method takes any parameters, the Provider MUST accept them as the value of RequestArguments.params.
RPC requests MUST be handled such that the returned Promise either resolves with a value per the requested RPC method’s specification, or rejects with an error.
If resolved, the Promise MUST resolve with a result per the RPC method’s specification. The Promise MUST NOT resolve with any RPC protocol-specific response objects, unless the RPC method’s return type is so defined.
If resolved, the Promise MUST resolve with a result per the RPC method’s specification. The Promise MUST NOT resolve with any RPC protocol-specific response objects, unless the RPC method’s return type is so defined.
If the returned Promise rejects, it MUST reject with a ProviderRpcError as specified in the RPC Errors section below.
The returned Promise MUST reject if any of the following conditions are met:
All supported RPC methods MUST be identified by unique strings.
The Provider MUST implement the following event handling methods:
These methods MUST be implemented per the Node.js EventEmitter API.
When emitted, the message event MUST be emitted with an object argument of the following form:
If the Provider supports Ethereum RPC subscriptions, e.g. eth_subscribe, the Provider MUST emit the message event when it receives a subscription notification.
If the Provider receives a subscription message from e.g. an eth_subscribe subscription, the Provider MUST emit a message event with a ProviderMessage object of the following form:
If the Provider becomes connected, the Provider MUST emit the event named connect.
This event MUST be emitted with an object of the following form:
chainId MUST specify the integer ID of the connected chain as a hexadecimal string, per the eth_chainId Ethereum RPC method.
If the Provider becomes disconnected from all chains, the Provider MUST emit the event named disconnect with value error: ProviderRpcError, per the interfaced defined in the RPC Errors section. The value of the error’s code property MUST follow the status codes for CloseEvent.
If the Provider becomes disconnected from all chains, the Provider MUST emit the event named disconnect with value error: ProviderRpcError, per the interfaced defined in the RPC Errors section. The value of the error’s code property MUST follow the status codes for CloseEvent.
If the chain the Provider is connected to changes, the Provider MUST emit the event named chainChanged with value chainId: string, specifying the integer ID of the new chain as a hexadecimal string, per the eth_chainId Ethereum RPC method.
If the accounts available to the Provider change, the Provider MUST emit the event named accountsChanged with value accounts: string[], containing the account addresses per the eth_accounts Ethereum RPC method.
https://eips.ethereum.org/EIPS/eip-1207
All public or external functions that are allowed the grantee to call MUST use overload to implement two functions: The First one is the standard method that the user invokes directly, the second one is the grantee methods of the same function name with one more authorizer address parameter.
https://eips.ethereum.org/EIPS/eip-1261
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The 0.4.24 Solidity interface grammar is not expressive enough to document the ERC-1261 standard. A contract which complies with ERC-1261 MUST also abide by the following:
The assign and revoke functions’ documentation only specify conditions when the transaction MUST throw. Your implementation MAY also throw in other situations. This allows implementations to achieve interesting results:
https://eips.ethereum.org/EIPS/eip-1271
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-1319
MUST be triggered when release is successfully called.
https://eips.ethereum.org/EIPS/eip-1363
Implementing contracts MUST implement the ERC-1363 interface as well as the ERC-20 and ERC-165 interfaces.
A contract that wants to accept token payments via transferAndCall or transferFromAndCall MUST implement the following interface:
A contract that wants to accept token payments via approveAndCall MUST implement the following interface:
https://eips.ethereum.org/EIPS/eip-1417
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The 0.4.24 Solidity interface grammar is not expressive enough to document the ERC-1417 standard. A contract which complies with ERC-1417 MUST also abide by the following:
https://eips.ethereum.org/EIPS/eip-1444
A fallback Localization with all keys filled MUST be available. If the user-specified Localization has not explicitly set a loalization (ie. textFor returns ""), the LocalizationPreferences MUST redelegate to the fallback Localization.
A fallback Localization with all keys filled MUST be available. If the user-specified Localization has not explicitly set a loalization (ie. textFor returns ""), the LocalizationPreferences MUST redelegate to the fallback Localization.
The first return value (bool _wasFound) represents if the text is available from that Localization, or if a fallback was used. If the fallback was used in this context, the textFor’s first return value MUST be set to false, and is true otherwise.
All strings MUST be encoded as UTF-8.
Template strings are allowed, and MUST follow the ANSI C printf conventions.
https://eips.ethereum.org/EIPS/eip-1474
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
Communication with Ethereum nodes is accomplished using JSON-RPC, a stateless, lightweight remote procedure call protocol that uses JSON as its data format. Ethereum RPC methods MUST be called using JSON-RPC request objects and MUST respond with JSON-RPC response objects.
Communication with Ethereum nodes is accomplished using JSON-RPC, a stateless, lightweight remote procedure call protocol that uses JSON as its data format. Ethereum RPC methods MUST be called using JSON-RPC request objects and MUST respond with JSON-RPC response objects.
If an Ethereum RPC method encounters an error, the error member included on the response object MUST be an object containing a code member and descriptive message member. The following list contains all possible error codes and associated messages:
New Ethereum RPC methods and changes to existing methods MUST be proposed via the traditional EIP process. This allows for community consensus around new method implementations and proposed method modifications. RPC method proposals MUST reach “draft” status before being added to this proposal and the official Ethereum RPC specification defined herein.
New Ethereum RPC methods and changes to existing methods MUST be proposed via the traditional EIP process. This allows for community consensus around new method implementations and proposed method modifications. RPC method proposals MUST reach “draft” status before being added to this proposal and the official Ethereum RPC specification defined herein.
https://eips.ethereum.org/EIPS/eip-1484
MUST be triggered when an Identity is created.
MUST be triggered when an address is added to an Identity.
MUST be triggered when an address is removed from an Identity.
MUST be triggered when a provider is added to an Identity.
MUST be triggered when a provider is removed.
MUST be triggered when a resolver is added.
MUST be triggered when a resolver is removed.
MUST be triggered when a recovery address change is triggered.
MUST be triggered when recovery is triggered.
MUST be triggered when an Identity is destroyed.
https://eips.ethereum.org/EIPS/eip-1523
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
An ERC-1523 compliant insurance policy is a non-fungible token which MUST adhere to the ERC-721 token standard and MUST implement theERC721Metadata and the ERC721Enumerable interface:
An ERC-1523 compliant insurance policy is a non-fungible token which MUST adhere to the ERC-721 token standard and MUST implement theERC721Metadata and the ERC721Enumerable interface:
In analogy to the “ERC721 Metadata JSON Schema”, the tokenURI MUST point to a JSON file with the following properties:
Parameters which are mandatory MUST be included in the metadata JSON. Other parameters MAY be included. However, the proposed optional parameters SHOULD be used for the intended purpose, so e.g. if the premium amount would be included in the metadata, the parameter name SHOULD be “premium”.
All parameters MAY be plain text or MAY also be URIs pointing to resources which contain the respective information, and which MAY be protected by an authentication mechanism.
For some applications it will be sufficient to store the metadata in an off-chain repository or database which can be addressed by the tokenURI resource locator.
For more advanced applications, it can be desirable to have metadata available on-chain.
Therefore, we require that the tokenURI MUST point to a JSON with the above structure, while the implementation of the policyMetadata function is OPTIONAL.
https://eips.ethereum.org/EIPS/eip-1559
Block validity is defined in the reference implementation below.
The GASPRICE (0x3a) opcode MUST return the effective_gas_price as defined in the reference implementation below.
https://eips.ethereum.org/EIPS/eip-1571
The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this document are to be interpreted as described in RFC 2119.
The definition mining pool server, and it’s plural form, is to be interpreted as work provider and later in this document can be shortened as pool or server.
The definition miner(s), and it’s plural form, is to be interpreted as work receiver/processor and later in this document can be shortened as miner or client.
The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this document are to be interpreted as described in RFC 2119.
The definition mining pool server, and it’s plural form, is to be interpreted as work provider and later in this document can be shortened as pool or server.
The definition miner(s), and it’s plural form, is to be interpreted as work receiver/processor and later in this document can be shortened as miner or client.
The Stratum protocol is an instance of JSON-RPC-2.0. The miner is a JSON-RPC client, and the server is a JSON-RPC server. All communications exist within the scope of a session. A session starts at the moment a client opens a TCP connection to the server till the moment either party do voluntary close the very same connection or it gets broken. Servers MAY support session resuming if this is initially negotiated (on first session handshaking) between the client and the server. During a session all messages exchanged among server and client are line-based which means all messages are JSON strings terminated by ASCII LF character (which may also be denoted as \n in this document). The LF character MUST NOT appear elsewhere in a message. Client and server implementations MUST assume that once they read a LF character, the current message has been completely received and can be processed.
Line messages are of three types :
The Stratum protocol is an instance of JSON-RPC-2.0. The miner is a JSON-RPC client, and the server is a JSON-RPC server. All communications exist within the scope of a session. A session starts at the moment a client opens a TCP connection to the server till the moment either party do voluntary close the very same connection or it gets broken. Servers MAY support session resuming if this is initially negotiated (on first session handshaking) between the client and the server. During a session all messages exchanged among server and client are line-based which means all messages are JSON strings terminated by ASCII LF character (which may also be denoted as \n in this document). The LF character MUST NOT appear elsewhere in a message. Client and server implementations MUST assume that once they read a LF character, the current message has been completely received and can be processed.
Line messages are of three types :
For this reason responses, we reiterate, MUST BE of two types:
The latter deserves a better explanation: failure responses can be distinguished by a severity degree.
Example 1 : a client submits a solution and server rejects it cause it’s not below target. Server MUST respond like this
Example 2 : a client submits a solution and server accepts it but it accounts the share as stale. Server MUST respond like this
Example 3 : a client submits an authorization request specifying an invalid workername. Server authorizes the account but rejects worker name. Server MUST respond like this
Using proper error codes pools may properly inform miners of the condition of their requests. Error codes MUST honor this scheme:
A notification message has the very same representation of a request with the only difference the id member MUST NOT be present. This means the issuer is not interested nor expects any response to this message. It’s up to the receiver to take actions accordingly. For instance the receiver MAY decide to execute the method, or, in case of errors or methods not allowed, drop the connection thus closing the session.
As seen above a response MAY contain an error member. When present this member MUST be an Object with:
One of the worst annoyances until now is that server, at the very moment of socket connection, does not provide any useful information about the stratum flavour implemented. This means the client has to start a conversation by iteratively trying to connect via different protocol flavours. This proposal amends the situation making mandatory for the server to advertise itself to the client.
When a new client connects to the server, the server MUST send a mining.hello notification :
If the server is prepared to start/resume a session with such requirements it MUST reply back with a response like this:
When the server replies back with "encoding" : "gzip" to the client, both parties MUST gzip compress all next messages. In case the client is not capable of compression it MUST close the connection immediately.
Should the server, after this reply, receive other messages as plain text, it MUST close the connection.
When the server replies back with "encoding" : "gzip" to the client, both parties MUST gzip compress all next messages. In case the client is not capable of compression it MUST close the connection immediately.
Should the server, after this reply, receive other messages as plain text, it MUST close the connection.
When the server replies back with "encoding" : "gzip" to the client, both parties MUST gzip compress all next messages. In case the client is not capable of compression it MUST close the connection immediately.
Should the server, after this reply, receive other messages as plain text, it MUST close the connection.
The party receiving this message aknowledges the other party wants to stop the conversation and closes the socket. The issuer will close too. The explicit issuance of this notification implies the session gets abandoned so no session resuming will be possible even on server which support session-resuming. Client reconnecting to the same server which implements session resuming SHOULD expect a new session id and MUST re-authorize all their workers.
Otherwise, if client wants to start a new session OR server does not support session resuming, the request of subscription MUST omit the params member:
A server receiving a client session subscription MUST reply back with
A server implementing session-resuming MUST cache :
This notification is meant only from servers to clients. Should a server receive such a notification it will simply ignore it. After the notification has been properly sent, the server is ALLOWED to close the connection, while the client will take the proper actions to reconnect to the suggested end-point.
The host member in params object SHOULD report an host DNS name and not an IP address: TLS encrypted connections require to validate the CN name in the certificate which, 99% of the cases, is an host name.
The third member resume of the params object sets whether or not the receiving server is prepared for session resuming.
After this notification has been issued by the server, the client should expect no further messages and MUST disconnect.
The miner MUST authorize at least one worker in order to begin receiving jobs and submit solutions or hashrates. The miner MAY authorize multiple workers in the same session. The server MUST allow authorization for multiple workers within a session and MUST validate at least one authorization from the client before starting to send jobs. A worker is a tuple of the address where rewards must be credited coupled with identifier of the machine actually doing the work. For Ethereum the most common form is <account>.<MachineName>. The same account can be bound to multiple machines. For pool’s allowing anonymous mining the account is the address where rewards must be credited, while, for pools requiring registration, the account is the login name. Each time a solution is submitted by the client it must be labelled with the Worker identifier. It’s up to server to keep the correct accounting for different addresses.
The miner MUST authorize at least one worker in order to begin receiving jobs and submit solutions or hashrates. The miner MAY authorize multiple workers in the same session. The server MUST allow authorization for multiple workers within a session and MUST validate at least one authorization from the client before starting to send jobs. A worker is a tuple of the address where rewards must be credited coupled with identifier of the machine actually doing the work. For Ethereum the most common form is <account>.<MachineName>. The same account can be bound to multiple machines. For pool’s allowing anonymous mining the account is the address where rewards must be credited, while, for pools requiring registration, the account is the login name. Each time a solution is submitted by the client it must be labelled with the Worker identifier. It’s up to server to keep the correct accounting for different addresses.
The miner MUST authorize at least one worker in order to begin receiving jobs and submit solutions or hashrates. The miner MAY authorize multiple workers in the same session. The server MUST allow authorization for multiple workers within a session and MUST validate at least one authorization from the client before starting to send jobs. A worker is a tuple of the address where rewards must be credited coupled with identifier of the machine actually doing the work. For Ethereum the most common form is <account>.<MachineName>. The same account can be bound to multiple machines. For pool’s allowing anonymous mining the account is the address where rewards must be credited, while, for pools requiring registration, the account is the login name. Each time a solution is submitted by the client it must be labelled with the Worker identifier. It’s up to server to keep the correct accounting for different addresses.
params member must be an Array of 2 string elements. For anonymous mining the “password” can be any string value or empty but not null. Pools allowing anonymous mining will simply ignore the value.
The server MUST reply back either with an error or, in case of success, with
Where the result member is a string which holds an unique - within the scope of the session - token which identifies the authorized worker. For every further request issued by the client, and related to a Worker action, the client MUST use the token given by the server in response to an mining.authorize request. This reduces the number of bytes transferred for solution and /or hashrate submission.
If client is resuming a previous session it CAN omit the authorization request for it’s workers and, in this case, MUST use the tokens assigned in the originating session. It’s up to the server to keep the correct map between tokens and workers.
The server receiving an authorization request where the credentials match previously authorized ones within the same session MUST reply back with the previously generated unique token.
If client is resuming a previous session it CAN omit the authorization request for it’s workers and, in this case, MUST use the tokens assigned in the originating session. It’s up to the server to keep the correct map between tokens and workers.
The server receiving an authorization request where the credentials match previously authorized ones within the same session MUST reply back with the previously generated unique token.
At the beginning of each session the server MUST send this notification before any mining.notify. All values passed by this notification will be valid for all NEXT jobs until a new mining.set notification overwrites them. Description of members is as follows:
Whenever the server detects that one, or two, or three or four values change within the session, the server will issue a notification with one, or two or three or four members in the param object. For this reason on each new session the server MUST pass all four members. As a consequence the miner is instructed to adapt those values on next job which gets notified.
The new algo member is defined to be prepared for possible presence of algorithm variants to ethash, namely ethash1a or ProgPow.
Pools providing multicoin switching will take care to send a new mining.set to miners before pushing any job after a switch.
The client which can’t support the data provided in the mining.set notification MAY close connection or stay idle till new values satisfy it’s configuration (see mining.noop).
All client’s implementations MUST be prepared to accept new extranonces during the session: unlike in EthereumStratum/1.0.0 the optional client advertisement mining.extranonce.subscribe is now implicit and mandatory.
Whenever the server detects that one, or two, or three or four values change within the session, the server will issue a notification with one, or two or three or four members in the param object. For this reason on each new session the server MUST pass all four members. As a consequence the miner is instructed to adapt those values on next job which gets notified.
The new algo member is defined to be prepared for possible presence of algorithm variants to ethash, namely ethash1a or ProgPow.
Pools providing multicoin switching will take care to send a new mining.set to miners before pushing any job after a switch.
The client which can’t support the data provided in the mining.set notification MAY close connection or stay idle till new values satisfy it’s configuration (see mining.noop).
All client’s implementations MUST be prepared to accept new extranonces during the session: unlike in EthereumStratum/1.0.0 the optional client advertisement mining.extranonce.subscribe is now implicit and mandatory.
The miner receiving the extranonce MUST initialize the search segment for next job resizing the extranonce to a hex of 16 bytes thus appending as many zeroes as needed.
Extranonce “af4c” means “search segment of next jobs starts from 0xaf4c000000000000”
If extranonce is valued to an empty string, or it’s never been set within the session scope, the client is free pick any starting point of it’s own search segment on subsequent mining.notify jobs.
Extranonce MUST be passed with all relevant bytes (no omission of left zeroes) for a specific reason. Assume an extranonce of “01ac” : it has the same decimal value of “1ac” but the number of bytes changes thus changing available search segment
This all said pools (server), when making use of extranonce, MUST observe a maximum length of 6 bytes (hex).
First element of params array is the jobId this solution refers to (as sent in the mining.notify message from the server). Second element is the miner nonce as hex. Third element is the token given to the worker previous mining.authorize request. Any mining.submit request bound to a worker which was not successfully authorized - i.e. the token does not exist in the session - MUST be rejected.
You’ll notice in the sample above the miner nonce is only 12 bytes wide (should be 16). Why ?
That’s because in the previous mining.set the server has set an extranonce of af4c. This means the full nonce is af4c68765fccd712
In presence of extranonce the miner MUST submit only the chars to append to the extranonce to build the final hex value. If no extranonce is set for the session or for the work the miner MUST send all 16 bytes.
You’ll notice in the sample above the miner nonce is only 12 bytes wide (should be 16). Why ?
That’s because in the previous mining.set the server has set an extranonce of af4c. This means the full nonce is af4c68765fccd712
In presence of extranonce the miner MUST submit only the chars to append to the extranonce to build the final hex value. If no extranonce is set for the session or for the work the miner MUST send all 16 bytes.
where params is an array made of two elements: the first is a hexadecimal string representation (32 bytes) of the hashrate the miner reads on it’s devices and the latter is the authorization token issued to worker this hashrate is refers to (see above for mining.authorization).
Server MUST respond back with either an aknowledgment message
https://eips.ethereum.org/EIPS/eip-1577
The field contenthash is introduced, which permits a wide range of protocols to be supported by ENS names. Resolvers supporting this field MUST return true when the supportsInterface function is called with argument 0xbc1c58d1.
The value returned by contenthash MUST be represented as a machine-readable multicodec. The format is specified as follows:
When resolving a contenthash, applications MUST use the protocol code to determine what type of address is encoded, and resolve the address appropriately for that protocol, if supported.
In order to support names that have an IPFS or Swarm hash in their content field, a grace period MUST be implemented offering those name holders time to update their names. If a resolver does not support the multihash interface, it MUST be checked whether they support the content interface. If they do, the value of that field SHOULD be treated in a context dependent fashion and resolved. This condition MUST be enforced until at least March 31st, 2019.
In order to support names that have an IPFS or Swarm hash in their content field, a grace period MUST be implemented offering those name holders time to update their names. If a resolver does not support the multihash interface, it MUST be checked whether they support the content interface. If they do, the value of that field SHOULD be treated in a context dependent fashion and resolved. This condition MUST be enforced until at least March 31st, 2019.
In order to support names that have an IPFS or Swarm hash in their content field, a grace period MUST be implemented offering those name holders time to update their names. If a resolver does not support the multihash interface, it MUST be checked whether they support the content interface. If they do, the value of that field SHOULD be treated in a context dependent fashion and resolved. This condition MUST be enforced until at least March 31st, 2019.
https://eips.ethereum.org/EIPS/eip-1616
Contracts that comply with the Attribute Registry EIP MUST implement the above interface.
As an additional requirement, the ERC-165 interface MUST be included:
The implementation MUST follow the specifications described below.
The view functions detailed below MUST be implemented.
NOTE: This function MUST return either true or false - i.e. calling this function MUST NOT cause the caller to revert. Implementations that wish to call into another contract during execution of this function MUST catch any revert and instead return false.
NOTE: This function MUST return either true or false - i.e. calling this function MUST NOT cause the caller to revert. Implementations that wish to call into another contract during execution of this function MUST catch any revert and instead return false.
NOTE: This function MUST return either true or false - i.e. calling this function MUST NOT cause the caller to revert. Implementations that wish to call into another contract during execution of this function MUST catch any revert and instead return false.
NOTE: This function MUST return two equal values when performing two directly consecutive function calls with identical account and attributeTypeID parameters, regardless of differences in the caller’s address, the transaction origin, or other out-of-band information.
NOTE: This function MUST revert if a directly preceding or subsequent function call to hasAttribute with identical account and attributeTypeID parameters would return false.
NOTE: This function MUST return two equal values when performing two directly consecutive function calls with identical account and attributeTypeID parameters, regardless of differences in the caller’s address, the transaction origin, or other out-of-band information.
NOTE: This function MUST return a positive integer value - i.e. calling this function MUST NOT cause the caller to revert.
NOTE: This function MUST return a positive integer value - i.e. calling this function MUST NOT cause the caller to revert.
NOTE: This function MUST return a value that encompasses all indexes of attribute type IDs whereby a call to hasAttribute on some address with an attribute type ID at the given index would return true.
NOTE: This function MUST revert if the provided index value falls outside of the range of the value returned from a directly preceding or subsequent function call to countAttributeTypes. It MUST NOT revert if the provided index value falls inside said range.
NOTE: This function MUST revert if the provided index value falls outside of the range of the value returned from a directly preceding or subsequent function call to countAttributeTypes. It MUST NOT revert if the provided index value falls inside said range.
NOTE: This function MUST return an attributeTypeID value on some index if the same attributeTypeID value would cause a given call to hasAttribute to return true when passed as a parameter.
https://eips.ethereum.org/EIPS/eip-1620
MUST allow senders to create multiple streams in parallel. SHOULD not accept Ether and only use ERC20-compatible tokens.
MUST allow only the recipient to perform this action.
SHOULD allow any party to do this but MUST NOT be executed without consent from all involved parties.
MUST allow any party to do this.
MUST be triggered when create is successfully called.
MUST be triggered when withdraw is successfully called.
MUST be triggered when redeem is successfully called.
MUST be triggered when confirmUpdate is successfully called.
MUST be triggered when revokeUpdate is successfully called.
MUST be triggered when an update is approved by all involved parties.
https://eips.ethereum.org/EIPS/eip-1761
Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains a localization attribute, its content may be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three attributes: uri, default and locales. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.
https://eips.ethereum.org/EIPS/eip-1767
Compatible nodes MUST provide a GraphQL endpoint available over HTTP. This SHOULD be offered on port 8547 by default. The path to the GraphQL endpoint SHOULD be ‘/graphql’.
Nodes MAY offer a superset of this schema, by adding new fields or types. Experimental or client-specific fields MUST be prefixed with ‘client’ (eg, ‘geth’ or ‘parity’). Unprefixed fields MUST be specified in a new EIP that extends this one.
Nodes MAY offer a superset of this schema, by adding new fields or types. Experimental or client-specific fields MUST be prefixed with ‘client’ (eg, ‘geth’ or ‘parity’). Unprefixed fields MUST be specified in a new EIP that extends this one.
https://eips.ethereum.org/EIPS/eip-1812
If the issuer is specified in the struct In addition to performing the standard ERC712 verification the verification code MUST also verify that the signing address is a valid veriKey delegate for the address specified in the issuer.
The EIP 712 Domain specifies what kind of message that is to be signed and is used to differentiate between signed data types. The content MUST contain the following:
https://eips.ethereum.org/EIPS/eip-1820
Below is the raw transaction which MUST be used to deploy the smart contract on any chain.
If the interface is part of an approved ERC, it MUST be named ERC###XXXXX where ### is the number of the ERC and XXXXX should be the name of the interface in CamelCase.
The meaning of this interface SHOULD be defined in the specified ERC.
NOTE: If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling updateERC165Cache with the contract address.
(See ERC165 Cache for more details.)
If a contract dynamically changes its interface and relies on the ERC-165 cache of the ERC-1820 registry, the cache MUST be updated manually—there is no automatic cache invalidation or cache update.
Ideally the contract SHOULD automatically update the cache when changing its interface.
However anyone MAY update the cache on the contract’s behalf.
The cache update MUST be done using the updateERC165Cache function:
This scheme is extensible.
You MAY make up your own interface name and raise awareness to get other people to implement it and then check for those implementations.
Have fun but please, you MUST not conflict with the reserved designations above.
NOTE: The _interfaceHash MUST NOT be an ERC-165 interface—it MUST NOT end with 28 zeroes (0).
NOTE: The _interfaceHash MUST NOT be an ERC-165 interface—it MUST NOT end with 28 zeroes (0).
Any contract being registered as the implementation of an interface for a given address MUST implement said interface.
In addition if it implements an interface on behalf of a different address, the contract MUST implement the ERC1820ImplementerInterface shown above.
Any contract being registered as the implementation of an interface for a given address MUST implement said interface.
In addition if it implements an interface on behalf of a different address, the contract MUST implement the ERC1820ImplementerInterface shown above.
If a contract implements the interface (interfaceHash) for a given address (addr), it MUST return ERC1820_ACCEPT_MAGIC when called with the addr and the interfaceHash.
If it does not implement the interfaceHash for a given address (addr), it MUST NOT return ERC1820_ACCEPT_MAGIC.
If a contract implements the interface (interfaceHash) for a given address (addr), it MUST return ERC1820_ACCEPT_MAGIC when called with the addr and the interfaceHash.
If it does not implement the interfaceHash for a given address (addr), it MUST NOT return ERC1820_ACCEPT_MAGIC.
https://eips.ethereum.org/EIPS/eip-1844
The address returned by interfaceImplementer MUST refer to a smart contract.
Resolvers implementing this interface MAY utilise a fallback strategy: If no matching interface was explicitly provided by the user, query the contract returned by addr(), returning its address if the requested interface is supported by that contract, and 0 otherwise. If they do this, they MUST ensure they return 0, rather than reverting, if the target contract reverts.
https://eips.ethereum.org/EIPS/eip-1901
JSON-RPC APIs can support the OpenRPC specification by implementing a service discovery method that will return the OpenRPC document for the JSON-RPC API. The method MUST be named rpc.discover. The rpc. prefix is a reserved method prefix for JSON-RPC 2.0 Specification system extensions.
https://eips.ethereum.org/EIPS/eip-1922
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-1923
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-1967
Beacons are used for keeping the logic address for multiple proxies in a single location, allowing the upgrade of multiple proxies by modifying a single storage slot. A beacon contract MUST implement the function:
https://eips.ethereum.org/EIPS/eip-2003
The Client is not required to provide the Host interface ([evmc_context] argument of execute() is set to NULL).
Therefore, the precompiled contracts implementation MUST NOT access the evmc_context.
https://eips.ethereum.org/EIPS/eip-2304
Resolvers MUST emit this event on each change to the address for a name and coin type.
A checksum format is specified by EIP-55, and extended by RSKIP60, which specifies a means of including the chain ID in the checksum. The checksum on a text format address must be checked. Addresses with invalid checksums that are not all uppercase or all lowercase MUST be rejected with an error. Implementations may choose whether to accept non-checksummed addresses, but the authors recommend at least providing a warning to users in this situation.
When encoding an address from binary to text, an EIP55/RSKIP60 checksum MUST be used - so the correct encoding of the above address for Ethereum is 0x314159265dD8dbb310642f98f50C066173C1259b.
If the resolver supports the addr(bytes32) interface defined in EIP137, the resolver MUST treat this as a special case of this new specification in the following ways:
https://eips.ethereum.org/EIPS/eip-2309
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL
NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and
“OPTIONAL” in this document are to be interpreted as described in
RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL
NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and
“OPTIONAL” in this document are to be interpreted as described in
RFC 2119.
The address executing the transaction MUST own all the tokens within the range of fromTokenId and toTokenId, or MUST be an approved operator to act on the owners behalf.
The address executing the transaction MUST own all the tokens within the range of fromTokenId and toTokenId, or MUST be an approved operator to act on the owners behalf.
The fromTokenId and toTokenId MUST be a consecutive range of tokens IDs.
The fromTokenId, fromAddress, and toAddress MUST be indexed parameters
The toTokenId MUST NOT be an indexed parameter
When minting/creating tokens, the fromAddress argument MUST be set to 0x0 (i.e. zero address).
When burning/destroying tokens, the toAddress argument MUST be set to 0x0 (i.e. zero address).
When emitting the ConsecutiveTransfer event the Transfer event MUST NOT be emitted
Contracts that implement the ConsecutiveTransfer event MAY still use the original Transfer event, however when emitting the ConsecutiveTransfer event the Transfer event MUST NOT be emitted.
https://eips.ethereum.org/EIPS/eip-2315
We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state. In practice, we must test at runtime for conditions 1 and 2 —- sufficient gas and sufficient stack. We don’t know how much gas there will be, we don’t know how deep a recursion may go, and analysis of stack depth even for non-recursive programs is nontrivial. All of the remaining conditions MUST be validated statically, in time and space quasi-linear in the size of the code.
https://eips.ethereum.org/EIPS/eip-2334
The path traversed through the tree of keys is defined by integers (which indicate the sibling index) separated by / which denote ancestor relations. There are 4 levels (plus the master node) in the path and at least 4 (5 including the master node) MUST be used.
The purpose is set to 12381 which is the name of the new curve (BLS12-381). In order to be in compliance with this standard, the EIP-2333 MUST be implemented as the KDF and therefore, the purpose 12381 MAY NOT be used unless this is the case.
https://eips.ethereum.org/EIPS/eip-2386
This element MUST be present. It MUST be a string following the syntactic structure as laid out in section 3 of RFC 4122.
This element MUST be present. It MUST be a string following the syntactic structure as laid out in section 3 of RFC 4122.
The name provided in the walletstore is a UTF-8 string. It is intended to serve as the user-friendly accessor. The only restriction on the name is that it MUST NOT start with the underscore (_) character.
This element MUST be present. It MUST be a string.
This element MUST be present. It MUST be a string.
This element MUST be present. It MUST be the integer 1.
This element MUST be present. It MUST be the integer 1.
This element MUST be present. It MUST be the string hierarchical deterministic.
This element MUST be present. It MUST be the string hierarchical deterministic.
This element MUST be present. It MUST be an object that follows the definition described in EIP-2335.
This element MUST be present. It MUST be an object that follows the definition described in EIP-2335.
This element MUST be present if the wallet type requires it. It MUST be a non-negative integer.
This element MUST be present if the wallet type requires it. It MUST be a non-negative integer.
https://eips.ethereum.org/EIPS/eip-2470
Below is the raw transaction which MUST be used to deploy the smart contract on any chain.
SingletonFactory does not allow sending value on create2, this was done to prevent different results on the created object.
SingletonFactory allows user defined salt to facilitate the creation of vanity addresses for other projects. If vanity address is not necessary, salt bytes(0) should be used.
Contracts that are constructed by the SingletonFactory MUST not use msg.sender in their constructor, all variables must came through initialization data. This is intentional, as if allowing a callback after creation to aid initialization state would lead to contracts with same address (but different chains) to have the same address but different initial state.
The resulting address can be calculated in chain by any contract using this formula: address(keccak256(bytes1(0xff), 0xce0042B868300000d44A59004Da54A005ffdcf9f, _salt, keccak256(_code)) << 96) or in javascript using https://github.com/ethereumjs/ethereumjs-util/blob/master/docs/README.md#const-generateaddress2.
https://eips.ethereum.org/EIPS/eip-2477
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Smart contracts implementing the ERC-2477 standard MUST implement the ERC2477 interface.
Smart contracts implementing the ERC-2477 standard MUST implement the ERC-165 standard, including the interface identifiers above.
A client implementing the ERC-2477 standard MUST support at least the sha256 hash algorithm and MAY support other algorithms.
https://eips.ethereum.org/EIPS/eip-2520
Setting and getting functions MUST have the same public interface as specified in EIP 1577. Additionally, they MUST also have new public interfaces introduced by this EIP:
Setting and getting functions MUST have the same public interface as specified in EIP 1577. Additionally, they MUST also have new public interfaces introduced by this EIP:
https://eips.ethereum.org/EIPS/eip-2535
In ALL cases any function or code that adds or replaces or removes one or more functions MUST emit the standard DiamondCut event specified below.
Any time one or more functions are added, replaced or removed the DiamondCut event MUST be emitted to record changes.
https://eips.ethereum.org/EIPS/eip-2539
This precompile performs extensive computations and in case of any errors during execution it MUST consume all gas from the the gas schedule for the corresponding operation.
https://eips.ethereum.org/EIPS/eip-2544
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
If a resolver implements this function, it MUST return true when supportsInterface() is called on it with the interface’s ID, 0xTBD.
ENS clients will call resolve with the DNS-encoded name to resolve and the encoded calldata for a resolver function (as specified in EIP-137 and elsewhere); the function MUST either return valid return data for that function, or revert if it is not supported.
EIP-2544-compliant ENS clients MUST perform the following procedure when determining the resolver for a given name:
If the procedure above returns null, name resolution MUST terminate unsuccessfully. Otherwise, EIP-2544-compliant ENS clients MUST perform the following procedure when resolving a record:
If the procedure above returns null, name resolution MUST terminate unsuccessfully. Otherwise, EIP-2544-compliant ENS clients MUST perform the following procedure when resolving a record:
https://eips.ethereum.org/EIPS/eip-2569
An EIP-2569 compatible contract MUST have a method with the signature getTokenImageSvg(uint256) view returns (string memory) and a method with the signature setTokenImageSvg(uint256 tokenId, string memory imagesvg) internal.
https://eips.ethereum.org/EIPS/eip-2678
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-2680
For other hierarchical stores, for example Amazon S3, the base location MUST be the lower-case hex string representing the SHA-256 hash of the string “Ethereum 2 wallet:” appended with the identifier for the hierarchical store. For example, if the account ID for a user’s Amazon S3 account is “AbC0438EB” then:
The wallet container is identified by the wallet’s UUID. It MUST be a string following the syntactic structure as laid out in section 3 of RFC 4122.
The walletstore element contains the walletstore and is held within the wallet container. It is identified by the wallet’s UUID. It MUST be a string following the syntactic structure as laid out in section 3 of RFC 4122.
The keystore element contains the keystore for a given key and is held within the wallet container. It is identified by the key’s UUID. It MUST be a string following the syntactic structure as laid out in section 3 of RFC 4122.
An implementer MAY include an index in the base location. If so then it MUST follow the structure as specified in the following “Index format” section.
An implementer MAY include an index within a wallet container for accounts within that wallet. If so then it MUST follow the structure as specified in the following “Index format” section.
The index MUST use the identifier ‘index’.
https://eips.ethereum.org/EIPS/eip-2696
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The Provider MUST implement implement a request method on the exposed EthereumProvider object. The request method MUST be callable with a single parameter which contains the arguments for the request as defined in the TypeScript interface above.
The Provider MUST implement implement a request method on the exposed EthereumProvider object. The request method MUST be callable with a single parameter which contains the arguments for the request as defined in the TypeScript interface above.
If the Provider supports a JSON-RPC (https://www.jsonrpc.org/specification) request as specified elsewhere, then it MUST accept a request call for that JSON-RPC method with the RequestArguments.method argument matching the JSON-RPC method string for the RPC call and the RequestArguments.params matching the params object of the RPC call. The RequestArguments.params should be encoded as a JavaScript object matching the specified JSON-RPC type, not encoded as a JSON string as would normally be the case when transporting JSON-RPC.
If the Provider supports a JSON-RPC request as specified elsewhere, then it MUST return an object that matches the expected result definition for the associated JSON-RPC request.
If the Provider is unable to fulfill a request for any reason, it MUST resolve the promise as an error. The resolved error MUST be shaped as a ProviderRpcError defined above whenever possible. While it is impossible to guaranteed that a JavaScript application will never throw an out of memory or stack overflow error, care should be taken to ensure that promise rejections conform to the above shape whenever possible.
If the Provider is unable to fulfill a request for any reason, it MUST resolve the promise as an error. The resolved error MUST be shaped as a ProviderRpcError defined above whenever possible. While it is impossible to guaranteed that a JavaScript application will never throw an out of memory or stack overflow error, care should be taken to ensure that promise rejections conform to the above shape whenever possible.
If a code is provided that is listed in the list above, or in the JSON-RPC specification (https://www.jsonrpc.org/specification#error_object), or in the associated JSON-RPC request standard being followed, then the error reason MUST align with the established meaning of that code and the message MUST match the provided message
If a code is provided that is listed in the list above, or in the JSON-RPC specification (https://www.jsonrpc.org/specification#error_object), or in the associated JSON-RPC request standard being followed, then the error reason MUST align with the established meaning of that code and the message MUST match the provided message
https://eips.ethereum.org/EIPS/eip-2700
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
If on is called with an eventName that the provider is familiar with then the provider MUST call the provided listener when the named event occurs. If the same listener is added multiple times to the same event via on, the provider MAY choose to either callback the listener one time or one time per call to on.
If removeListener is called with an eventName and listener that was previously added via on then the provider MUST decrease the number of times it calls the listener per event by one.
https://eips.ethereum.org/EIPS/eip-2711
With the advent of tokens and especially stable coins, it has become common for users to not hold ETH in an account while they may have other assets of value in that account. Some users don’t want to be exposed to the perceived volatility of ETH and instead would prefer to transact using other assets. Unfortunately, since gas MUST be paid for with ETH, this prevents the user from transacting with their assets without first acquiring some ETH using some other means, and then using that ETH to pay fees.
https://eips.ethereum.org/EIPS/eip-2718
As of FORK_BLOCK_NUMBER, the transaction root in the block header MUST be the root hash of patriciaTrie(rlp(Index) => Transaction) where:
As of FORK_BLOCK_NUMBER, the receipt root in the block header MUST be the root hash of patriciaTrie(rlp(Index) => Receipt) where:
The TransactionType of the receipt MUST match the TransactionType of the transaction with a matching Index.
https://eips.ethereum.org/EIPS/eip-2770
Request struct MUST contain the following fields in this exact order:
Registration MUST be performed in advance by a call to the following method:
https://eips.ethereum.org/EIPS/eip-2771
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.
The Trusted Forwarder is responsible for calling the Recipient contract
and MUST append the address of the Transaction Signer (20 bytes of data) to
the end of the call data.
The Recipient MUST check that it trusts the Forwarder to prevent it from
extracting address data appended from an untrusted contract. This could result
in a forged address.
To provide this discovery mechanism a Recipient contract MUST implement
this function:
Internally, the Recipient MUST then accept a request from forwarder
https://eips.ethereum.org/EIPS/eip-2786
The Provider MUST emit a connect event to all attached EIP-2700 listeners if it transitions from a disconnected state to a connected state.
All attached listeners MUST be called with the parameter { chainId }.
chainId MUST specify the integer ID of the connected chain encoded as a hexadecimal string.
If the Provider supports the eth_chainId JSON-RPC method or a derivation of it, then the chainId MUST match the return value of eth_chainId.
The Provider MAY call the attached listeners in any order.
The Provider MUST emit a connect event to all attached EIP-2700 listeners if it transitions from a disconnected state to a connected state.
All attached listeners MUST be called with the parameter { chainId }.
chainId MUST specify the integer ID of the connected chain encoded as a hexadecimal string.
If the Provider supports the eth_chainId JSON-RPC method or a derivation of it, then the chainId MUST match the return value of eth_chainId.
The Provider MAY call the attached listeners in any order.
The Provider MUST emit a connect event to all attached EIP-2700 listeners if it transitions from a disconnected state to a connected state.
All attached listeners MUST be called with the parameter { chainId }.
chainId MUST specify the integer ID of the connected chain encoded as a hexadecimal string.
If the Provider supports the eth_chainId JSON-RPC method or a derivation of it, then the chainId MUST match the return value of eth_chainId.
The Provider MAY call the attached listeners in any order.
The Provider MUST emit a connect event to all attached EIP-2700 listeners if it transitions from a disconnected state to a connected state.
All attached listeners MUST be called with the parameter { chainId }.
chainId MUST specify the integer ID of the connected chain encoded as a hexadecimal string.
If the Provider supports the eth_chainId JSON-RPC method or a derivation of it, then the chainId MUST match the return value of eth_chainId.
The Provider MAY call the attached listeners in any order.
https://eips.ethereum.org/EIPS/eip-2831
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
These methods MUST be implemented per the Node.js EventEmitter API.
https://eips.ethereum.org/EIPS/eip-2848
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 when, and only when, they appear in all capitals as shown here.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 when, and only when, they appear in all capitals as shown here.
Clients following MOM standard MUST allow users to send and to read MOM transaction, creating an updated message list for each address the users are interested in.
Reading MOM transactions, MOM clients MUST be able to show the current and updated message list, and they SHOULD be able to show also all the message history if users ask for it.
Clients SHOULD allow users to choose and set the source to download content from, and they SHOULD be able to use common Content Addressable Networks - i.e. IPFS or Swarm - or HTTP servers. If content is downloaded from HTTP servers, clients MUST check the content against the declared multihash.
As the default setting, clients MUST consider text/markdown (RFC 7763) as the media type of the content represented by a multihash, and in particular Markdown text in UTF-8 without BOM.
Clients MUST assume that invalid MOM transactions don’t exist. If a transaction does not strictly follow the MOM standard, clients MUST ignore it and they MUST NOT consider it a MOM transaction at all.
Clients MUST assume that invalid MOM transactions don’t exist. If a transaction does not strictly follow the MOM standard, clients MUST ignore it and they MUST NOT consider it a MOM transaction at all.
Clients MUST assume that invalid MOM transactions don’t exist. If a transaction does not strictly follow the MOM standard, clients MUST ignore it and they MUST NOT consider it a MOM transaction at all.
Each operational code has one or more parameters, and all parameters MUST be considered mandatory.
Optional parameters don’t exist: if parameters for the specific operational code are not all present or they don’t follow the rules, clients MUST ignore the transaction completely.
Messages MUST be always referenced with the multihash of their content.
Please note that sending a DELETE command users are not asking to actually delete anything from the blockchain, they are just asking clients to hide that specific message because it’s not valid anymore for some reasons. You can think of it like if users say: I changed my mind so please ÐApps don’t show this anymore. As already stated in the specifications above, clients MUST follow this request by the author, unless expressly asked otherwise by the user.
https://eips.ethereum.org/EIPS/eip-2976
Typed Transactions can be sent over devp2p as TransactionType || TransactionPayload.
The exact contents of the TransactionPayload are defined by the TransactionType in future EIPs, and clients may start supporting their gossip without incrementing the devp2p version.
If a client receives a TransactionType that it doesn’t recognize, it SHOULD disconnect from the peer who sent it.
Clients MUST NOT send new transaction types before they believe the fork block is reached.
Clients MUST NOT send transactions of a new TransactionType until that transaction type’s introductory fork block.
https://eips.ethereum.org/EIPS/eip-2980
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Every ERC-2980 compliant contract MUST implement the ERC-2980 interface.
The ERC-2980 extends ERC-20. Due to the indivisible nature of asset tokens, the decimals number MUST be zero.
Revoke and Reassign methods allow Issuers to move tokens from addresses, even if they are in the Frozenlist. The Revoke method transfers the entire balance of the target address to the Issuer who invoked the method. The Reassign method transfers the entire balance of the target address to another address. These rights for these operations MUST be allowed only to Issuers.
This EIP does not introduce backward incompatibilities and is backward compatible with the older ERC-20 token standard.
This standard allows the implementation of ERC-20 functions transfer, transferFrom, approve and allowance alongside to make a token fully compatible with ERC-20.
The token MAY implement decimals() for backward compatibility with ERC-20. If implemented, it MUST always return 0.
https://eips.ethereum.org/EIPS/eip-2981
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL
NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and
“OPTIONAL” in this document are to be interpreted as described in
RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL
NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and
“OPTIONAL” in this document are to be interpreted as described in
RFC 2119.
Marketplaces MUST pay the royalty in the same unit of exchange as that of the _salePrice passed to royaltyInfo(). This is equivalent to saying that the _salePrice parameter and the royaltyAmount return value MUST be denominated in the same monetary unit. For example, if the sale price is in ETH, then the royalty payment must also be paid in ETH, and if the sale price is in USDC, then the royalty payment must also be paid in USDC.
Marketplaces MUST pay the royalty in the same unit of exchange as that of the _salePrice passed to royaltyInfo(). This is equivalent to saying that the _salePrice parameter and the royaltyAmount return value MUST be denominated in the same monetary unit. For example, if the sale price is in ETH, then the royalty payment must also be paid in ETH, and if the sale price is in USDC, then the royalty payment must also be paid in USDC.
Implementers of this standard MUST calculate a percentage of the _salePrice when calculating the royalty amount. Subsequent invocations of royaltyInfo() MAY return a different royaltyAmount. Though there are some important considerations for implementers if they choose to perform different percentage calculations between royaltyInfo() invocations.
The royaltyInfo() function is not aware of the unit of exchange for the sale and royalty payment. With that in mind, implementers MUST NOT return a fixed/constant royaltyAmount, wherein they’re ignoring the _salePrice. For the same reason, implementers MUST NOT determine the royaltyAmount based on comparing the _salePrice with constant numbers. In both cases, the royaltyInfo() function makes assumptions on the unit of exchange, which MUST be avoided.
The royaltyInfo() function is not aware of the unit of exchange for the sale and royalty payment. With that in mind, implementers MUST NOT return a fixed/constant royaltyAmount, wherein they’re ignoring the _salePrice. For the same reason, implementers MUST NOT determine the royaltyAmount based on comparing the _salePrice with constant numbers. In both cases, the royaltyInfo() function makes assumptions on the unit of exchange, which MUST be avoided.
The royaltyInfo() function is not aware of the unit of exchange for the sale and royalty payment. With that in mind, implementers MUST NOT return a fixed/constant royaltyAmount, wherein they’re ignoring the _salePrice. For the same reason, implementers MUST NOT determine the royaltyAmount based on comparing the _salePrice with constant numbers. In both cases, the royaltyInfo() function makes assumptions on the unit of exchange, which MUST be avoided.
The percentage value used must be independent of the sale price for reasons previously mentioned (i.e. if the percentage value 10%, then 10% MUST apply whether _salePrice is 10, 10000 or 1234567890). If the royalty fee calculation results in a remainder, implementers MAY round up or round down to the nearest integer. For example, if the royalty fee is 10% and _salePrice is 999, the implementer can return either 99 or 100 for royaltyAmount, both are valid.
Marketplaces that support this standard MUST pay royalties no matter where the sale occurred or in what currency, including on-chain sales, over-the-counter (OTC) sales and off-chain sales such as at auction houses. As royalty payments are voluntary, entities that respect this EIP must pay no matter where the sale occurred - a sale conducted outside of the blockchain is still a sale. The exact mechanism for paying and notifying the recipient will be defined in future EIPs.
Implementers of this standard MUST have all of the following functions:
https://eips.ethereum.org/EIPS/eip-3005
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST (BUT WE KNOW YOU WON’T)”, “SHOULD CONSIDER”, “REALLY SHOULD NOT”, “OUGHT TO”, “WOULD PROBABLY”, “MAY WISH TO”, “COULD”, “POSSIBLE”, and “MIGHT” in this document are to be interpreted as described in RFC 6919.
In order to successfully validate and transfer tokens, the processMetaBatch() function MUST process the following data about a meta transaction:
The processMetaBatch() function MUST receive the following data:
The created hash MUST then be signed with the sender’s private key.
The processMetaBatch() function MUST have the following interface:
Each entry in each of the arrays MUST represent data from one meta transaction. The order of the data is very important. Data from a single meta transaction MUST have the same index in every array.
Each entry in each of the arrays MUST represent data from one meta transaction. The order of the data is very important. Data from a single meta transaction MUST have the same index in every array.
After a meta transaction is successfully validated, the meta nonce of the meta transaction sender MUST be increased by 1.
Then two token transfers MUST occur:
https://eips.ethereum.org/EIPS/eip-3026
The base field element (Fp) is encoded as 96 bytes by performing BigEndian encoding of the corresponding (unsigned) integer. The corresponding integer MUST be less than the base field modulus.
If encodings do not follow this spec anywhere during parsing in the precompile, the precompile MUST revert with “endoding error”.
This precompile performs extensive computations and in case of any errors during execution it MUST consume all gas from the the gas schedule for the corresponding operation.
https://eips.ethereum.org/EIPS/eip-3041
Returns information about a block specified by hash.
Every block returned by this endpoint whose block number is before the EIP-1559 fork block MUST NOT include a baseFee field.
Every block returned by this endpoint whose block number is on or after the EIP-1559 fork block MUST include a baseFee field.
Returns information about a block specified by hash.
Every block returned by this endpoint whose block number is before the EIP-1559 fork block MUST NOT include a baseFee field.
Every block returned by this endpoint whose block number is on or after the EIP-1559 fork block MUST include a baseFee field.
https://eips.ethereum.org/EIPS/eip-3044
Returns information about a block specified by number.
Every block returned by this endpoint whose block number is before the EIP-1559 fork block MUST NOT include a baseFee field.
Every block returned by this endpoint whose block number is on or after the EIP-1559 fork block MUST include a baseFee field.
Returns information about a block specified by number.
Every block returned by this endpoint whose block number is before the EIP-1559 fork block MUST NOT include a baseFee field.
Every block returned by this endpoint whose block number is on or after the EIP-1559 fork block MUST include a baseFee field.
https://eips.ethereum.org/EIPS/eip-3045
Returns information about an uncle specified by block hash and uncle index position
Every block returned by this endpoint whose block number is before the EIP-1559 fork block MUST NOT include a baseFee field.
Every block returned by this endpoint whose block number is on or after the EIP-1559 fork block MUST include a baseFee field.
Returns information about an uncle specified by block hash and uncle index position
Every block returned by this endpoint whose block number is before the EIP-1559 fork block MUST NOT include a baseFee field.
Every block returned by this endpoint whose block number is on or after the EIP-1559 fork block MUST include a baseFee field.
https://eips.ethereum.org/EIPS/eip-3046
Returns information about an uncle specified by block number and uncle index position
Every block returned by this endpoint whose block number is before the EIP-1559 fork block MUST NOT include a baseFee field.
Every block returned by this endpoint whose block number is on or after the EIP-1559 fork block MUST include a baseFee field.
Returns information about an uncle specified by block number and uncle index position
Every block returned by this endpoint whose block number is before the EIP-1559 fork block MUST NOT include a baseFee field.
Every block returned by this endpoint whose block number is on or after the EIP-1559 fork block MUST include a baseFee field.
https://eips.ethereum.org/EIPS/eip-3074
An important note is that invoker contracts MUST NOT be upgradeable. If an invoker can be redeployed to the same address with different code, it would be possible to redeploy the invoker with code that does not properly verify commit and any account that signed a message over that invoker would be compromised. Although this sounds scary, it is no different than using a smart contract wallet via DELEGATECALL. If the wallet is redeployed with different logic, all wallets using its code could be compromised.
https://eips.ethereum.org/EIPS/eip-3085
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
Only the chainId is required per this specification, but a wallet MAY require any other fields listed, impose additional requirements on them, or ignore them outright.
If a field does not meet the requirements of this specification and the wallet does not ignore the field, the wallet MUST reject the request.
All URL strings MUST include the protocol component of the URL.
HTTPS SHOULD always be used over HTTP.
The method MUST return null if the request was successful, and an error otherwise.
The wallet MUST NOT allow the same chainId to be added multiple times.
See Security Considerations for more information.
https://eips.ethereum.org/EIPS/eip-3155
The CUT MUST output a json object for EACH operation.
The stack, memory and memSize are the values before execution of the op.
All array attributes (stack, returnStack, memory) MUST be initialized to empty arrays (“stack”:[],) NOT to null.
If the CUT will not output values for memory or storage then the memory and storage fields are omitted.
This can happen either because the CUT does not support tracing these fields or it has been configured not to trace it.
The memSize field MUST be present regardless of memory support.
Clients SHOULD implement a way to disable recording the storage as the stateroot includes all storage updates.
Clients SHOULD output the fields in the same order as listed in this EIP.
The stack, memory and memSize are the values before execution of the op.
All array attributes (stack, returnStack, memory) MUST be initialized to empty arrays (“stack”:[],) NOT to null.
If the CUT will not output values for memory or storage then the memory and storage fields are omitted.
This can happen either because the CUT does not support tracing these fields or it has been configured not to trace it.
The memSize field MUST be present regardless of memory support.
Clients SHOULD implement a way to disable recording the storage as the stateroot includes all storage updates.
Clients SHOULD output the fields in the same order as listed in this EIP.
The CUT MUST NOT output a line for the STOP operation if an error occurred:
Example:
At the end of execution, the CUT MUST print some summerical info, this info SHOULD have the following fields.
The summary should be a single jsonl object.
https://eips.ethereum.org/EIPS/eip-3156
A lender MUST implement the IERC3156FlashLender interface.
The maxFlashLoan function MUST return the maximum loan possible for token. If a token is not currently supported maxFlashLoan MUST return 0, instead of reverting.
The maxFlashLoan function MUST return the maximum loan possible for token. If a token is not currently supported maxFlashLoan MUST return 0, instead of reverting.
The flashFee function MUST return the fee charged for a loan of amount token. If the token is not supported flashFee MUST revert.
The flashFee function MUST return the fee charged for a loan of amount token. If the token is not supported flashFee MUST revert.
The flashLoan function MUST include a callback to the onFlashLoan function in a IERC3156FlashBorrower contract.
The flashLoan function MUST transfer amount of token to receiver before the callback to the receiver.
The flashLoan function MUST include msg.sender as the initiator to onFlashLoan.
The flashLoan function MUST NOT modify the token, amount and data parameter received, and MUST pass them on to onFlashLoan.
The flashLoan function MUST NOT modify the token, amount and data parameter received, and MUST pass them on to onFlashLoan.
The flashLoan function MUST include a fee argument to onFlashLoan with the fee to pay for the loan on top of the principal, ensuring that fee == flashFee(token, amount).
The lender MUST verify that the onFlashLoan callback returns the keccak256 hash of “ERC3156FlashBorrower.onFlashLoan”.
After the callback, the flashLoan function MUST take the amount + fee token from the receiver, or revert if this is not successful.
If successful, flashLoan MUST return true.
A receiver of flash loans MUST implement the IERC3156FlashBorrower interface:
For the transaction to not revert, receiver MUST approve amount + fee of token to be taken by msg.sender before the end of onFlashLoan.
If successful, onFlashLoan MUST return the keccak256 hash of “ERC3156FlashBorrower.onFlashLoan”.
https://eips.ethereum.org/EIPS/eip-3234
A lender MUST implement the IERC3234BatchFlashLender interface.
The maxFlashLoan function MUST return the maximum loan possible for each token. If a token is not currently supported maxFlashLoan MUST return 0, instead of reverting.
The maxFlashLoan function MUST return the maximum loan possible for each token. If a token is not currently supported maxFlashLoan MUST return 0, instead of reverting.
The flashFee function MUST return the fees charged for each loan of amount token. If a token is not supported flashFee MUST revert.
The flashFee function MUST return the fees charged for each loan of amount token. If a token is not supported flashFee MUST revert.
The batchFlashLoan function MUST include a callback to the onBatchFlashLoan function in a IERC3234BatchFlashBorrower contract.
The batchFlashLoan function MUST transfer amounts[i] of each tokens[i] to receiver before the callback to the borrower.
The batchFlashLoan function MUST include msg.sender as the initiator to onBatchFlashLoan.
The batchFlashLoan function MUST NOT modify the tokens, amounts and data parameters received, and MUST pass them on to onBatchFlashLoan.
The batchFlashLoan function MUST NOT modify the tokens, amounts and data parameters received, and MUST pass them on to onBatchFlashLoan.
The lender MUST verify that the onBatchFlashLoan callback returns the keccak256 hash of “ERC3234BatchFlashBorrower.onBatchFlashLoan”.
The batchFlashLoan function MUST include a fees argument to onBatchFlashLoan with the fee to pay for each individual token and amount lent, ensuring that fees[i] == flashFee(tokens[i], amounts[i]).
After the callback, for each token in tokens, the batchFlashLoan function MUST take the amounts[i] + fees[i] of tokens[i] from the receiver, or revert if this is not successful.
If successful, batchFlashLoan MUST return true.
A receiver of flash loans MUST implement the IERC3234BatchFlashBorrower interface:
For the transaction to not revert, for each token in tokens, receiver MUST approve amounts[i] + fees[i] of tokens[i] to be taken by msg.sender before the end of onBatchFlashLoan.
If successful, onBatchFlashLoan MUST return the keccak256 hash of “ERC3156BatchFlashBorrower.onBatchFlashLoan”.
https://eips.ethereum.org/EIPS/eip-3326
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC-2119.
If a field does not meet the requirements of this specification, the wallet MUST reject the request.
The method MUST return null if the request was successful, and an error otherwise.
If the wallet does not have a concept of an active chain, the wallet MUST reject the request.
https://eips.ethereum.org/EIPS/eip-3382
As of FORK_BLOCK_NUMBER, the header.gasLimit MUST be equal to BLOCK_GAS_LIMIT, where BLOCK_GAS_LIMIT is a hardcoded constant set to 12,500,000.
https://eips.ethereum.org/EIPS/eip-3386
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Minting requires the transfer of the {Base} tokens into the {Pool} in exchange for {Derivative} tokens. The {Base} tokens deposited in this way MUST NOT be transferred again except through the burning functions. This ensures the value of the {Derivative} tokens is representative of the value of the {Base} tokens.
Prices should not be necessarily fixed. therefore, Mint/Burn events MUST include the ERC-20 _value minted/burned.
Due to the variety of pricing implementations, the Mint* and Burn* events MUST include the number {Derivative} tokens minted/burned.
The {Wrapper} MAY inherit from {ERC20}, in order to directly call super.mint and super.burn.
If the {Wrapper} does not inherit from {ERC20}, the {Derivative} contract MUST be limited such that the {Wrapper} has the sole power to mint, burn, and otherwise change the supply of tokens.
If not inheriting from {ERC721Receiver} and/or {ERC1155Receiver}, the pool MUST be limited such that the base tokens can only be transferred via the Wrapper’s mint, burn.
If the {Wrapper} does not inherit from {ERC721} or {ERC1155}, it MUST include calls to {IERC721} and {IERC1155} in order to transfer {Base} tokens.
All of the underlying transfer methods are not tied to the {Wrapper}, but rather call the ERC-20/721/1155 transfer methods. Implementations of this standard MUST:
Wrapper contracts are RECOMMENDED to inherit from burnable ERC-20 tokens. If they are not, the supply of the {Derivative} tokens MUST be controlled by the Wrapper. Similarly, price implementations MUST ensure that the supply of {Base} tokens is reflected by the {Derivative} tokens.
Wrapper contracts are RECOMMENDED to inherit from burnable ERC-20 tokens. If they are not, the supply of the {Derivative} tokens MUST be controlled by the Wrapper. Similarly, price implementations MUST ensure that the supply of {Base} tokens is reflected by the {Derivative} tokens.
https://eips.ethereum.org/EIPS/eip-3440
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Implementations of ERC-3440 MUST designate which token Id is the original NFT (defaulted to Id 0), and which token Id is a unique replica. The original print SHOULD be token Id number 0 but MAY be assigned to a different Id. The original print MUST only be designated once. The implementation MUST designate a maximum number of minted editions, after which new Ids MUST NOT be printed / minted.
Implementations of ERC-3440 MUST designate which token Id is the original NFT (defaulted to Id 0), and which token Id is a unique replica. The original print SHOULD be token Id number 0 but MAY be assigned to a different Id. The original print MUST only be designated once. The implementation MUST designate a maximum number of minted editions, after which new Ids MUST NOT be printed / minted.
Implementations of ERC-3440 MUST designate which token Id is the original NFT (defaulted to Id 0), and which token Id is a unique replica. The original print SHOULD be token Id number 0 but MAY be assigned to a different Id. The original print MUST only be designated once. The implementation MUST designate a maximum number of minted editions, after which new Ids MUST NOT be printed / minted.
Implementations of ERC-3440 MUST designate which token Id is the original NFT (defaulted to Id 0), and which token Id is a unique replica. The original print SHOULD be token Id number 0 but MAY be assigned to a different Id. The original print MUST only be designated once. The implementation MUST designate a maximum number of minted editions, after which new Ids MUST NOT be printed / minted.
Signature messages MUST use the EIP-712 standard.
https://eips.ethereum.org/EIPS/eip-3475
To ensure the indexing of transactions throughout the bond lifecycle (i.e “Issue”, “Redeem” and “Transfer” functions), events cited in specification section MUST be emitted when such transaction is passed.
https://eips.ethereum.org/EIPS/eip-3525
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-3569
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The sealed metadata JSON file MAY contain metadata for many different tokens. The top level keys of the JSON object MUST be token IDs.
https://eips.ethereum.org/EIPS/eip-3589
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
mint and safeMint assemble assets into one ERC-721 token. mint SHOULD be implemented for normal ERC-20 tokens whose _transfer is lossless. safeMint MUST takes care for lossy token such as PIG token whose _transfer function is taxed.
_salt of hash function MAY be implemented other way, even provided as user input. But the token id MUST be generated by hash function.
Implementers of this standard MUST have all of the following functions:
https://eips.ethereum.org/EIPS/eip-3607
Any transaction where tx.sender has a CODEHASH != EMPTYCODEHASH MUST be rejected as invalid, where EMPTYCODEHASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470.
The invalid transaction MUST be rejected by the client and not be included in a block.
A block containing such a transaction MUST be considered invalid.
Any transaction where tx.sender has a CODEHASH != EMPTYCODEHASH MUST be rejected as invalid, where EMPTYCODEHASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470.
The invalid transaction MUST be rejected by the client and not be included in a block.
A block containing such a transaction MUST be considered invalid.
Any transaction where tx.sender has a CODEHASH != EMPTYCODEHASH MUST be rejected as invalid, where EMPTYCODEHASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470.
The invalid transaction MUST be rejected by the client and not be included in a block.
A block containing such a transaction MUST be considered invalid.
https://eips.ethereum.org/EIPS/eip-3668
A CCIP read enabled contract MUST revert with the following error whenever a function that requires offchain data is called:
urls specifies a list of URL templates to services (known as gateways) that implement the CCIP read protocol and can formulate an answer to the query. urls can be the empty list [], in which case the client MUST specify the URL template. The order in which URLs are tried is up to the client, but contracts SHOULD return them in order of priority, with the most important entry first.
extraData is additional data that is required by the callback, and MUST be retained by the client and provided unmodified to the callback function. This value is opaque to the client.
The contract MUST also implement a callback method for decoding and validating the data returned by the gateway. The name of this method is implementation-specific, but it MUST have the signature (bytes response, bytes extraData), and MUST have the same return type as the function that reverted with OffchainLookup.
The contract MUST also implement a callback method for decoding and validating the data returned by the gateway. The name of this method is implementation-specific, but it MUST have the signature (bytes response, bytes extraData), and MUST have the same return type as the function that reverted with OffchainLookup.
The contract MUST also implement a callback method for decoding and validating the data returned by the gateway. The name of this method is implementation-specific, but it MUST have the signature (bytes response, bytes extraData), and MUST have the same return type as the function that reverted with OffchainLookup.
When a CCIP-aware contract wishes to make a call to another contract, and the possibility exists that the callee may implement CCIP read, the calling contract MUST catch all OffchainLookup errors thrown by the callee, and revert with a different error if the sender field of the error does not match the callee address.
Where the possibility exists that a callee implements CCIP read, a CCIP-aware contract MUST NOT allow the default solidity behaviour of bubbling up reverts from nested calls. This is to prevent the following situation:
If the URL template contains the {data} substitution parameter, the client MUST send a GET request after replacing the substitution parameters as described above.
If the URL template does not contain the {data} substitution parameter, the client MUST send a POST request after replacing the substitution parameters as described above. The POST request MUST be sent with a Content-Type of application/json, and a payload matching the following schema:
If the URL template does not contain the {data} substitution parameter, the client MUST send a POST request after replacing the substitution parameters as described above. The POST request MUST be sent with a Content-Type of application/json, and a payload matching the following schema:
Compliant gateways MUST respond with a Content-Type of application/json, with the body adhering to the following JSON schema:
Unsuccessful requests MUST return the appropriate HTTP status code - for example, 404 if the sender address is not supported by this gateway, 400 if the callData is in an invalid format, 500 if the server encountered an internal error, and so forth. If the Content-Type of a 4xx or 5xx response is application/json, it MUST adhere to the following JSON schema:
Unsuccessful requests MUST return the appropriate HTTP status code - for example, 404 if the sender address is not supported by this gateway, 400 if the callData is in an invalid format, 500 if the server encountered an internal error, and so forth. If the Content-Type of a 4xx or 5xx response is application/json, it MUST adhere to the following JSON schema:
Clients MUST support both GET and POST requests. Gateways may implement either or both as needed.
A client that supports CCIP read MUST make contract calls using the following process:
Clients MUST handle HTTP status codes appropriately, employing best practices for error reporting and retries.
Clients MUST handle HTTP 4xx and 5xx error responses that have a content type other than application/json appropriately; they MUST NOT attempt to parse the response body as JSON.
Clients MUST handle HTTP 4xx and 5xx error responses that have a content type other than application/json appropriately; they MUST NOT attempt to parse the response body as JSON.
This protocol can result in multiple lookups being requested by the same contract. Clients MUST implement a limit on the number of lookups they permit for a single contract call, and this limit SHOULD be at least 4.
In order to prevent a malicious gateway from causing unintended side-effects or faulty results, contracts MUST include sufficient information in the extraData argument to allow them to verify the relevance and validity of the gateway’s response. For example, if the contract is requesting information based on an address supplied to the original call, it MUST include that address in the extraData so that the callback can verify the gateway is not providing the answer to a different query.
In order to prevent a malicious gateway from causing unintended side-effects or faulty results, contracts MUST include sufficient information in the extraData argument to allow them to verify the relevance and validity of the gateway’s response. For example, if the contract is requesting information based on an address supplied to the original call, it MUST include that address in the extraData so that the callback can verify the gateway is not providing the answer to a different query.
In order to prevent a malicious client from causing unintended effects when making transactions using CCIP read, contracts MUST implement appropriate checks on the extraData returned to them in the callback. Any sanity/permission checks performed on input data for the initial call MUST be repeated on the data passed through the extraData field in the callback. For example, if a transaction should only be executable by an authorised account, that authorisation check MUST be done in the callback; it is not sufficient to perform it with the initial call and embed the authorised address in the extraData.
In order to prevent a malicious client from causing unintended effects when making transactions using CCIP read, contracts MUST implement appropriate checks on the extraData returned to them in the callback. Any sanity/permission checks performed on input data for the initial call MUST be repeated on the data passed through the extraData field in the callback. For example, if a transaction should only be executable by an authorised account, that authorisation check MUST be done in the callback; it is not sufficient to perform it with the initial call and embed the authorised address in the extraData.
In order to prevent a malicious client from causing unintended effects when making transactions using CCIP read, contracts MUST implement appropriate checks on the extraData returned to them in the callback. Any sanity/permission checks performed on input data for the initial call MUST be repeated on the data passed through the extraData field in the callback. For example, if a transaction should only be executable by an authorised account, that authorisation check MUST be done in the callback; it is not sufficient to perform it with the initial call and embed the authorised address in the extraData.
https://eips.ethereum.org/EIPS/eip-3670
This feature is introduced on the very same block EIP-3540 is enabled, therefore every EOF1-compatible bytecode MUST be validated according to these rules.
https://eips.ethereum.org/EIPS/eip-3675
Events having the POS_ prefix in the name (PoS events) are emitted by the new proof-of-stake consensus mechanism. They signify the corresponding assertion that has been made regarding a block specified by the event. The underlying logic of PoS events can be found in the beacon chain specification. On the occurrence of each PoS event the corresponding action that is specified by this EIP MUST be taken.
The following set of parameters is a part of client software configuration and MUST be included into its binary distribution:
Note: If TERMINAL_BLOCK_HASH is stubbed with 0x0000000000000000000000000000000000000000000000000000000000000000 then TERMINAL_BLOCK_HASH and TERMINAL_BLOCK_NUMBER parameters MUST NOT take an effect.
PoW blocks that are descendants of any terminal PoW block MUST NOT be imported. This implies that a terminal PoW block will be the last PoW block in the canonical chain.
Beginning with TRANSITION_BLOCK, a number of previously dynamic block fields are deprecated by enforcing these values to instead be constants. Each block field listed in the table below MUST be replaced with the corresponding constant value.
Beginning with TRANSITION_BLOCK, the validation of the block’s extraData field changes: The length of the block’s extraData MUST be less than or equal to MAX_EXTRA_DATA_BYTES bytes.
Note: Logic and validity conditions of block fields that are not specified here MUST remain unchanged. Additionally, the overall block format MUST remain unchanged.
Note: Logic and validity conditions of block fields that are not specified here MUST remain unchanged. Additionally, the overall block format MUST remain unchanged.
Beginning with TRANSITION_BLOCK, the block validity conditions MUST be altered by the following:
Note: If one of the new rules fails then the block MUST be invalidated.
Note: Validity rules that are not specified in the list above MUST remain unchanged.
In addition to satisfying the above conditions, TRANSITION_BLOCK MUST be a child of a terminal PoW block. That is, a parent of TRANSITION_BLOCK MUST satisfy terminal PoW block conditions.
In addition to satisfying the above conditions, TRANSITION_BLOCK MUST be a child of a terminal PoW block. That is, a parent of TRANSITION_BLOCK MUST satisfy terminal PoW block conditions.
Beginning with TRANSITION_BLOCK, block and ommer rewards are deprecated. Specifically, the following actions MUST be taken:
Note: Transaction fee mechanics affecting the block’s beneficiary account MUST remain unchanged.
As of the first POS_FORKCHOICE_UPDATED event, the fork choice rule MUST be altered in the following way:
The new PoS LMD-GHOST fork choice rule is specified as follows. On each occurrence of a POS_FORKCHOICE_UPDATED event including the first one, the following actions MUST be taken:
Changes to the block tree store that are related to the above actions MUST be applied atomically.
Note: This rule MUST be strictly enforced. “Optimistic” updates to the head MUST NOT be made. That is – if a new block is processed on top of the current head block, this new block becomes the new head if and only if an accompanying POS_FORKCHOICE_UPDATED event occurs.
Note: This rule MUST be strictly enforced. “Optimistic” updates to the head MUST NOT be made. That is – if a new block is processed on top of the current head block, this new block becomes the new head if and only if an accompanying POS_FORKCHOICE_UPDATED event occurs.
For the purposes of the EIP-2124 fork identifier, nodes implementing this EIP MUST set the FORK_NEXT parameter to the FORK_NEXT_VALUE.
Beginning with receiving the FIRST_FINALIZED_BLOCK, the networking stack MUST discard the following ingress messages:
Beginning with receiving the finalized block next to the FIRST_FINALIZED_BLOCK, the networking stack MUST remove the handlers corresponding to the following messages:
Note: The logic of message handlers that are not affected by this section MUST remain unchanged.
https://eips.ethereum.org/EIPS/eip-3690
This feature is introduced on the very same block EIP-3540 is enabled, therefore every EOF1-compatible bytecode MUST have a JUMPDEST-table if it uses jumps.
https://eips.ethereum.org/EIPS/eip-3770
shortName is mandatory and MUST be a valid short name from ethereum-lists/chains
address is mandatory and MUST be a EIP-55 compatible hexadecimal address
https://eips.ethereum.org/EIPS/eip-4337
eth_sendUserOperation submits a User Operation object to the User Operation pool of the client. An entryPoint address MUST be specified, and the client MUST only simulate and submit the User Operation through the specified entryPoint.
eth_sendUserOperation submits a User Operation object to the User Operation pool of the client. An entryPoint address MUST be specified, and the client MUST only simulate and submit the User Operation through the specified entryPoint.
https://eips.ethereum.org/EIPS/eip-4361
The message MUST conform with the following Augmented Backus–Naur Form (ABNF, RFC 5234) expression (note that %s denotes case sensitivity for a string term, as per RFC 7405).
https://eips.ethereum.org/EIPS/eip-4393
Smart contracts implementing this EIP standard MUST implement all of the functions in this EIP interface. MUST also emit the events specified in the interface so that a complete state of the tip token contract can be derived from the events emitted alone.
Smart contracts implementing this EIP standard MUST implement all of the functions in this EIP interface. MUST also emit the events specified in the interface so that a complete state of the tip token contract can be derived from the events emitted alone.
Smart contracts implementing this EIP standard MUST implement the ERC-165 supportsInterface function and MUST return the constant value true if 0xE47A7022 is passed through the interfaceID argument. Note that revert in this document MAY mean a require, throw (not recommended as depreciated) or revert solidity statement with or without error messages.
Smart contracts implementing this EIP standard MUST implement the ERC-165 supportsInterface function and MUST return the constant value true if 0xE47A7022 is passed through the interfaceID argument. Note that revert in this document MAY mean a require, throw (not recommended as depreciated) or revert solidity statement with or without error messages.
Whenever a user sends a tip, an equivalent value of deposited ERC-20 MUST be transferred to a pending account for the NFT or multi token holder, and the tip tokens sent MUST be burnt. This equivalent value is calculated using a simple formula:
Whenever a user sends a tip, an equivalent value of deposited ERC-20 MUST be transferred to a pending account for the NFT or multi token holder, and the tip tokens sent MUST be burnt. This equivalent value is calculated using a simple formula:
If not inheriting from ERC-20, then minting the tip tokens MUST emit event Transfer(address indexed from, address indexed to, uint256 value) where sender is the zero address for a mint and to is the zero address for a burn. The Transfer event MUST be the same signature as the Transfer function in the IERC20 interface.
If not inheriting from ERC-20, then minting the tip tokens MUST emit event Transfer(address indexed from, address indexed to, uint256 value) where sender is the zero address for a mint and to is the zero address for a burn. The Transfer event MUST be the same signature as the Transfer function in the IERC20 interface.
To keep the ITipToken interface simple and general purpose, each tip token contract MUST use one ERC-20 compatible deposit type at a time. If tipping is required to support many ERC-20 deposits then each tip token contract MUST be deployed separately per ERC-20 compatible type required. Thus, if tipping is required from both ETH and BTC wrapper ERC-20 deposits then the tip token contract is deployed twice. The tip token contract’s constructor is REQUIRED to pass in the address of the ERC-20 token supported for the deposits for the particular tip token contract. Or in the case for upgradeable tip token contracts, an initialize method is REQUIRED to pass in the ERC-20 token address.
To keep the ITipToken interface simple and general purpose, each tip token contract MUST use one ERC-20 compatible deposit type at a time. If tipping is required to support many ERC-20 deposits then each tip token contract MUST be deployed separately per ERC-20 compatible type required. Thus, if tipping is required from both ETH and BTC wrapper ERC-20 deposits then the tip token contract is deployed twice. The tip token contract’s constructor is REQUIRED to pass in the address of the ERC-20 token supported for the deposits for the particular tip token contract. Or in the case for upgradeable tip token contracts, an initialize method is REQUIRED to pass in the ERC-20 token address.
This EIP does not provide details for where the ERC-20 reward deposits are held. It MUST be available at the time a holder withdraws the rewards that they are owed. A RECOMMENDED implementation would be to keep the deposits locked in the tip token contract address. By keeping a mapping structure that records the balances pending to holders then the
deposits can remain where they are when a user tips, and only transferred out to a holder’s address when a holder withdraws it as their reward.
Clever ways to minimise on-chain state updating of the deposit balances for each user and the reward balances of each holder, can help further to minimise the gas costs when sending in a batch if the batch is ordered beforehand. For example, can avoid the checks if the next NFT in the batch is the same. This left to the tip token contract implementer. Whatever optimisation is applied, it MUST still allow information of which account tipped which account and for what NFT to be reconstructed from the Tip and the TipBatch events emitted.
As the Ethereum ecosystem continues to grow, many dapps are relying on traditional databases and explorer API services to retrieve and categorize data. This EIP standard guarantees that event logs emitted by the smart contract MUST provide enough data to create an accurate record of all current tip token and ERC-20 reward balances. A database or explorer can provide indexed and categorized searches of every tip token and reward sent to NFT holders from the events emitted by any tip token contract that implements this standard. Thus, the state of the tip token contract can be reconstructed from the events emitted alone.
A tip token contract can be fully compatible with ERC-20 specification and inherit some functions such as transfer if the tokens are allowed to be sent directly to other users. Note that balanceOf has been adopted and MUST be the number of tips held by a user’s address. If inheriting from, for example, OpenZeppelin’s implementation of ERC-20 token then their contract is responsible for maintaining the balance of tip token. Therefore, tip token balanceOf function SHOULD simply directly call the parent (super) contract’s balanceOf function.
Though it is RECOMMENDED that users’ deposits are kept locked in the tip token contract or external escrow account, and SHOULD NOT be used for anything but the rewards for holders, this cannot be enforced. This standard stipulates that the rewards MUST be available for when holders withdraw their rewards from the pool of deposits.
https://eips.ethereum.org/EIPS/eip-4399
At the point of TRANSITION_BLOCK of the Proof-of-Stake (PoS) upgrade described in EIP-3675, the difficulty block field MUST be 0 thereafter because there is no longer any Proof-of-Work (PoW) seal on the block. This means that the DIFFICULTY (0x44) instruction no longer has it’s previous semantic meaning, nor a clear “correct” value to return.
Beginning with TRANSITION_BLOCK, client software MUST set the value of the mixHash, i.e. the field with the number 13 (0-indexed) in a block header, to the latest RANDAO mix of the post beacon state of the previous block.
Beginning with TRANSITION_BLOCK, the DIFFICULTY (0x44) instruction MUST return the value of the mixHash field.
This EIP introduces backward incompatible changes to the execution and validation of EVM state transitions. As written, this EIP utilizes TRANSITION_BLOCK and is thus tightly coupled with the PoS upgrade introduced in EIP-3675. If this EIP is to be adopted, it MUST be scheduled at the same time as EIP-3675.
https://eips.ethereum.org/EIPS/eip-4400
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Every contract compliant to the EIP721Consumable extension MUST implement the IEIP721Consumable interface. The consumer extension is OPTIONAL for EIP-721 contracts.
Every contract implementing the EIP721Consumable extension is free to define the permissions of a consumer (e.g. what are consumers allowed to do within their system) with only one exception - consumers MUST NOT be considered owners, authorised operators or approved addresses as per the EIP-721 specification. Thus, they MUST NOT be able to execute transfers & approvals.
Every contract implementing the EIP721Consumable extension is free to define the permissions of a consumer (e.g. what are consumers allowed to do within their system) with only one exception - consumers MUST NOT be considered owners, authorised operators or approved addresses as per the EIP-721 specification. Thus, they MUST NOT be able to execute transfers & approvals.
The ConsumerChanged event MUST be emitted when a consumer is changed.
On every transfer, the consumer MUST be changed to a default address. It is RECOMMENDED for implementors to use address(0) as that default address.
The supportsInterface method MUST return true when called with 0x953c8dfa.
There are numerous use-cases where a distinct role for NFTs is required that MUST NOT have owner permissions. A contract that implements the consumer role and grants ownership permissions to the consumer renders this standard pointless.
https://eips.ethereum.org/EIPS/eip-4444
Clients MUST use a valid Weak Subjectivity Checkpoint to bootstrap from a more recent view of the chain. For the purpose of syncing, clients treat weak subjectivity checkpoints as the genesis block. We call this method “checkpoint sync”.
Because there are a number of alternative proposals for reducing the execution client’s footprint on disk, we’ve decided to enforce a specific pronouncination of the EIP. When pronouncing the EIP number, it MUST be pronounced EIP “four fours”. All other pronounciations are incorrect.
https://eips.ethereum.org/EIPS/eip-4494
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Three new functions MUST be added to ERC-721:
For all addresses spender, uint256s tokenId, deadline, and nonce, and bytes sig, a call to permit(spender, tokenId, deadline, sig) MUST set spender as approved on tokenId as long as the owner of tokenId remains in possession of it, and MUST emit a corresponding Approval event, if and only if the following conditions are met:
For all addresses spender, uint256s tokenId, deadline, and nonce, and bytes sig, a call to permit(spender, tokenId, deadline, sig) MUST set spender as approved on tokenId as long as the owner of tokenId remains in possession of it, and MUST emit a corresponding Approval event, if and only if the following conditions are met:
This EIP requires EIP-165. EIP165 is already required in ERC-721, but is further necessary here in order to register the interface of this EIP. Doing so will allow easy verification if an NFT contract has implemented this EIP or not, enabling them to interact accordingly. The interface of this EIP (as defined in EIP-165) is 0x5604e225. Contracts implementing this EIP MUST have the supportsInterface function return true when called with 0x5604e225.
https://eips.ethereum.org/EIPS/eip-4521
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The interface for ERC-4521 transfer() MUST conform to ERC-20 and resulting transfers MUST fire the Transfer event as described in ERC-721.
The interface for ERC-4521 transfer() MUST conform to ERC-20 and resulting transfers MUST fire the Transfer event as described in ERC-721.
https://eips.ethereum.org/EIPS/eip-4524
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
In order to be compliant with this EIP, and ERC-20-compliant contract MUST also implement the following functions:
safeTransfer and safeTransferFrom MUST transfer as expected to EOA addresses, and to contracts implementing ERC20Receiver and returning the function selector (0x4fc35859) when called, and MUST revert when transferring to a contract which either does not have ERC20Receiver implemented, or does not return the function selector when called.
safeTransfer and safeTransferFrom MUST transfer as expected to EOA addresses, and to contracts implementing ERC20Receiver and returning the function selector (0x4fc35859) when called, and MUST revert when transferring to a contract which either does not have ERC20Receiver implemented, or does not return the function selector when called.
In addition, a contract accepting safe transfers MUST implement the following if it wishes to accept safe transfers, and MUST return the function selector (0x4fc35859):
In addition, a contract accepting safe transfers MUST implement the following if it wishes to accept safe transfers, and MUST return the function selector (0x4fc35859):
https://eips.ethereum.org/EIPS/eip-4546
The wrapped deposit contract SHOULD be deployed at an identifiable address (e.g. 0x1111119a9e30bceadf9f939390293ffacef93fe9). The contract MUST be non-upgradable with no ability for state variables to be changed.
The wrapped deposit contract MUST have the following public functions:
Each of these functions MUST revert if to is an address with a zero code size. Each function MUST attempt to call a method on the to address confirming that it is willing and able to accept the deposit. If this function call does not return a true value execution MUST revert. If the asset transfer is not successful execution MUST revert.
Each of these functions MUST revert if to is an address with a zero code size. Each function MUST attempt to call a method on the to address confirming that it is willing and able to accept the deposit. If this function call does not return a true value execution MUST revert. If the asset transfer is not successful execution MUST revert.
Each of these functions MUST revert if to is an address with a zero code size. Each function MUST attempt to call a method on the to address confirming that it is willing and able to accept the deposit. If this function call does not return a true value execution MUST revert. If the asset transfer is not successful execution MUST revert.
Each of these functions MUST revert if to is an address with a zero code size. Each function MUST attempt to call a method on the to address confirming that it is willing and able to accept the deposit. If this function call does not return a true value execution MUST revert. If the asset transfer is not successful execution MUST revert.
A receiving contract MAY implement any of these functions as desired. If a given function is not implemented deposits MUST not be sent for that asset type.
Receiving contracts MUST verify that msg.sender is equal to the wrapped deposit contract. Failing to do so allows anyone to simulate deposits.
https://eips.ethereum.org/EIPS/eip-4626
All EIP-4626 tokenized Vaults MUST implement EIP-20 to represent shares.
If a Vault is to be non-transferrable, it MAY revert on calls to transfer or transferFrom.
The EIP-20 operations balanceOf, transfer, totalSupply, etc. operate on the Vault “shares”
which represent a claim to ownership on a fraction of the Vault’s underlying holdings.
All EIP-4626 tokenized Vaults MUST implement EIP-20’s optional metadata extensions.
The name and symbol functions SHOULD reflect the underlying token’s name and symbol in some way.
MUST be an EIP-20 token contract.
MUST NOT revert.
MUST be inclusive of any fees that are charged against assets in the Vault.
MUST NOT revert.
MUST NOT be inclusive of any fees that are charged against assets in the Vault.
MUST NOT show any variations depending on the caller.
MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
MUST NOT revert unless due to integer overflow caused by an unreasonably large input.
MUST round down towards 0.
MUST NOT be inclusive of any fees that are charged against assets in the Vault.
MUST NOT show any variations depending on the caller.
MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
MUST NOT revert unless due to integer overflow caused by an unreasonably large input.
MUST round down towards 0.
MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.
MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.
MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.
MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.
MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.
MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.
MUST NOT revert.
MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called in the same transaction.
MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the deposit would be accepted, regardless if the user has enough tokens approved, etc.
MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause deposit to revert.
MUST emit the Deposit event.
MUST support EIP-20 approve / transferFrom on asset as a deposit flow.
MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the deposit execution, and are accounted for during deposit.
MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).
MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.
MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.
MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.
MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0.
MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0.
MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.
MUST NOT revert.
MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the same transaction.
MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint would be accepted, regardless if the user has enough tokens approved, etc.
MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause mint to revert.
MUST emit the Deposit event.
MUST support EIP-20 approve / transferFrom on asset as a mint flow.
MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint execution, and are accounted for during mint.
MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).
MUST return the maximum amount of assets that could be transferred from owner through withdraw and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST return the maximum amount of assets that could be transferred from owner through withdraw and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST return 0.
MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST return 0.
MUST NOT revert.
MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if called in the same transaction.
MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though the withdrawal would be accepted, regardless if the user has enough shares, etc.
MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause withdraw to revert.
MUST emit the Withdraw event.
MUST support a withdraw flow where the shares are burned from owner directly where owner is msg.sender.
MUST support a withdraw flow where the shares are burned from owner directly where msg.sender has EIP-20 approval over the shares of owner.
MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).
MUST return the maximum amount of shares that could be transferred from owner through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST return the maximum amount of shares that could be transferred from owner through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.
MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.
MUST NOT revert.
MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the same transaction.
MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the redemption would be accepted, regardless if the user has enough shares, etc.
MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause redeem to revert.
MUST emit the Withdraw event.
MUST support a redeem flow where the shares are burned from owner directly where owner is msg.sender.
MUST support a redeem flow where the shares are burned from owner directly where msg.sender has EIP-20 approval over the shares of owner.
MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).
MUST be emitted when tokens are deposited into the Vault via the mint and deposit methods.
MUST be emitted when shares are withdrawn from the Vault in EIP-4626.redeem or EIP-4626.withdraw methods.
The only functions where the preferred rounding direction would be ambiguous are the convertTo functions. To ensure consistency across all EIP-4626 Vault implementations it is specified that these functions MUST both always round down. Integrators may wish to mimic rounding up versions of these functions themselves, like by adding 1 wei to the result.
https://eips.ethereum.org/EIPS/eip-4736
The Consensus Layer change withdrawal credentials operation is not yet fully specified, but MUST have at least the following fields:
Note that these restrictions SHALL NOT apply to withdrawal credential change operations found in blocks. If any operation has been included on-chain, it MUST by definition be valid regardless of its contents or protective mechanisms described above.
https://eips.ethereum.org/EIPS/eip-4747
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-4788
Beginning at the execution timestamp FORK_TIMESTAMP, execution clients MUST:
https://eips.ethereum.org/EIPS/eip-4799
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The authenticity of designated ownership of an NFT is conferred by the designating ERC-4799 contract’s ownership of the original NFT according to the source contract. This MUST be verified by clients by querying the source contract.
Clients respecting this specification SHALL NOT distribute any utility to the address of the ERC-4799 contract. Instead, they MUST distribute it to the owner of the designated token that the ERC-4799 contract points them to.
https://eips.ethereum.org/EIPS/eip-4834
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-4863
Beginning with the execution timestamp FORK_TIMESTAMP, execution clients MUST introduce the following extensions to transaction processing and block validation:
If a block contains any transactions with WITHDRAWAL_TX_TYPE type, they MUST come after ALL other transactions in the block.
If the execution client receives a block where this is not the case, it MUST consider the block invalid.
This balance change is unconditional and MUST not fail.
https://eips.ethereum.org/EIPS/eip-4881
Consensus clients MAY continue to implement the deposit Merkle tree however they choose. However, when transmitting the tree to newly syncing nodes, clients MUST use the following format:
Where finalized is a variable-length list (of maximum size DEPOSIT_CONTRACT_DEPTH) containing the hashes defined in the Deposit Finalization Flow section below. The fields deposit_root, deposit_count, and execution_block_hash store the same information as the Eth1Data object that corresponds to the snapshot, and execution_block_height is the height of the execution block with hash execution_block_hash. Consensus clients MUST make this structure available via the Beacon Node API endpoint:
Care must be taken not to send a snapshot which includes deposits that haven’t been fully included in the finalized checkpoint. Let state be the BeaconState at a given block in the chain. Under normal operation, the Eth1Data stored in state.eth1_data is replaced every EPOCHS_PER_ETH1_VOTING_PERIOD epochs. Thus, finalization of the deposit tree proceeds with increments of state.eth1_data. Let eth1data be some Eth1Data. Both of the following conditions MUST be met to consider eth1data finalized:
https://eips.ethereum.org/EIPS/eip-4883
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-4885
Smart contracts implementing this EIP standard MUST implement the EIP-165 supportsInterface function and MUST return the constant value true if 0xC1A48422 is passed through the interfaceID argument. Note that revert in this document MAY mean a require, throw (not recommended as depreciated) or revert solidity statement with or without error messages.
Smart contracts implementing this EIP standard MUST implement the EIP-165 supportsInterface function and MUST return the constant value true if 0xC1A48422 is passed through the interfaceID argument. Note that revert in this document MAY mean a require, throw (not recommended as depreciated) or revert solidity statement with or without error messages.
Use of subscription tokens is in effect an indirect way to control the lifetime of an NFT. As such it is assumed that this arrangement would work best when the NFTs and subscription token contracts subscribing to the NFTs, are deployed by the same platform or decentralised app. It MUST NOT have an impact or dependencies to existing NFTs that have not approved the subscription token as an operator. Indeed in this case, any other parties wouldn’t be aware of and any NFT lifetime dependencies will be ignored, hence should not work anyway. To this end, this proposal specifies that the ‘nft’ MUST have approved the subscriptionToken contract address as operator.
Use of subscription tokens is in effect an indirect way to control the lifetime of an NFT. As such it is assumed that this arrangement would work best when the NFTs and subscription token contracts subscribing to the NFTs, are deployed by the same platform or decentralised app. It MUST NOT have an impact or dependencies to existing NFTs that have not approved the subscription token as an operator. Indeed in this case, any other parties wouldn’t be aware of and any NFT lifetime dependencies will be ignored, hence should not work anyway. To this end, this proposal specifies that the ‘nft’ MUST have approved the subscriptionToken contract address as operator.
https://eips.ethereum.org/EIPS/eip-4886
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-4895
Beginning with the execution timestamp FORK_TIMESTAMP, execution clients MUST introduce the following extensions to block validation and processing:
NOTE: refer to EIP-3675 as some of the values in the header RLP have fixed values that MUST* be used.
This balance change is unconditional and MUST not fail.
https://eips.ethereum.org/EIPS/eip-4906
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The MetadataUpdate or BatchMetadataUpdate event MUST be emitted when the JSON metadata of a token, or a consecutive range of tokens, is changed.
The supportsInterface method MUST return true when called with 0x49064906.
https://eips.ethereum.org/EIPS/eip-4907
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The UpdateUser event MUST be emitted when a user address is changed or the user expires is changed.
The supportsInterface method MUST return true when called with 0xad092b5c.
https://eips.ethereum.org/EIPS/eip-4931
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Returns the current status of the upgrade functionality. Status MUST return true when the upgrade contract is functional and serving upgrades. It MUST return false when the upgrade contract is not currently serving upgrades.
Returns the current status of the upgrade functionality. Status MUST return true when the upgrade contract is functional and serving upgrades. It MUST return false when the upgrade contract is not currently serving upgrades.
Returns the current status of the downgrade functionality. Status MUST return true when the upgrade contract is functional and serving downgrades. It MUST return false when the upgrade contract is not currently serving downgrades. When the downgrade Optional Ext. is not implemented, this method will always return false to signify downgrades are not available.
Returns the current status of the downgrade functionality. Status MUST return true when the upgrade contract is functional and serving downgrades. It MUST return false when the upgrade contract is not currently serving downgrades. When the downgrade Optional Ext. is not implemented, this method will always return false to signify downgrades are not available.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Downgrades the amount of destination token to the source token in the specified ratio. The source tokens will be sent to the _to address. The function MUST unwrap the destination tokens back to the source tokens. The function MUST throw if the caller’s address does not have enough destination token to downgrade or if isDowngradeActive is returning false. The function MUST also fire the Downgrade event. approve MUST be called first on the destination contract.
Downgrades the amount of destination token to the source token in the specified ratio. The source tokens will be sent to the _to address. The function MUST unwrap the destination tokens back to the source tokens. The function MUST throw if the caller’s address does not have enough destination token to downgrade or if isDowngradeActive is returning false. The function MUST also fire the Downgrade event. approve MUST be called first on the destination contract.
Downgrades the amount of destination token to the source token in the specified ratio. The source tokens will be sent to the _to address. The function MUST unwrap the destination tokens back to the source tokens. The function MUST throw if the caller’s address does not have enough destination token to downgrade or if isDowngradeActive is returning false. The function MUST also fire the Downgrade event. approve MUST be called first on the destination contract.
Downgrades the amount of destination token to the source token in the specified ratio. The source tokens will be sent to the _to address. The function MUST unwrap the destination tokens back to the source tokens. The function MUST throw if the caller’s address does not have enough destination token to downgrade or if isDowngradeActive is returning false. The function MUST also fire the Downgrade event. approve MUST be called first on the destination contract.
MUST trigger when tokens are upgraded.
MUST trigger when tokens are downgraded.
https://eips.ethereum.org/EIPS/eip-4955
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-4972
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-4973
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-4974
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Every ERC-4974 compliant contract MUST implement the ERC4974 and ERC165 interfaces:
https://eips.ethereum.org/EIPS/eip-4987
Smart contracts implementing the ERC20 held token standard MUST implement all of the functions in the IERC20Holder interface.
Smart contracts implementing the ERC20 held token standard MUST also implement ERC165 and return true when the interface ID 0x74c89d54 is passed.
Smart contracts implementing the ERC721 held token standard MUST implement all of the functions in the IERC721Holder interface.
Smart contracts implementing the ERC721 held token standard MUST also implement ERC165 and return true when the interface ID 0x16b900ff is passed.
Smart contracts implementing the ERC1155 held token standard MUST implement all of the functions in the IERC1155Holder interface.
Smart contracts implementing the ERC1155 held token standard MUST also implement ERC165 and return true when the interface ID 0xced24c37 is passed.
https://eips.ethereum.org/EIPS/eip-5003
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5005
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5006
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The supportsInterface method MUST return true when called with 0xc26d96cc.
https://eips.ethereum.org/EIPS/eip-5007
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5008
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The nonce(uint256 tokenId) function MUST be implemented as view.
The supportsInterface method MUST return true when called with 0xce03fdab.
https://eips.ethereum.org/EIPS/eip-5050
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Smart contracts implementing this EIP standard MUST implement the EIP-165 supportsInterface function and MUST return the constant value true if the IERC5050Sender interface ID 0xc8c6c9f3 and/or the IERC5050Receiver interface ID 0x1a3f02f4 is passed through the interfaceID argument (depending on which interface(s) the contract implements).
Smart contracts implementing this EIP standard MUST implement the EIP-165 supportsInterface function and MUST return the constant value true if the IERC5050Sender interface ID 0xc8c6c9f3 and/or the IERC5050Receiver interface ID 0x1a3f02f4 is passed through the interfaceID argument (depending on which interface(s) the contract implements).
State contracts allow arbitrary senders and receivers to share a user-specified state environment. Each Object MAY define its own action handling, which MAY include reading from the state contract during, but the action MUST be finalized by the state contract. This means the state contract serves as ground truth.
Contracts that support Controllers SHOULD ignore require/revert statements related to action verification, and MUST NOT pass the action to the next contract in the chain.
https://eips.ethereum.org/EIPS/eip-5058
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Lockable EIP-721 MUST implement the IERC5058 interfaces:
https://eips.ethereum.org/EIPS/eip-5069
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The best available resource to understand the EIP process is EIP-1. Anyone desirous of becoming an EIP editor MUST understand this document. Afterwards, participating in the EIP process by commenting on and suggesting improvements to PRs and issues will familliarize the procedure, and is RECOMMENDED. The contributions of newer editors SHALL be monitored by other EIP editors.
This EIP MUST have the same rules regarding changes as EIP-1.
https://eips.ethereum.org/EIPS/eip-5081
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The definition of expire_by is a block number the latest possible block to
execute this transaction. Any block with a block number block_num > expire_by MUST NOT execute this transaction.
https://eips.ethereum.org/EIPS/eip-5094
If the key in the parameter is decimals the value MUST be a number.
rpc_url is represented as an array of RPC URLs. A minimum of 1 rpc_url MUST be present, in the format of rpc_url=https%3A%2F%2Fpolygon-rpc.com, or when multiple present rpc_url=https%3A%2F%2Fpolygon-rpc.com&rpc_url=https%3A%2F%2Frpc-mainnet.matic.network.
decimals if provided, MUST be a non-negative integer representing the decimal precision of the native token.
explorer_url if provided, MUST specify one or more URLs pointing to block explorer web sites for the chain.
icon_url if provided, MUST specify one or more URLs pointing to reasonably sized images that can be used to visually identify the chain.
https://eips.ethereum.org/EIPS/eip-5095
All Principal Tokens (PTs) MUST implement EIP-20 to represent ownership of future underlying redemption.
If a PT is to be non-transferrable, it MAY revert on calls to transfer or transferFrom.
The EIP-20 operations balanceOf, transfer, totalSupply, etc. operate on the Principal Token balance.
All Principal Tokens MUST implement EIP-20’s optional metadata extensions.
The name and symbol functions SHOULD reflect the underlying token’s name and symbol in some way, as well as the origination protocol, and in the case of yield tokenization protocols, the origination money-market.
MUST be an EIP-20 token contract.
MUST NOT revert.
MUST NOT revert.
MUST NOT be inclusive of any fees that are charged against redemptions.
MUST NOT show any variations depending on the caller.
MUST NOT reflect slippage or other on-chain conditions, when performing the actual redemption.
MUST NOT revert unless due to integer overflow caused by an unreasonably large input.
MUST round down towards 0.
MUST NOT be inclusive of any fees.
MUST NOT show any variations depending on the caller.
MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
MUST NOT revert unless due to integer overflow caused by an unreasonably large input.
MUST round down towards 0.
MUST return the maximum amount of principal tokens that could be transferred from holder through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST return the maximum amount of principal tokens that could be transferred from holder through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.
MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.
MUST NOT revert.
MUST return as close to and no more than the exact amount of underliyng that would be obtained in a redeem call in the same transaction. I.e. redeem should return the same or more underlyingAmount as previewRedeem if called in the same transaction.
MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the redemption would be accepted, regardless if the user has enough principal tokens, etc.
MUST be inclusive of redemption fees. Integrators should be aware of the existence of redemption fees.
MUST NOT revert due to principal token contract specific user/global limits. MAY revert due to other conditions that would also cause redeem to revert.
Interfaces and other contracts MUST NOT expect fund custody to be present. While custodial redemption of Principal Tokens through the Principal Token contract is extremely useful for integrators, some protocols may find giving the Principal Token itself custody breaks their backwards compatibility.
MUST emit the Redeem event.
MUST support a redeem flow where the Principal Tokens are burned from holder directly where holder is msg.sender or msg.sender has EIP-20 approval over the principal tokens of holder.
MAY support an additional flow in which the principal tokens are transferred to the Principal Token contract before the redeem execution, and are accounted for during redeem.
MUST revert if all of principalAmount cannot be redeemed (due to withdrawal limit being reached, slippage, the holder not having enough Principal Tokens, etc).
MUST return the maximum amount of underlying tokens that could be redeemed from holder through withdraw and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST return the maximum amount of underlying tokens that could be redeemed from holder through withdraw and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).
MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST return 0.
MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST return 0.
MUST NOT revert.
MUST return as close to and no fewer than the exact amount of principal tokens that would be burned in a withdraw call in the same transaction. I.e. withdraw should return the same or fewer principalAmount as previewWithdraw if called in the same transaction.
MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though the withdrawal would be accepted, regardless if the user has enough principal tokens, etc.
MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
MUST NOT revert due to principal token contract specific user/global limits. MAY revert due to other conditions that would also cause withdraw to revert.
MUST emit the Redeem event.
MUST support a withdraw flow where the principal tokens are burned from holder directly where holder is msg.sender or msg.sender has EIP-20 approval over the principal tokens of holder.
MAY support an additional flow in which the principal tokens are transferred to the principal token contract before the withdraw execution, and are accounted for during withdraw.
MUST revert if all of underlyingAmount cannot be withdrawn (due to withdrawal limit being reached, slippage, the holder not having enough principal tokens, etc).
MUST be emitted when Principal Tokens are burnt and underlying is withdrawn from the contract in the EIP5095.redeem method.
https://eips.ethereum.org/EIPS/eip-5115
This EIP is fully backwards compatible as its implementation extends the functionality of EIP-20, however the optional metadata extensions, namely name, decimals, and symbol semantics MUST be implemented for all SCY token implementations.
https://eips.ethereum.org/EIPS/eip-5131
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The mainAddress MUST have an ENS resolver record and reverse record configured.
In order to automatically discover the linked account, the authAddress SHOULD have an ENS resolver record and reverse record configured.
https://eips.ethereum.org/EIPS/eip-5139
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
List consumers (like wallets) MUST validate lists against the provided schema. List consumers MUST NOT connect to RPC providers present only in an invalid list.
List consumers (like wallets) MUST validate lists against the provided schema. List consumers MUST NOT connect to RPC providers present only in an invalid list.
Lists MUST conform to the following JSON Schema:
List versioning MUST follow the Semantic Versioning 2.0.0 (SemVer) specification.
The major version MUST be incremented for the following modifications:
If the major version is not incremented, the minor version MUST be incremented if any of the following modifications are made:
If the major and minor versions are unchanged, the patch version MUST be incremented for any change.
Provider lists MAY instead be published using HTTPS. Provider lists published in this way MUST allow reasonable access from other origins (generally by setting the header Access-Control-Allow-Origin: *.)
If present, the uri field MUST use a scheme specified in Publishing.
If present, the ens field MUST specify an ENS name to be resolved using EIP-1577.
The version field SHALL specify a range of compatible versions. List consumers MUST reject extension lists specifying an incompatible parent version.
In the event of an incompatible version, list consumers MAY continue to use a previously saved parent list, but list consumers choosing to do so MUST display a prominent warning that the provider list is out of date.
JSON pointers within the changes field MUST be resolved relative to the providers field of the parent list. For example, see the following lists for a correctly formatted extension.
List consumers MUST follow this algorithm to apply extension lists:
https://eips.ethereum.org/EIPS/eip-5143
This ERC is an extension of EIP-4626. Any contract implementing it MUST also implement EIP-4626.
MUST emit the Deposit event.
MUST support EIP-20 approve / transferFrom on asset as a deposit flow.
MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the deposit execution, and are accounted for during deposit.
MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).
MUST revert if depositing assets underlying asset mints less then minShares shares.
MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).
MUST revert if depositing assets underlying asset mints less then minShares shares.
MUST emit the Deposit event.
MUST support ERC-20 approve / transferFrom on asset as a mint flow.
MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint execution, and are accounted for during mint.
MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).
MUST revert if minting shares shares cost more then maxAssets underlying tokens.
MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).
MUST revert if minting shares shares cost more then maxAssets underlying tokens.
MUST emit the Withdraw event.
MUST support a withdraw flow where the shares are burned from owner directly where owner is msg.sender or msg.sender has ERC-20 approval over the shares of owner.
MAY support an additional flow in which the shares are transferred to the Vault contract before the withdraw execution, and are accounted for during withdraw.
MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).
MUST revert if withdrawing assets underlying tokens requires burning more then maxShares shares.
MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).
MUST revert if withdrawing assets underlying tokens requires burning more then maxShares shares.
MUST emit the Withdraw event.
MUST support a redeem flow where the shares are burned from owner directly where owner is msg.sender or msg.sender has ERC-20 approval over the shares of owner.
MAY support an additional flow in which the shares are transferred to the Vault contract before the redeem execution, and are accounted for during redeem.
MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).
MUST revert if redeeming shares shares sends less than minAssets underlying tokens to receiver.
MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).
MUST revert if redeeming shares shares sends less than minAssets underlying tokens to receiver.
https://eips.ethereum.org/EIPS/eip-5169
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The interface MUST be implemented under the following constraints:
https://eips.ethereum.org/EIPS/eip-5173
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Implementers of this standard MUST have all of the following functions:
An nFR contract MUST implement and update for each Token ID. The data in the FRInfo struct MAY either be stored wholly in a single mapping, or MAY be broken down into several mappings. The struct MUST either be exposed in a public mapping or mappings, or MUST have public functions that access the private data. This is for client-side data fetching and verification.
An nFR contract MUST implement and update for each Token ID. The data in the FRInfo struct MAY either be stored wholly in a single mapping, or MAY be broken down into several mappings. The struct MUST either be exposed in a public mapping or mappings, or MUST have public functions that access the private data. This is for client-side data fetching and verification.
An nFR contract MUST implement and update for each Token ID. The data in the FRInfo struct MAY either be stored wholly in a single mapping, or MAY be broken down into several mappings. The struct MUST either be exposed in a public mapping or mappings, or MUST have public functions that access the private data. This is for client-side data fetching and verification.
Additionally, an nFR smart contract MUST store the corresponding ListInfo for each Token ID in a mapping. A method to retrieve a Token ID’s corresponding ListInfo MUST also be accessible publicly.
Additionally, an nFR smart contract MUST store the corresponding ListInfo for each Token ID in a mapping. A method to retrieve a Token ID’s corresponding ListInfo MUST also be accessible publicly.
An nFR smart contract MUST also store and update the amount of Ether allocated to a specific address using the _allotedFR mapping. The _allottedFR mapping MUST either be public or have a function to fetch the FR payment allotted to a specific address.
An nFR smart contract MUST also store and update the amount of Ether allocated to a specific address using the _allotedFR mapping. The _allottedFR mapping MUST either be public or have a function to fetch the FR payment allotted to a specific address.
The allocatedFR MUST be calculated using a percentage fixed point with a scaling factor of 1e18 (X/1e18) - such as “5e16” - for 5%. This is REQUIRED to maintain uniformity across the standard. The max and min values would be - 1e18 - 1.
A default FRInfo MUST be stored in order to be backward compatible with EIP-721 mint functions. It MAY also have a function to update the FRInfo, assuming it has not been hard-coded.
An nFR-compliant smart contract MUST override the EIP-721 _mint, _transfer, and _burn functions. When overriding the _mint function, a default FR model is REQUIRED to be established if the mint is to succeed when calling the EIP-721 _mint function and not the nFR _mint function. It is also to update the owner amount and directly add the recipient address to the FR cycle. When overriding the _transfer function, the smart contract SHALL consider the NFT as sold for 0 ETH, and update the state accordingly after a successful transfer. This is to prevent FR circumvention. Finally, when overriding the _burn function, the smart contract SHALL delete the FRInfo corresponding to that Token ID after a successful burn.
If the wallet/broker/auction application will accept safe transfers, then it MUST implement the EIP-721 wallet interface.
The list, unlist, and buy functions MUST be implemented, as they provide the capability to sell a token.
The buy function accepts a tokenId and MUST be payable. It MUST verify that the msg.value matches the token’s salePrice and that the token is listed, before proceeding and calling the FR _transferFrom function. This is to ensure the values are valid and will also allow for the necessary FR to be held in the contract.
The buy function accepts a tokenId and MUST be payable. It MUST verify that the msg.value matches the token’s salePrice and that the token is listed, before proceeding and calling the FR _transferFrom function. This is to ensure the values are valid and will also allow for the necessary FR to be held in the contract.
The FR _transferFrom function MUST be called by all nFR-supporting smart contracts, though the accommodations for non-nFR-supporting contracts MAY also be implemented to ensure backwards compatibility.
Based on the stored lastSoldPrice, the smart contract will determine whether the sale was profitable after calling the EIP-721 transfer function and transferring the NFT. If it was not profitable, the smart contract SHALL update the last sold price for the corresponding Token ID, increment the owner amount, shift the generations, and transfer all of the msg.value to the lister depending on the implementation. Otherwise, if the transaction was profitable, the smart contract SHALL call the _distributeFR function, then update the lastSoldPrice, increment the owner amount, and finally shift generations. The _distributeFR function MUST return the difference between the allocated FR that is to be distributed amongst the _addressesInFR and the msg.value to the lister. Once the operations have completed, the function MUST clear the corresponding ListInfo.
Based on the stored lastSoldPrice, the smart contract will determine whether the sale was profitable after calling the EIP-721 transfer function and transferring the NFT. If it was not profitable, the smart contract SHALL update the last sold price for the corresponding Token ID, increment the owner amount, shift the generations, and transfer all of the msg.value to the lister depending on the implementation. Otherwise, if the transaction was profitable, the smart contract SHALL call the _distributeFR function, then update the lastSoldPrice, increment the owner amount, and finally shift generations. The _distributeFR function MUST return the difference between the allocated FR that is to be distributed amongst the _addressesInFR and the msg.value to the lister. Once the operations have completed, the function MUST clear the corresponding ListInfo.
When an owner loses money during their holding period, they MUST NOT be obligated to share Future Rewards distributions, since there is no profit to share. However, he SHALL still receive a share of Future Rewards distributions from future generations of owners, if they are profitable.
The _distributeFR function MUST be called in the FR transferFrom function if there is a profitable sale. The function SHALL calculate the difference between the current sale price and the lastSoldPrice, then it SHALL call the _calculateFR function to receive the proper distribution of FR. Then it SHALL distribute the FR accordingly, making order adjustments as necessary. Then, the contract SHALL calculate the total amount of FR that was distributed (allocatedFR), in order to return the difference of the soldPrice and allocatedFR to the lister. Finally, it SHALL emit the FRDistributed event.
The _shiftGenerations function MUST be called regardless of whether the sale was profitable or not. As a result, it will be called in the _transfer EIP-721 override function and the FR transferFrom function. The function SHALL remove the oldest account from the corresponding _addressesInFR array. This calculation will take into account the current length of the array versus the total number of generations for a given token ID.
https://eips.ethereum.org/EIPS/eip-5185
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5187
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5189
If the operation passes these checks, then the client MUST call isOperationReady() on the endorser. If the endorser considers the operation ready, then the client MUST add the operation to the mempool. Otherwise, the operation MUST discarded.
If the operation passes these checks, then the client MUST call isOperationReady() on the endorser. If the endorser considers the operation ready, then the client MUST add the operation to the mempool. Otherwise, the operation MUST discarded.
If the operation passes these checks, then the client MUST call isOperationReady() on the endorser. If the endorser considers the operation ready, then the client MUST add the operation to the mempool. Otherwise, the operation MUST discarded.
The endorser result MUST be invalidated and its readiness be re-evaluated if any of the values of the provided dependencies change. If the operation readiness changes to false, the operation MUST be discarded.
The endorser result MUST be invalidated and its readiness be re-evaluated if any of the values of the provided dependencies change. If the operation readiness changes to false, the operation MUST be discarded.
Before including the operation in a block, a last simulation MUST be performed, this time without calling the endorser, but by constructing the block and probing the result. All transactions in the block listed before the operation must be simulated and the endorser must be queried again there for readiness in-case some dependencies changed.
The bundler MUST NOT drop an operation after successfully including such operation in a block, the operation must remain in the mempool and a last isOperationReady call must be performed.
https://eips.ethereum.org/EIPS/eip-5192
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5202
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
A blueprint contract MUST use the preamble 0xFE71<version bits><length encoding bits>. 6 bits are allocated to the version, and 2 bits to the length encoding. The first version begins at 0 (0b000000), and versions increment by 1. The value 0b11 for <length encoding bits> is reserved. In the case that the length bits are 0b11, the third byte is considered a continuation byte (that is, the version requires multiple bytes to encode). The exact encoding of a multi-byte version is left to a future ERC.
A blueprint contract MUST contain at least one byte of initcode.
https://eips.ethereum.org/EIPS/eip-5216
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Every contract compliant to the ERC1155ApprovalByAmount extension MUST implement the IERC1155ApprovalByAmount interface. The approval by amount extension is OPTIONAL for EIP-1155 contracts.
The allowance(address account, address operator, uint256 id) function MAY be implemented as public or external for visibility and MUST be implemented as view.
Every contract implementing the ERC1155ApprovalByAmount extension MUST implement _checkApprovalForBatch(address from, address to, uint256[] memory ids, uint256[] memory amounts) function in some way. This function is necessary to manage
batch transfers subtracting the amount of tokens transferred.
The ApprovalByAmount event MUST be emitted when a certain number of tokens are approved.
The supportsInterface method MUST return true when called with 0x1be07d74.
https://eips.ethereum.org/EIPS/eip-5218
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The supportsInterface method MUST return true when called with 0xac7b5ca9.
https://eips.ethereum.org/EIPS/eip-5219
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
DApp contracts MUST implement the interface defined in the following file: Contract Interface.
https://eips.ethereum.org/EIPS/eip-5247
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5267
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Compliant contracts MUST define eip712Domain exactly as declared below. All specified values MUST be returned even if they are not used, to ensure proper decoding on the client side.
Compliant contracts MUST define eip712Domain exactly as declared below. All specified values MUST be returned even if they are not used, to ensure proper decoding on the client side.
The return values of this function MUST describe the domain separator that is used for verification of EIP-712 signatures in the contract. They describe both the form of the EIP712Domain struct (i.e., which of the optional fields and extensions are present) and the value of each field, as follows.
https://eips.ethereum.org/EIPS/eip-5269
Similar to EIP-165 callers of the interface MUST assume the smart contract
declaring they support such EIP interfaces doesn’t necessarily correctly support them.
https://eips.ethereum.org/EIPS/eip-5289
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
When a signature is requested, wallets MUST call legalDocument and fetch the file off of IPFS, and render that file to the user. If the user agrees, the wallet MUST call signDocument. Using a form of account abstraction is RECOMMENDED.
When a signature is requested, wallets MUST call legalDocument and fetch the file off of IPFS, and render that file to the user. If the user agrees, the wallet MUST call signDocument. Using a form of account abstraction is RECOMMENDED.
https://eips.ethereum.org/EIPS/eip-5313
The key word “MUST” in this document is to be interpreted as described in RFC 2119.
Every contract compliant with this EIP MUST implement the EIP5313 interface.
https://eips.ethereum.org/EIPS/eip-5334
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The UpdateUser event MUST be emitted when a user address is changed or the user expires is changed or the user level is changed.
https://eips.ethereum.org/EIPS/eip-5375
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
All addresses used in this standard MUST follow the casing rules described in EIP-55.
Moreover, if the consent field is present, the consentInfo field of authorInfo MUST be present.
consentData MAY support additional fields as defined by other EIPs. consentData MUST contain all the information (which is not already present in other fields) required to verify the validity of an authorship consent proof.
Verifiers MUST NOT assume that an NFT with a valid consent proof from address X means that X is the actual author. On the other hand, verifiers MAY assume that if an NFT does not provide a valid consent proof for address X, then X is not the actual author.
A potential attack that exploits this EIP involves tricking authors into signing authorship consent messages against their wishes. For this reason, authors MUST verify that all signature fields match the required ones.
https://eips.ethereum.org/EIPS/eip-5409
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The supportsInterface method MUST return true when called with 0x6352211e.
https://eips.ethereum.org/EIPS/eip-5437
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5450
https://eips.ethereum.org/EIPS/eip-5453
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5484
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5485
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
https://eips.ethereum.org/EIPS/eip-5489
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The SlotAuthorizationCreated event MUST be emitted when a slot is authorized to an address.
The SlotAuthorizationRevoked event MUST be emitted when a slot authorization is revoked.
The supportInterface method MUST return true when called with 0x8f65987b.
https://eips.ethereum.org/EIPS/eip-5496
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Every contract compliant to the ERC5496 extension MUST implement the IERC5496 interface. The sharable multi-privilege extension is OPTIONAL for EIP-721 contracts.
Every contract implementing the ERC5496 SHOULD set a maximum privilege number before setting any privilege, the privilegeId MUST NOT be greater than the maximum privilege number.
The PrivilegeAssigned event MUST be emitted when setPrivilege is called.
The PrivilegeTransfered event MUST be emitted when transferPrivilege is called.
The supportsInterface method MUST return true when called with 0x076e1bbb.
The PrivilegeCloned event MUST be emitted when clonePrivilege is called.