../Dataset/Raw-data/1.xml
Copyright Waiver - All EIPs must be in the public domain. The copyright waiver MUST link to the license file and use the following wording: Copyright and related rights waived via [CC0](/LICENSE).

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/20.xml
Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!

but interfaces and other contracts MUST NOT expect these values to be present.

but interfaces and other contracts MUST NOT expect these values to be present.

but interfaces and other contracts MUST NOT expect these values to be present.

Transfers _value amount of tokens to address _to, and MUST fire the Transfer event.

<em>Note</em> Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.

Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.

<em>Note</em> Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.

MUST trigger when tokens are transferred, including zero value transfers.

MUST trigger on any successful call to approve(address _spender, uint256 _value).

../Dataset/Raw-data/86.xml
Transactions of this form MUST have gasprice = 0, nonce = 0, value = 0, and do NOT increment the nonce of account NULL_SENDER.

../Dataset/Raw-data/137.xml
Resolvers may implement any subset of the record types specified here. Where a record types specification requires a resolver to provide multiple functions, the resolver MUST implement either all or none of them. Resolvers MUST specify a fallback function that throws.

If the resolver supports addr lookups but the requested node does not have an addr record, the resolver MUST return the zero address.

Clients resolving the addr record MUST check for a zero return value, and treat this in the same manner as a name that does not have a resolver specified - that is, refuse to send funds to or interact with the address. Failure to do this can result in users accidentally sending funds to the 0 address.

Changes to an address MUST trigger the following event:

../Dataset/Raw-data/634.xml
display - a canonical display name for the ENS name; this MUST match the ENS name when its case is folded, and clients should ignore this value if it does not (e.g. "ricmoo.eth" could set this to "RicMoo.eth")

../Dataset/Raw-data/681.xml
Note that a number can be expressed in <em>scientific notation</em>, with a multiplier of a power of 10. Only integer numbers are allowed, so the exponent MUST be greater or equal to the number of decimals after the point.

If <em>key</em> in the parameter list is value, gasLimit, gasPrice or gas then <em>value</em> MUST be a number. Otherwise, it must correspond to the TYPE string used as <em>key</em>.

../Dataset/Raw-data/721.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Emits the ApprovalForAll event. The contract MUST allow

A wallet/broker/auction application MUST implement the wallet interface if it will accept safe transfers.

transfer. Return of other than the magic value MUST result in the

The 0.4.20 Solidity interface grammar is not expressive enough to document the ERC-721 standard. A contract which complies with ERC-721 MUST also abide by the following:

Solidity issue #3412: The above interfaces include explicit mutability guarantees for each function. Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure. Your implementation MUST meet the mutability guarantee in this interface and you MAY meet a stronger guarantee. For example, a payable function in this interface may be implemented as nonpayable (no state mutability specified) in your contract. We expect a later Solidity release will allow your stricter contract to inherit from this interface, but a workaround for version 0.4.20 is that you can edit this interface to add stricter mutability before inheriting from your contract.

Every NFT is identified by a unique uint256 ID inside the ERC-721 smart contract. This identifying number SHALL NOT change for the life of the contract. The pair (contract address, uint256 tokenId) will then be a globally unique and fully-qualified identifier for a specific asset on an Ethereum chain. While some ERC-721 smart contracts may find it convenient to start with ID 0 and simply increment by one for each new NFT, callers SHALL NOT assume that ID numbers have any specific pattern to them, and MUST treat the ID as a “black box”. Also note that NFTs MAY become invalid (be destroyed). Please see the enumeration functions for a supported enumeration interface.

The transfer and accept functions’ documentation only specify conditions when the transaction MUST throw. Your implementation MAY also throw in other situations. This allows implementations to achieve interesting results:

../Dataset/Raw-data/725.xml
MUST only be called by the current owner of the contract.

MUST be triggered when execute creates a new call using the operationType 0, 3, 4.

MUST be triggered when execute creates a new contract using the operationType 1, 2.

Sets data as bytes in the storage for a single key. MUST only be called by the current owner of the contract.

Sets array of data at multiple keys. MUST only be called by the current owner of the contract.

MUST be triggered when setData was successfully called.

../Dataset/Raw-data/777.xml
The token contract MUST implement the above interface.

The implementation MUST follow the specifications described below.

The token contract MUST register the ERC777Token interface with its own address via <a href="/EIPS/eip-1820">ERC-1820.

the token MUST register or unregister the ERC777Token interface for its own address accordingly via ERC1820.

When interacting with the token contract, all amounts and balances MUST be unsigned integers.

The display denomination—to display any amount to the end user—MUST

the user interface MUST show 0.5 tokens to the user.

the contract MUST be called with an amount of 300,000,000,000,000,000 (0.3×10<sup>18</sup>).

But this MUST be made clear, for example by displaying the uint256 type.

The view functions detailed below MUST be implemented.

<em>NOTE</em>: The total supply MUST be equal to the sum of the balances of all addresses—as

<em>NOTE</em>: The total supply MUST be equal to the sum of all the minted tokens

The balance MUST be zero (0) or higher.

The following rules MUST be applied regarding the <em>granularity</em>:

The <em>granularity</em> value MUST be set at creation time.

The <em>granularity</em> value MUST NOT be changed, ever.

The <em>granularity</em> value MUST be greater than or equal to 1.

All balances MUST be a multiple of the granularity.

MUST be a multiple of the <em>granularity</em> value.

MUST be considered invalid, and the transaction MUST revert.

The decimals of the token MUST always be 18.

For an <a href="/EIPS/eip-20">ERC-20 compatible token, the decimals function is REQUIRED and MUST return 18.

Hence for compatibility reasons, decimals MUST be implemented for <a href="/EIPS/eip-20">ERC-20 compatible tokens.)

When an address becomes an <em>operator</em> for a <em>holder</em>, an AuthorizedOperator event MUST be emitted.

MUST be the addresses of the <em>operator</em> and the <em>holder</em> respectively.

When a <em>holder</em> revokes an <em>operator</em>, a RevokedOperator event MUST be emitted.

MUST be the addresses of the <em>operator</em> and the <em>holder</em> respectively.

AuthorizedOperator events MUST NOT be emitted when defining the <em>default operators</em>.

The token contract MUST define <em>default operators</em> at creation time.

The <em>default operators</em> MUST be invariants. I.e., the token contract MUST NOT add or remove <em>default operators</em> ever.

AuthorizedOperator events MUST NOT be emitted when defining <em>default operators</em>.

A <em>holder</em> MUST be allowed to revoke a <em>default operator</em>

A <em>holder</em> MUST be allowed to re-authorize a previously revoked <em>default operator</em>.

an AuthorizedOperator or RevokedOperator event (respectively) MUST be emitted.

An address MUST always be an <em>operator</em> for itself. Hence an address MUST NOT ever be revoked as its own <em>operator</em>.

If an address is an <em>operator</em> for a <em>holder</em>, isOperatorFor MUST return true.

If an address is not an <em>operator</em> for a <em>holder</em>, isOperatorFor MUST return false.

The token contract MUST emit an AuthorizedOperator event with the correct values

The token contract MUST emit a RevokedOperator event with the correct values

An AuthorizedOperator MUST be emitted each time.

A RevokedOperator MUST be emitted each time.

<em>NOTE</em>: This event MUST NOT be emitted outside of an <em>operator</em> authorization process.

<em>NOTE</em>: This event MUST NOT be emitted outside of an <em>operator</em> revocation process.

MUST be implemented to manage <em>operators</em>.

<em>NOTE</em>: If the token contract does not have any <em>default operators</em>, this function MUST return an empty list.

Hence this function MUST revert if it is called to authorize the holder (msg.sender)

Hence this function MUST revert if it is called to revoke the holder (msg.sender)

one MUST call isOperatorFor with the <em>holder</em> for each <em>default operator</em>

with the associated data and operatorData, the token contract MUST apply the following rules:

The balance of the <em>holder</em> MUST be decreased by the amount.

The balance of the <em>recipient</em> MUST be increased by the amount.

The balance of the <em>holder</em> MUST be greater or equal to the amount—such

The token contract MUST emit a Sent event with the correct values as defined in the <a href="#sent">Sent Event.

The token contract MUST call the tokensToSend hook of the <em>holder</em>

The token contract MUST call the tokensReceived hook of the <em>recipient</em>

The data and operatorData MUST be immutable during the entire send process—hence

the same data and operatorData MUST be used to call both hooks and emit the Sent event.

The token contract MUST revert when sending in any of the following cases:

The previous send rules MUST apply to all the <em>holders</em> and all the <em>recipients</em>.

The sum of all the balances incremented MUST be equal to the total sent amount.

The sum of all the balances decremented MUST be equal to the total sent amount.

A Sent event MUST be emitted for every <em>holder</em> and <em>recipient</em> pair with the corresponding amount for each pair.

The sum of all the amounts from the Sent event MUST be equal to the total sent amount.

<em>NOTE</em>: Sending an amount of zero (0) tokens is valid and MUST be treated as a regular send.

The token contract MUST call the tokensToSend hook <em>before</em> updating the state.

The token contract MUST call the tokensReceived hook <em>after</em> updating the state.<br />

I.e., tokensToSend MUST be called first,

then the balances MUST be updated to reflect the send,

and finally tokensReceived MUST be called <em>afterward</em>.

The operatorData MUST only be provided by the <em>operator</em>.

<em>NOTE</em>: This event MUST NOT be emitted outside of a send or an <a href="/EIPS/eip-20">ERC-20 transfer process.

The send and operatorSend functions described below MUST be implemented to send tokens.

The <em>operator</em> and the <em>holder</em> MUST both be the msg.sender.

then the send process MUST revert.

This call MUST be equivalent to send with the addition

Nonetheless, the rules below MUST be respected when minting for a <em>recipient</em>:

The total supply MUST be increased by the amount of tokens minted.

The balance of 0x0 MUST NOT be decreased.

The balance of the <em>recipient</em> MUST be increased by the amount of tokens minted.

The token contract MUST emit a Minted event with the correct values as defined in the <a href="#minted">Minted Event.

The token contract MUST call the tokensReceived hook of the <em>recipient</em>

The data and operatorData MUST be immutable during the entire mint process—hence

the same data and operatorData MUST be used to call the tokensReceived hook and emit the Minted event.

The token contract MUST revert when minting in any of the following cases:

<em>NOTE</em>: The initial token supply at the creation of the token contract MUST be considered as minting

and the tokensReceived hook of the recipient(s) MUST be called.

While a Sent event MUST NOT be emitted when minting,

The previous mint rules MUST apply to all the <em>recipients</em>.

The sum of all the balances incremented MUST be equal to the total minted amount.

A Minted event MUST be emitted for every <em>recipient</em> with the corresponding amount for each <em>recipient</em>.

The sum of all the amounts from the Minted event MUST be equal to the total minted amount.

<em>NOTE</em>: Minting an amount of zero (0) tokens is valid and MUST be treated as a regular mint.

<em>NOTE</em>: This event MUST NOT be emitted outside of a mint process.

The rules below MUST be respected when burning the tokens of a <em>holder</em>:

The total supply MUST be decreased by the amount of tokens burned.

The balance of 0x0 MUST NOT be increased.

The balance of the <em>holder</em> MUST be decreased by amount of tokens burned.

The token contract MUST emit a Burned event with the correct values as defined in the <a href="#burned">Burned Event.

The token contract MUST call the tokensToSend hook of the <em>holder</em>

The operatorData MUST be immutable during the entire burn process—hence

the same operatorData MUST be used to call the tokensToSend hook and emit the Burned event.

The token contract MUST revert when burning in any of the following cases:

While a Sent event MUST NOT be emitted when burning;

The previous burn rules MUST apply to each <em>holders</em>.

The sum of all the balances decremented MUST be equal to the total burned amount.

A Burned event MUST be emitted for every <em>holder</em> with the corresponding amount for each <em>holder</em>.

The sum of all the amounts from the Burned event MUST be equal to the total burned amount.

<em>NOTE</em>: Burning an amount of zero (0) tokens is valid and MUST be treated as a regular burn.

<em>NOTE</em>: This event MUST NOT be emitted outside of a burn process.

The burn and operatorBurn functions described below MUST be implemented to burn tokens.

The <em>operator</em> and the <em>holder</em> MUST both be the msg.sender.

then the burn process MUST revert.

The operatorData MUST only be provided by the <em>operator</em>.

This call MUST be equivalent to burn

but said address MUST implement the interface on its behalf.

<em>NOTE</em>: This function MUST NOT be called outside of a burn, send or <a href="/EIPS/eip-20">ERC-20 transfer process.

The tokensToSend hook MUST be called for every send and burn processes.

The tokensToSend hook MUST be called <em>before</em> the state is updated—i.e. <em>before</em> the balance is decremented.

operator MUST be the address which triggered the send or burn process.

from MUST be the address of the <em>holder</em> whose tokens are sent or burned.

to MUST be the address of the <em>recipient</em> which receives the tokens for a send.

to MUST be 0x0 for a burn.

amount MUST be the number of tokens the <em>holder</em> sent or burned.

data MUST contain the extra information (if any) provided to the send or the burn process.

operatorData MUST contain the extra information provided by the address

Hence the ERC777TokensSender MUST expect to be called by different token contracts.

This hook takes precedence over <a href="/EIPS/eip-20">ERC-20 and MUST be called (if registered)

When called from a transfer, operator MUST be the same value as the from.

When called from a transferFrom, operator MUST be the address which issued the transferFrom call.

MUST revert if the tokensReceived hook is called from a mint or send call.

A contract MUST register either its address or the address of another contract

but said address MUST implement the interface on its behalf.

<em>NOTE</em>: This function MUST NOT be called outside of a mint, send or <a href="/EIPS/eip-20">ERC-20 transfer process.

The tokensReceived hook MUST be called for every send and mint processes.

The tokensReceived hook MUST be called <em>after</em> the state is updated—i.e. <em>after</em> the balance is incremented.

operator MUST be the address which triggered the send or mint process.

from MUST be the address of the <em>holder</em> whose tokens are sent for a send.

from MUST be 0x0 for a mint.

to MUST be the address of the <em>recipient</em> which receives the tokens.

amount MUST be the number of tokens the <em>recipient</em> sent or minted.

data MUST contain the extra information (if any) provided to the send or the mint process.

operatorData MUST contain the extra information provided by the address

Hence the ERC777TokensRecipient MUST expect to be called by different token contracts.

This hook takes precedence over <a href="/EIPS/eip-20">ERC-20 and MUST be called (if registered)

When called from a transfer, operator MUST be the same value as the from.

When called from a transferFrom, operator MUST be the address which issued the transferFrom call.

The logo MUST NOT be used to advertise, promote or associate in any way technology—such

If implemented, it MUST always return 18.

Note however that the following functions are mandatory in <a href="/EIPS/eip-777">ERC-777 and MUST be implemented:

it MUST register the ERC20Token interface with its own address via <a href="/EIPS/eip-1820">ERC-1820.

the token MUST register or unregister the ERC20Token interface for its own address accordingly via ERC1820.

Even with an <a href="/EIPS/eip-20">ERC-20 transfer and transferFrom call, the token contract MUST check via <a href="/EIPS/eip-1820">ERC-1820

If any hook is implemented, it MUST be called.

The table below summarizes the different actions the token contract MUST take

MUST call <code>tokensReceived

The movement MUST proceed and only be canceled if another condition is not respected

During a send, mint and burn, the respective Sent, Minted and Burned events MUST be emitted.

and MUST emit a Transfer event for sending (as specified in the <a href="/EIPS/eip-20">ERC-20 standard).

During an <a href="/EIPS/eip-20">ERC-20’s transfer or transferFrom functions, a valid Sent event MUST be emitted.

Third-party developers MUST be careful not to consider both events as separate movements.

then only the Transfer event MUST be taken into account.

then only the Sent, Minted and Burned events MUST be considered.

../Dataset/Raw-data/801.xml
MUST trigger when the contract is called the first time after the canary died.

../Dataset/Raw-data/820.xml
:warning: <a href="/EIPS/eip-1820">ERC-1820 MUST be used in lieu of <a href="/EIPS/eip-820">ERC-820. :warning:

<span class="c1">/// @dev The interface a contract MUST implement if it is the implementer of

Below is the raw transaction which MUST be used to deploy the smart contract on any chain.

This transaction MUST NOT use <a href="/EIPS/eip-155">EIP-155 in order to work on any chain.

This transaction MUST have a relatively high gas price to be deployed on any chain. In this case, it is going to be 100 Gwei.

To deploy the registry, 0.08 ethers MUST be sent to this account <em>first</em>.

      "content": "/* ERC820 Pseudo-introspection Registry Contract\n * This standard defines a universal registry smart contract where any address\n * (contract or regular account) can register which interface it supports and\n * which smart contract is responsible for its implementation.\n *\n * Written in 2018 by Jordi Baylina and Jacques Dafflon\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * &lt;https://creativecommons.org/publicdomain/zero/1.0/&gt;.\n *\n *    ███████╗██████╗  ██████╗ █████╗ ██████╗  ██████╗\n *    ██╔════╝██╔══██╗██╔════╝██╔══██╗╚════██╗██╔═████╗\n *    █████╗  ██████╔╝██║     ╚█████╔╝ █████╔╝██║██╔██║\n *    ██╔══╝  ██╔══██╗██║     ██╔══██╗██╔═══╝ ████╔╝██║\n *    ███████╗██║  ██║╚██████╗╚█████╔╝███████╗╚██████╔╝\n *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚════╝ ╚══════╝ ╚═════╝\n *\n *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\n *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\n *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝\n *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝\n *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║\n *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝\n *\n */\npragma solidity 0.4.24;\n// IV is value needed to have a vanity address starting with 0x820.\n// IV: 9513\n\n/// @dev The interface a contract MUST implement if it is the implementer of\n/// some (other) interface for any address other than itself.\ninterface ERC820ImplementerInterface {\n    /// @notice Indicates whether the contract implements the interface interfaceHash for the address addr or not.\n    /// @param interfaceHash keccak256 hash of the name of the interface\n    /// @param addr Address for which the contract will implement the interface\n    /// @return ERC820_ACCEPT_MAGIC only if the contract implements interfaceHash for the address addr.\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);\n}\n\n\n/// @title ERC820 Pseudo-introspection Registry Contract\n/// @author Jordi Baylina and Jacques Dafflon\n/// @notice This contract is the official implementation of the ERC820 Registry.\n/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-820\ncontract ERC820Registry {\n    /// @notice ERC165 Invalid ID.\n    bytes4 constant INVALID_ID = 0xffffffff;\n    /// @notice Method ID for the ERC165 supportsInterface method (= bytes4(keccak256('supportsInterface(bytes4)'))).\n    bytes4 constant ERC165ID = 0x01ffc9a7;\n    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.\n    bytes32 constant ERC820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC820_ACCEPT_MAGIC\"));\n\n    mapping (address =&gt; mapping(bytes32 =&gt; address)) interfaces;\n    mapping (address =&gt; address) managers;\n    mapping (address =&gt; mapping(bytes4 =&gt; bool)) erc165Cached;\n\n    /// @notice Indicates a contract is the implementer of interfaceHash for addr.\n    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);\n    /// @notice Indicates newManager is the address of the new manager for addr.\n    event ManagerChanged(address indexed addr, address indexed newManager);\n\n    /// @notice Query if an address implements an interface and through which contract.\n    /// @param _addr Address being queried for the implementer of an interface.\n    /// (If _addr == 0 then msg.sender is assumed.)\n    /// @param _interfaceHash keccak256 hash of the name of the interface as a string.\n    /// E.g., web3.utils.keccak256('ERC777Token').\n    /// @return The address of the contract which implements the interface _interfaceHash for _addr\n    /// or 0x0 if _addr did not register an implementer for this interface.\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {\n        address addr = _addr == 0 ? msg.sender : _addr;\n        if (isERC165Interface(_interfaceHash)) {\n            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);\n            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : 0;\n        }\n        return interfaces[addr][_interfaceHash];\n    }\n\n    /// @notice Sets the contract which implements a specific interface for an address.\n    /// Only the manager defined for that address can set it.\n    /// (Each address is the manager for itself until it sets a new manager.)\n    /// @param _addr Address to define the interface for. (If _addr == 0 then msg.sender is assumed.)\n    /// @param _interfaceHash keccak256 hash of the name of the interface as a string.\n    /// For example, web3.utils.keccak256('ERC777TokensRecipient') for the ERC777TokensRecipient interface.\n    /// @param _implementer Contract address implementing _interfaceHash for _addr.\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {\n        address addr = _addr == 0 ? msg.sender : _addr;\n        require(getManager(addr) == msg.sender, \"Not the manager\");\n\n        require(!isERC165Interface(_interfaceHash), \"Must not be a ERC165 hash\");\n        if (_implementer != 0 &amp;&amp; _implementer != msg.sender) {\n            require(\n                ERC820ImplementerInterface(_implementer)\n                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC820_ACCEPT_MAGIC,\n                \"Does not implement the interface\"\n            );\n        }\n        interfaces[addr][_interfaceHash] = _implementer;\n        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);\n    }\n\n    /// @notice Sets the _newManager as manager for the _addr address.\n    /// The new manager will be able to call setInterfaceImplementer for _addr.\n    /// @param _addr Address for which to set the new manager.\n    /// @param _newManager Address of the new manager for addr.\n    function setManager(address _addr, address _newManager) external {\n        require(getManager(_addr) == msg.sender, \"Not the manager\");\n        managers[_addr] = _newManager == _addr ? 0 : _newManager;\n        emit ManagerChanged(_addr, _newManager);\n    }\n\n    /// @notice Get the manager of an address.\n    /// @param _addr Address for which to return the manager.\n    /// @return Address of the manager for a given address.\n    function getManager(address _addr) public view returns(address) {\n        // By default the manager of an address is the same address\n        if (managers[_addr] == 0) {\n            return _addr;\n        } else {\n            return managers[_addr];\n        }\n    }\n\n    /// @notice Compute the keccak256 hash of an interface given its name.\n    /// @param _interfaceName Name of the interface.\n    /// @return The keccak256 hash of an interface name.\n    function interfaceHash(string _interfaceName) external pure returns(bytes32) {\n        return keccak256(abi.encodePacked(_interfaceName));\n    }\n\n    /* --- ERC165 Related Functions --- */\n    /* --- Developed in collaboration with William Entriken. --- */\n\n    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n    /// @param _contract Address of the contract for which to update the cache.\n    /// @param _interfaceId ERC165 interface for which to update the cache.\n    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {\n        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(_contract, _interfaceId) ? _contract : 0;\n        erc165Cached[_contract][_interfaceId] = true;\n    }\n\n    /// @notice Checks whether a contract implements an ERC165 interface or not.\n    /// The result may be cached, if not a direct lookup is performed.\n    /// @param _contract Address of the contract to check.\n    /// @param _interfaceId ERC165 interface to check.\n    /// @return true if _contract implements _interfaceId, false otherwise.\n    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {\n        if (!erc165Cached[_contract][_interfaceId]) {\n            return implementsERC165InterfaceNoCache(_contract, _interfaceId);\n        }\n        return interfaces[_contract][_interfaceId] == _contract;\n    }\n\n    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n    /// @param _contract Address of the contract to check.\n    /// @param _interfaceId ERC165 interface to check.\n    /// @return true if _contract implements _interfaceId, false otherwise.\n    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {\n        uint256 success;\n        uint256 result;\n\n        (success, result) = noThrowCall(_contract, ERC165ID);\n        if (success == 0 || result == 0) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, INVALID_ID);\n        if (success == 0 || result != 0) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, _interfaceId);\n        if (success == 1 &amp;&amp; result == 1) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\n    /// @param _interfaceHash The hash to check.\n    /// @return true if the hash is a ERC165 interface (ending with 28 zeroes), false otherwise.\n    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {\n        return _interfaceHash &amp; 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;\n    }\n\n    /// @dev Make a call on a contract without throwing if the function does not exist.\n    function noThrowCall(address _contract, bytes4 _interfaceId)\n        internal view returns (uint256 success, uint256 result)\n    {\n        bytes4 erc165ID = ERC165ID;\n\n        assembly {\n                let x := mload(0x40)               // Find empty storage location using \"free memory pointer\"\n                mstore(x, erc165ID)                // Place signature at beginning of empty storage\n                mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature\n\n                success := staticcall(\n                    30000,                         // 30k gas\n                    _contract,                     // To addr\n                    x,                             // Inputs are stored at location x\n                    0x08,                          // Inputs are 8 bytes long\n                    x,                             // Store output over input (saves space)\n                    0x20                           // Outputs are 32 bytes long\n                )\n\n                result := mload(x)                 // Load the result\n        }\n    }\n}\n",

If the interface is part of an approved ERC, it MUST be named ERC###XXXXX where ### is the number of the ERC and XXXXX should be the name of the interface in CamelCase. The meaning of this interface SHOULD be defined in the specified ERC.

<em>NOTE</em>: The result is cached. If the cache is out of date, it MUST be updated by calling updateERC165Cache. (See <a href="#erc165-cache">ERC165 Cache for more details.)

If a contract dynamically changes its interface and relies on the <a href="/EIPS/eip-165">ERC-165 cache of the <a href="/EIPS/eip-820">ERC-820 registry, the cache MUST be updated manually—there is no automatic cache invalidation or cache update. Ideally the contract SHOULD automatically update the cache when changing its interface. However anyone MAY update the cache on the contract’s behalf.

The cache update MUST be done using the updateERC165Cache function:

This scheme is extensible. You MAY make up your own interface name and raise awareness to get other people to implement it and then check for those implementations. Have fun but please, you MUST not conflict with the reserved designations above.

The _implementer MUST implement the ERC820ImplementerInterface (detailed below).

Calling canImplementInterfaceForAddress on _implementer with the given _addr and _interfaceHash MUST return the ERC820_ACCEPT_MAGIC value.

<em>NOTE</em>: The _interfaceHash MUST NOT be an <a href="/EIPS/eip-165">ERC-165 interface—it MUST NOT end with 28 zeroes (0).

Any contract being registered as the implementation of an interface for a given address MUST implement said interface. In addition if it implements an interface on behalf of a different address, the contract MUST implement the ERC820ImplementerInterface shown above.

If a contract implements the interface (interfaceHash) for a given address (addr), it MUST return ERC820_ACCEPT_MAGIC when called with the addr and the interfaceHash. If it does not implement the interfaceHash for a given address (addr), it MUST NOT return ERC820_ACCEPT_MAGIC.

../Dataset/Raw-data/823.xml
NOTE: Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!

NOTE: Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!

../Dataset/Raw-data/884.xml
Each token MUST correspond to a single share, each of which would be paid for in full, so there is no need to record information concerning partly paid shares, and there are no partial tokens.

 *  The implementation MUST take care not to allow unauthorised access to

 *  In addition to the above the following optional ERC20 function MUST be defined.

 *  decimals — MUST return 0 as each token represents a single share and shares are non-divisible.

     *  It MUST throw if the supplied address or hash are zero, or if the address has already been supplied.

     *  It MUST throw if an attempt is made to remove a verifiedAddress that owns tokens.

     *  It MUST throw if the hash is zero, or if the address is unverified.

     *  Access to this function MUST be strictly controlled.

     *  The original address MUST be removed from the set of verified addresses.

     *  This function MUST emit the VerifiedAddressSuperseded event.

     *  @param original The address to be superseded. This address MUST NOT be reused.

     *  The transfer function MUST NOT allow transfers to addresses that

     *  If the to address is not currently a shareholder then it MUST become one.

     *  MUST be removed from the list of shareholders.

     *  The transferFrom function MUST NOT allow transfers to addresses that

     *  If the to address is not currently a shareholder then it MUST become one.

     *  MUST be removed from the list of shareholders.

     *  It MUST throw if index &gt;= holderCount().

The decimals function MUST return 0 as the tokens MUST NOT be divisible,

The transfer and transferFrom functions MUST NOT allow transfers to non-verified addresses, and MUST maintain a list of shareholders.

../Dataset/Raw-data/900.xml
Stakes a certain amount of tokens, this MUST transfer the given amount from the user.

MUST trigger Staked event.

Stakes a certain amount of tokens, this MUST transfer the given amount from the caller.

MUST trigger Staked event.

Unstakes a certain amount of tokens, this SHOULD return the given amount of tokens to the user, if unstaking is currently not possible the function MUST revert.

MUST trigger Unstaked event.

MUST return true if the optional history functions are implemented, otherwise false.

../Dataset/Raw-data/902.xml
This event MUST be fired on return from a call to a TokenValidator.check/2.

This event MUST be fired on return from a call to a TokenValidator.check/4.

../Dataset/Raw-data/926.xml
Providers may implement any subset of the metadata record types specified here. Where a record types specification requires a provider to provide multiple functions, the provider MUST implement either all or none of them. Providers MUST throw if called with an unsupported function ID.

The first argument to all provider functions MUST be the address being queried; this facilitates the creation of multi-user provider contracts.

../Dataset/Raw-data/927.xml
Arguments have the same meaning as in canCall. Implementing contracts MUST ensure that msg.sender is authorised to call authoriseCaller or revokeCaller on behalf of owner; this MUST always be true if owner == msg.sender. Implementing contracts SHOULD use the standard specified here to determine if other callers may provide authorisations as well.

../Dataset/Raw-data/998.xml
This function transfers an amount of tokens from a user address to an ERC721 token. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address. MUST be triggered when setData was successfully called. (in addition to the standard ERC20 Transfer event!). This function MUST throw if the _from account balance does not have enough tokens to spend.

This function transfers an amount of tokens from an ERC721 token to an address. This function MUST emit the TransferFromParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise.

This function transfers an amount of tokens from an ERC721 token to an address. This function has identical requirements to transferFromParent, except that it additionally MUST invoke tokenFallback on the recipient address, if the address is a contract, as specified by ERC223.

This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.

For backwards-compatibility, implementations MUST emit the standard ERC20 Transfer event when a transfer occurs, regardless of whether the sender and recipient are addresses or ERC721 tokens. In the case that either sender or recipient are tokens, the corresponding parameter in the Transfer event SHOULD be the contract address of the token.

Implementations MUST implement all ERC20 and ERC223 functions in addition to the functions specified in this interface.

../Dataset/Raw-data/1056.xml
MUST be triggered when changeOwner or changeOwnerSigned was successfully called.

MUST be triggered when a change to a delegate was successfully made.

MUST be triggered when a change to an attribute was successfully made.

../Dataset/Raw-data/1080.xml
Reports the lostAccount address as being lost. MUST trigger the AccountClaimedLost event.

After the time configured in getLostAccountRecoveryTimeInMinutes the implementer MUST provide a mechanism for determining the correct owner of the tokens held and moving the tokens to a new account.

Reports the msg.sender’s account as being not being lost. MUST trigger the AccountClaimedLostCanceled event.

MUST fail if an account recovery process has already begun.

Otherwise, this method MUST stop a dispute from being started to recover funds.

Reports the current address as being stolen. MUST trigger the AccountFrozen event.

Successful calls MUST result in the msg.sender’s tokens being frozen.

The implementer MUST provide a mechanism for determining the correct owner of the tokens held and moving the tokens to a new account.

The implementer MUST provide a mechanism for determining the correct owner of the tokens disputed and moving the tokens to the correct account.

MUST comply with sender’s chargeback window as value configured by setPendingTransferTimeInMinutes.

MUST NOT change the time if the account has any pending transfers.

MUST NOT change the time if the account has open disputes.

A record of an account being frozen. MUST trigger when an account is frozen.

../Dataset/Raw-data/1102.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119.

../Dataset/Raw-data/1109.xml
A PRECOMPILEDCALL to a regular address or regular smart contract, is considered a call to an “undefined smart contract”, so the VM MUST not execute it and the opcode must return 0x0 .

../Dataset/Raw-data/1123.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,

../Dataset/Raw-data/1129.xml
MUST trigger when new announcement is created.

MUST trigger when an announcement is removed.

../Dataset/Raw-data/1154.xml
receiveResult MUST revert if the msg.sender is not an oracle authorized to provide the result for that id.

receiveResult MUST revert if receiveResult has been called with the same id before.

Consumers MUST coordinate with oracles to determine how to encode/decode results to and from bytes. For example, abi.encode and abi.decode may be used to implement a codec for results in Solidity. receiveResult SHOULD revert if the consumer receives a unexpected result format from the oracle.

resultFor MUST revert if the result for an id is not available yet.

resultFor MUST return the same result for an id after that result is available.

../Dataset/Raw-data/1155.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Smart contracts implementing the ERC-1155 standard MUST implement all of the functions in the ERC1155 interface.

Smart contracts implementing the ERC-1155 standard MUST implement the ERC-165 supportsInterface function and MUST return the constant value true if 0xd9b67a26 is passed through the interfaceID argument.

        @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard).

        The _operator argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).

        The _from argument MUST be the address of the holder whose balance is decreased.

        The _to argument MUST be the address of the recipient whose balance is increased.

        The _id argument MUST be the token type being transferred.

        The _value argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.

        When minting/creating tokens, the _from argument MUST be set to 0x0 (i.e. zero address).

        When burning/destroying tokens, the _to argument MUST be set to 0x0 (i.e. zero address).

        @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see "Safe Transfer Rules" section of the standard).

        The _operator argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).

        The _from argument MUST be the address of the holder whose balance is decreased.

        The _to argument MUST be the address of the recipient whose balance is increased.

        The _ids argument MUST be the list of tokens being transferred.

        The _values argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.

        When minting/creating tokens, the _from argument MUST be set to 0x0 (i.e. zero address).

        When burning/destroying tokens, the _to argument MUST be set to 0x0 (i.e. zero address).

        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).

        @dev MUST emit when the URI is updated for a token ID.

        The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".

        MUST revert if _to is the zero address.

        MUST revert if balance of holder for token _id is lower than the _value sent.

        MUST revert on any other error.

        MUST emit the TransferSingle event to reflect the balance change (see "Safe Transfer Rules" section of the standard).

        After the above conditions are met, this function MUST check if _to is a smart contract (e.g. code size &gt; 0). If so, it MUST call onERC1155Received on _to and act appropriately (see "Safe Transfer Rules" section of the standard).

        @param _data    Additional data with no specified format, MUST be sent unaltered in call to onERC1155Received on _to

        MUST revert if _to is the zero address.

        MUST revert if length of _ids is not the same as length of _values.

        MUST revert if any of the balance(s) of the holder(s) for token(s) in _ids is lower than the respective amount(s) in _values sent to the recipient.

        MUST revert on any other error.

        MUST emit TransferSingle or TransferBatch event(s) such that all the balance changes are reflected (see "Safe Transfer Rules" section of the standard).

        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).

        After the above conditions for the transfer(s) in the batch are met, this function MUST check if _to is a smart contract (e.g. code size &gt; 0). If so, it MUST call the relevant ERC1155TokenReceiver hook(s) on _to and act appropriately (see "Safe Transfer Rules" section of the standard).

        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the ERC1155TokenReceiver hook(s) on _to

        @dev MUST emit the ApprovalForAll event on success.

Smart contracts MUST implement all of the functions in the ERC1155TokenReceiver interface to accept transfers. See “Safe Transfer Rules” for further detail.

Smart contracts MUST implement the ERC-165 supportsInterface function and signify support for the ERC1155TokenReceiver interface to accept transfers. See “ERC1155TokenReceiver ERC-165 rules” for further detail.

        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a safeTransferFrom after the balance has been updated.

        This function MUST return bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")) (i.e. 0xf23a6e61) if it accepts the transfer.

        This function MUST revert if it rejects the transfer.

        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.

        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a safeBatchTransferFrom after the balances have been updated.

        This function MUST return bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)")) (i.e. 0xbc197c81) if it accepts the transfer(s).

        This function MUST revert if it rejects the transfer(s).

        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.

To be more explicit about how the standard safeTransferFrom and safeBatchTransferFrom functions MUST operate with respect to the ERC1155TokenReceiver hook functions, a list of scenarios and rules follows.

onERC1155Received and onERC1155BatchReceived MUST NOT be called on an EOA (Externally Owned Account).

onERC1155Received and onERC1155BatchReceived MUST NOT be called outside of a mint or transfer process.

The transfer MUST be reverted with the one caveat below.

The transfer MUST be reverted.

The transfer MUST be reverted.

The balances for the transfer MUST have been updated before the ERC1155TokenReceiver hook is called on a recipient contract.

The transfer event MUST have been emitted to reflect the balance changes before the ERC1155TokenReceiver hook is called on the recipient contract.

One of onERC1155Received or onERC1155BatchReceived MUST be called on the recipient contract.

See “onERC1155Received rules” for further rules that MUST be followed.

See “onERC1155BatchReceived rules” for further rules that MUST be followed.

All balance transfers that are referenced in a call to an ERC1155TokenReceiver hook MUST be updated before the ERC1155TokenReceiver hook is called on the recipient contract.

All transfer events MUST have been emitted to reflect current balance changes before an ERC1155TokenReceiver hook is called on the recipient contract.

onERC1155Received or onERC1155BatchReceived MUST be called on the recipient as many times as necessary such that every balance change for the recipient in the scenario is accounted for.

The return magic value for every hook call MUST be checked and acted upon as per “onERC1155Received rules” and “onERC1155BatchReceived rules”.

See “onERC1155BatchReceived rules” for further rules that MUST be followed.

See “onERC1155Received rules” for further rules that MUST be followed.

The prescribed keccak256 acceptance value magic for the receiver hook being called MUST be returned after forwarding is successful.

i.e. an external viewer MUST still be able to query the balance via a standard function and it MUST be identical to the balance as determined by TransferSingle and TransferBatch events alone.

However while the safeTransferFrom or safeBatchTransferFrom functions MUST revert if a receiving contract does not implement the ERC1155TokenReceiver interface, a non-standard function MAY proceed with the transfer.

MUST revert if _to is the zero address.

MUST revert if balance of holder for token _id is lower than the _value sent to the recipient.

MUST revert on any other error.

MUST emit the TransferSingle event to reflect the balance change (see “TransferSingle and TransferBatch event rules” section).

After the above conditions are met, this function MUST check if _to is a smart contract (e.g. code size &gt; 0). If so, it MUST call onERC1155Received on _to and act appropriately (see “onERC1155Received rules” section).

The _data argument provided by the sender for the transfer MUST be passed with its contents unaltered to the onERC1155Received hook function via its _data argument.

MUST revert if _to is the zero address.

MUST revert if length of _ids is not the same as length of _values.

MUST revert if any of the balance(s) of the holder(s) for token(s) in _ids is lower than the respective amount(s) in _values sent to the recipient.

MUST revert on any other error.

MUST emit TransferSingle or TransferBatch event(s) such that all the balance changes are reflected (see “TransferSingle and TransferBatch event rules” section).

The balance changes and events MUST occur in the array order they were submitted (_ids[0]/_values[0] before _ids[1]/_values[1], etc).

After the above conditions are met, this function MUST check if _to is a smart contract (e.g. code size &gt; 0). If so, it MUST call onERC1155Received or onERC1155BatchReceived on _to and act appropriately (see “onERC1155Received and onERC1155BatchReceived rules” section).

The _data argument provided by the sender for the transfer MUST be passed with its contents unaltered to the ERC1155TokenReceiver hook function(s) via their _data argument.

The _operator argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).

The _from argument MUST be the address of the holder whose balance is decreased.

The _to argument MUST be the address of the recipient whose balance is increased.

The _id argument MUST be the token type being transferred.

The _value argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.

When minting/creating tokens, the _from argument MUST be set to 0x0 (i.e. zero address). See “Minting/creating and burning/destroying rules”.

When burning/destroying tokens, the _to argument MUST be set to 0x0 (i.e. zero address). See “Minting/creating and burning/destroying rules”.

The _operator argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).

The _from argument MUST be the address of the holder whose balance is decreased for each entry pair in _ids and _values.

The _to argument MUST be the address of the recipient whose balance is increased for each entry pair in _ids and _values.

The _ids array argument MUST contain the ids of the tokens being transferred.

The _values array argument MUST contain the number of token to be transferred for each corresponding entry in _ids.

_ids and _values MUST have the same length.

When minting/creating tokens, the _from argument MUST be set to 0x0 (i.e. zero address). See “Minting/creating and burning/destroying rules”.

When burning/destroying tokens, the _to argument MUST be set to 0x0 (i.e. zero address). See “Minting/creating and burning/destroying rules”.

All TransferSingle and TransferBatch events MUST be emitted to reflect all the balance changes that have occurred before any call(s) to onERC1155Received or onERC1155BatchReceived.

To make sure event order is correct in the case of valid re-entry (e.g. if a receiver contract forwards tokens on receipt) state balance and events balance MUST match before calling an external contract.

The _operator argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).

The _from argument MUST be the address of the holder whose balance is decreased.

_from MUST be 0x0 for a mint.

The _id argument MUST be the token type being transferred.

The _value argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.

The _data argument MUST contain the information provided by the sender for the transfer with its contents unaltered.

i.e. it MUST pass on the unaltered _data argument sent via the safeTransferFrom or safeBatchTransferFrom call for this transfer.

If the return value is bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")) the transfer MUST be completed or MUST revert if any other conditions are not met for success.

If the recipient contract throws/reverts the transaction MUST be reverted.

If the return value is anything other than bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)")) the transaction MUST be reverted.

The _operator argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).

The _from argument MUST be the address of the holder whose balance is decreased.

_from MUST be 0x0 for a mint.

The _ids argument MUST be the list of tokens being transferred.

The _values argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.

The _data argument MUST contain the information provided by the sender for the transfer with its contents unaltered.

i.e. it MUST pass on the unaltered _data argument sent via the safeBatchTransferFrom call for this transfer.

If the return value is bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)")) the transfer MUST be completed or MUST revert if any other conditions are not met for success.

If the recipient contract throws/reverts the transaction MUST be reverted.

If the return value is anything other than bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)")) the transaction MUST be reverted.

It MUST return the constant value true if 0x01ffc9a7 is passed through the interfaceID argument. This signifies ERC-165 support.

It MUST return the constant value true if 0x4e2312e0 is passed through the interfaceID argument. This signifies ERC-1155 ERC1155TokenReceiver support.

It MUST NOT consume more than 10,000 gas.

If an implementation specific API function is used to transfer ERC-1155 token(s) to a contract, the safeTransferFrom or safeBatchTransferFrom (as appropriate) rules MUST still be followed if the receiver implements the ERC1155TokenReceiver interface. If it does not the non-standard implementation SHOULD revert but MAY proceed.

If however myTransferFrom wishes to continue it MUST call supportsInterface(0x4e2312e0) on _to and if it returns the constant value true the transaction MUST be reverted, as it is now known to be a valid receiver and the previous acceptance step failed.

Balances that are updated MUST have equivalent transfer events emitted.

Balances (and events associated) that are referenced in a call to an ERC1155TokenReceiver hook MUST be updated (and emitted) before the ERC1155TokenReceiver hook is called.

The return values of the ERC1155TokenReceiver hook functions that are called MUST be respected if they are implemented.

Only non-standard transfer functions MAY allow tokens to be sent to a recipient contract that does NOT implement the necessary ERC1155TokenReceiver hook functions. safeTransferFrom and safeBatchTransferFrom MUST revert in that case (unless it is a hybrid standards implementation see “Backwards Compatibility”).

A mint/create operation is essentially a specialized transfer and MUST follow these rules:

The “TransferSingle and TransferBatch event rules” MUST be followed as appropriate for the mint(s) (i.e. singles or batches) however the _from argument MUST be set to 0x0 (i.e. zero address) to flag the transfer as a mint to contract observers.

NOTE: This includes tokens that are given an initial balance in the contract. The balance of the contract MUST also be able to be determined by events alone meaning initial contract balances (for eg. in construction) MUST emit events to reflect those balances too.

A burn/destroy operation is essentially a specialized transfer and MUST follow these rules:

The “TransferSingle and TransferBatch event rules” MUST be followed as appropriate for the burn(s) (i.e. singles or batches) however the _to argument MUST be set to 0x0 (i.e. zero address) to flag the transfer as a burn to contract observers.

When burning/destroying you do not have to actually transfer to 0x0 (that is impl specific), only the _to argument in the event MUST be set to 0x0 as above.

Even in a non-safe API and/or hybrid standards case the above event rules MUST still be adhered to when minting/creating or burning/destroying.

A contract MAY skip calling the ERC1155TokenReceiver hook function(s) if the mint operation is transferring the token(s) to itself. In all other cases the ERC1155TokenReceiver rules MUST be followed as appropriate for the implementation (i.e. safe, custom and/or hybrid).

The URI value allows for ID substitution by clients. If the string {id} exists in any URI, clients MUST replace this with the actual token ID in hexadecimal form. This allows for a large number of tokens to use the same on-chain string by defining a URI once, for that large number of tokens.

The string format of the substituted hexadecimal ID MUST be lowercase alphanumeric: [0-9a-f] with no 0x prefix.

The string format of the substituted hexadecimal ID MUST be leading zero padded to 64 hex characters length if necessary.

The ERC-165 supportsInterface function MUST return the constant value true if 0x0e89341c is passed through the interfaceID argument.

<em>Changes</em> to the URI MUST emit the URI event if the change can be expressed with an event (i.e. it isn’t dynamic/programmatic).

The uri function MUST return the same value as the latest event for an _id if it was emitted.

The uri function MUST NOT be used to check for the existence of a token as it is possible for an implementation to return a valid string even if the token does not exist.

        The URI MUST point to a JSON file that conforms to the "ERC-1155 Metadata URI JSON Schema".

This JSON schema is loosely based on the “ERC721 Metadata JSON Schema”, but includes optional formatting to allow for ID substitution by clients. If the string {id} exists in any JSON value, it MUST be replaced with the actual token ID, by all client software that follows this standard.

The string format of the substituted hexadecimal ID MUST be lowercase alphanumeric: [0-9a-f] with no 0x prefix.

The string format of the substituted hexadecimal ID MUST be leading zero padded to 64 hex characters length if necessary.

Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains a localization attribute, its content MAY be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three attributes: uri, default and locales. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.

The requirement to emit TransferSingle or TransferBatch on balance change implies that a valid implementation of ERC-1155 redeploying to a new contract address MUST emit events from the new contract address to replicate the deprecated contract final state. It is valid to only emit a minimal number of events to reflect only the final balance and omit all the transactions that led to that state. The event emit requirement is to ensure that the current state of the contract can always be traced only through events. To alleviate the need to emit events when changing contract address, consider using the proxy pattern, such as described in <a href="/EIPS/eip-2535">EIP-2535. This will also have the added benefit of providing a stable contract address for users.

Hence in a hybrid ERC-1155 contract implementation an extra call MUST be made on the recipient contract and checked before any hook calls to onERC1155Received or onERC1155BatchReceived are made.

Order of operation MUST therefore be:

The implementation MUST call the function supportsInterface(0x4e2312e0) on the recipient contract, providing at least 10,000 gas.

An important consideration is that even if the tokens are sent with another standard’s rules the <em>ERC-1155 transfer events MUST still be emitted.</em> This is so the balances can still be determined via events alone as per ERC-1155 standard rules.

../Dataset/Raw-data/1178.xml
<em>OPTIONAL - It is recommended that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method.</em>

<em>OPTIONAL - It is recommended that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method.</em>

<em>OPTIONAL - It is recommend that this method is implemented for enhanced usability with wallets and exchanges, but interfaces and other contracts MUST NOT depend on the existence of this method.</em>

Grants approval for address _to to take possession quantity amount of the MCFT with ID _classId. This method MUST throw if balanceOf(msg.sender, _classId) &lt; quantity, or if _classId does not represent an MCFT class currently tracked by this contract, or if msg.sender == _to.

Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)

Assigns the ownership of quantity MCFT’s with ID _classId to _to if and only if quantity == balanceOf(msg.sender, _classId). A successful transfer MUST fire the Transfer event (defined below).

This method MUST transfer ownership to _to or throw, no other outcomes can be possible. Reasons for failure include (but are not limited to):

A conforming contract MUST allow the current owner to “transfer” a token to themselves, as a way of affirming ownership in the event stream. (i.e. it is valid for _to == msg.sender if balanceOf(msg.sender, _classId) &gt;= balance.) This “no-op transfer” MUST be considered a successful transfer, and therefore MUST fire a Transfer event (with the same address for _from and _to).

This event MUST trigger when MCFT ownership is transferred via any mechanism.

Additionally, the creation of new MCFTs MUST trigger a Transfer event for each newly created MCFTs, with a _from address of 0 and a _to address matching the owner of the new MCFT (possibly the smart contract itself). The deletion (or burn) of any MCFT MUST trigger a Transfer event with a _to address of 0 and a _from address of the owner of the MCFT (now former owner!).

This event MUST trigger on any successful call to approve(_to, _classId, quantity) (unless the caller is attempting to clear approval when there is no pending approval).

../Dataset/Raw-data/1193.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119.

If resolved, the Promise MUST resolve with a result per the RPC method’s specification. The Promise MUST NOT resolve with any RPC protocol-specific response objects, unless the RPC method’s return type is so defined.

../Dataset/Raw-data/1202.xml
///      Any contract of ERC1202 **MUST** implement ALL the following methods and events.

Whenever referring to the options as a whole, the order MUST be maintained.

../Dataset/Raw-data/1207.xml
The callable function MUST verify the grantee’s authorization

This method MUST return success or throw, no other outcomes can be possible

This method MUST return success or throw, no other outcomes can be possible

This method MUST return success or throw, no other outcomes can be possible

A successful grant MUST fire the Grant event(defined below)

A successful revoke MUST fire the Revoke event(defined below).

This event MUST trigger when the authorizer grant a new authorization when grant or regrant processes successfully

This event MUST trigger when the authorizer revoke a specific authorization successfully

All public or external functions that are allowed the grantee to call MUST use overload to implement two functions: The First one is the standard method that the user invokes directly, the second one is the grantee methods of the same function name with one more authorizer address parameter.

../Dataset/Raw-data/1261.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The 0.4.24 Solidity interface grammar is not expressive enough to document the ERC-1261 standard. A contract which complies with ERC-1261 MUST also abide by the following:

 Solidity issue #3412: The above interfaces include explicit mutability guarantees for each function. Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure. Your implementation MUST meet the mutability guarantee in this interface and you MAY meet a stronger guarantee. For example, a payable function in this interface may be implemented as nonpayble (no state mutability specified) in your contract. We expect a later Solidity release will allow your stricter contract to inherit from this interface, but a workaround for version 0.4.24 is that you can edit this interface to add stricter mutability before inheriting from your contract.

The assign and revoke functions’ documentation only specify conditions when the transaction MUST throw. Your implementation MAY also throw in other situations. This allows implementations to achieve interesting results:

../Dataset/Raw-data/1271.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119.

   * MUST return the bytes4 magic value 0x1626ba7e when function passes.

   * MUST NOT modify state (using STATICCALL for solc &lt; 0.5, view modifier for solc &gt; 0.5)

   * MUST allow external calls

../Dataset/Raw-data/1319.xml
MUST be triggered when release is successfully called.

../Dataset/Raw-data/1363.xml
   * transfer. Return of other than the magic value MUST result in the

   * approval. Return of other than the magic value MUST result in the

../Dataset/Raw-data/1417.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The 0.4.24 Solidity interface grammar is not expressive enough to document the ERC-1417 standard. A contract which complies with ERC-1417 MUST also abide by the following:

Solidity issue #3412: The above interfaces include explicit mutability guarantees for each function. Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure. Your implementation MUST meet the mutability guarantee in this interface and you MAY meet a stronger guarantee. For example, a payable function in this interface may be implemented as nonpayble (no state mutability specified) in your contract. We expect a later Solidity release will allow your stricter contract to inherit from this interface, but a workaround for version 0.4.24 is that you can edit this interface to add stricter mutability before inheriting from your contract.

../Dataset/Raw-data/1444.xml
A fallback Localization with all keys filled MUST be available. If the user-specified Localization has not explicitly set a loalization (ie. textFor returns ""), the LocalizationPreferences MUST redelegate to the fallback Localization.

The first return value (bool _wasFound) represents if the text is available from that Localization, or if a fallback was used. If the fallback was used in this context, the textFor’s first return value MUST be set to false, and is true otherwise.

All strings MUST be encoded as <a href="https://www.ietf.org/rfc/rfc3629.txt">UTF-8.

Template strings are allowed, and MUST follow the <a href="https://pubs.opengroup.org/onlinepubs/009696799/utilities/printf.html">ANSI C printf conventions.

../Dataset/Raw-data/1474.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119.

../Dataset/Raw-data/1484.xml
MUST be triggered when an Identity is created.

MUST be triggered when an address is added to an Identity.

MUST be triggered when an address is removed from an Identity.

MUST be triggered when a provider is added to an Identity.

MUST be triggered when a provider is removed.

MUST be triggered when a resolver is added.

MUST be triggered when a resolver is removed.

MUST be triggered when a recovery address change is triggered.

MUST be triggered when recovery is triggered.

MUST be triggered when an Identity is destroyed.

../Dataset/Raw-data/1523.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

An ERC-1523 compliant insurance policy is a non-fungible token which MUST adhere to the ERC-721 token standard and MUST implement theERC721Metadata and the ERC721Enumerable interface:

../Dataset/Raw-data/1571.xml
The Stratum protocol is an instance of <a href="https://www.jsonrpc.org/specification">JSON-RPC-2.0. The miner is a JSON-RPC client, and the server is a JSON-RPC server. All communications exist within the scope of a session. A session starts at the moment a client opens a TCP connection to the server till the moment either party do voluntary close the very same connection or it gets broken. Servers MAY support session resuming if this is initially negotiated (on first session handshaking) between the client and the server. During a session all messages exchanged among server and client are line-based which means all messages are JSON strings terminated by ASCII LF character (which may also be denoted as \n in this document). The LF character MUST NOT appear elsewhere in a message. Client and server implementations MUST assume that once they read a LF character, the current message has been completely received and can be processed.

Notifications MUST NOT have an id member

JSON member jsonrpc (always valued to “2.0”) MUST ALWAYS BE OMITTED

JSON member id MUST NOT be null. When member is present, mandatorily in requests and responses, it MUST be valued to an integer Number ranging from 0 to 65535. Please note that a message with "id": 0 MUST NOT be interpreted as a notification: it’s a request with identifier 0

JSON member’s names MUST NOT begin with a number.

optional params member : in case the method invocation on the receiver side requires the application of additional parameters to be executed. The type CAN be Object (with named members of different types) or Array of single type. In case of an array the parameters will be applied by their ordinal position. If the method requested for invocation on the receiver side does not require the application of additional parameters this member MUST NOT be present. The notation "params" : null IS NOT PERMITTED

optional error member : whether an error occurred during the parsing of the method or during it’s execution this member MUST be present and valued. If no errors occurred this member MUST NOT be present. For a detailed structure of the error member see below.

optional result member : This has to be set, if the corresponding request requires a result from the user. If no errors occurred by invoking the corresponding function, this member MUST be present even if one or more information are null. The type can be of Object or single type Array or Primitive string/number. If no data is meant back for the issuer (the method is void on the receiver) or an error occurred this member MUST NOT be present.

For this reason responses, we reiterate, MUST BE of two types:

success responses : no error occurred during the processing, the request was legit, syntactically correct, and the receiver had no issues processing it. This kind of responses MUST NOT have the error member and MAY have the result member if a value is expected back to the issuer.

failure responses : something wrong with the request, it’s syntax, it’s validity scope, or server processing problems. This kind of responses MUST HAVE the error member and MAY have the result member.

A notification message has the very same representation of a request with the only difference the id member MUST NOT be present. This means the issuer is not interested nor expects any response to this message. It’s up to the receiver to take actions accordingly. For instance the receiver MAY decide to execute the method, or, in case of errors or methods not allowed, drop the connection thus closing the session.

../Dataset/Raw-data/1577.xml
The field contenthash is introduced, which permits a wide range of protocols to be supported by ENS names. Resolvers supporting this field MUST return true when the supportsInterface function is called with argument 0xbc1c58d1.

The value returned by contenthash MUST be represented as a machine-readable <a href="https://github.com/multiformats/multicodec">multicodec. The format is specified as follows:

When resolving a contenthash, applications MUST use the protocol code to determine what type of address is encoded, and resolve the address appropriately for that protocol, if supported.

In order to support names that have an IPFS or Swarm hash in their content field, a grace period MUST be implemented offering those name holders time to update their names. If a resolver does not support the multihash interface, it MUST be checked whether they support the content interface. If they do, the value of that field SHOULD be treated in a context dependent fashion and resolved. This condition MUST be enforced until at least March 31st, 2019.

../Dataset/Raw-data/1616.xml
Contracts that comply with the Attribute Registry EIP MUST implement the above interface.

As an additional requirement, the ERC-165 interface MUST be included:

The implementation MUST follow the specifications described below.

The view functions detailed below MUST be implemented.

<em>NOTE</em>: This function MUST return either true or false - i.e. calling this function MUST NOT cause the caller to revert. Implementations that wish to call into another contract during execution of this function MUST catch any revert and instead return false.

<em>NOTE</em>: This function MUST return two equal values when performing two directly consecutive function calls with identical account and attributeTypeID parameters, regardless of differences in the caller’s address, the transaction origin, or other out-of-band information.

<em>NOTE</em>: This function MUST revert if a directly preceding or subsequent function call to hasAttribute with identical account and attributeTypeID parameters would return false.

<em>NOTE</em>: This function MUST return two equal values when performing two directly consecutive function calls with identical account and attributeTypeID parameters, regardless of differences in the caller’s address, the transaction origin, or other out-of-band information.

<em>NOTE</em>: This function MUST return a positive integer value - i.e. calling this function MUST NOT cause the caller to revert.

<em>NOTE</em>: This function MUST return a value that encompasses all indexes of attribute type IDs whereby a call to hasAttribute on some address with an attribute type ID at the given index would return true.

<em>NOTE</em>: This function MUST revert if the provided index value falls outside of the range of the value returned from a directly preceding or subsequent function call to countAttributeTypes. It MUST NOT revert if the provided index value falls inside said range.

<em>NOTE</em>: This function MUST return an attributeTypeID value on <em>some</em> index if the same attributeTypeID value would cause a given call to hasAttribute to return true when passed as a parameter.

   * @dev This function MUST return either true or false - i.e. calling this

   * function MUST NOT cause the caller to revert.

   * @dev This function MUST revert if a directly preceding or subsequent

   * @dev This function MUST return a positive integer value  - i.e. calling

   * this function MUST NOT cause the caller to revert.

   * @dev This function MUST revert if the provided index value falls outside

   * function call to countAttributeTypes. It MUST NOT revert if the provided

   * @dev This function MUST return either true or false - i.e. calling this

   * function MUST NOT cause the caller to revert.

   * @dev This function MUST revert if a directly preceding or subsequent

   * @dev This function MUST return a positive integer value  - i.e. calling

   * this function MUST NOT cause the caller to revert.

   * @dev This function MUST revert if the provided index value falls outside

   * function call to countAttributeTypes. It MUST NOT revert if the provided

../Dataset/Raw-data/1620.xml
MUST allow senders to create multiple streams in parallel. SHOULD not accept Ether and only use ERC20-compatible tokens.

MUST allow only the recipient to perform this action.

SHOULD allow any party to do this but MUST NOT be executed without consent from all involved parties.

MUST allow any party to do this.

MUST be triggered when create is successfully called.

MUST be triggered when withdraw is successfully called.

MUST be triggered when redeem is successfully called.

MUST be triggered when confirmUpdate is successfully called.

MUST be triggered when revokeUpdate is successfully called.

MUST be triggered when an update is approved by all involved parties.

../Dataset/Raw-data/1753.xml
Callers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!

../Dataset/Raw-data/1761.xml
        @dev MUST emit when approval changes for scope.

        @dev MUST emit when the token IDs are added to the scope.

        @dev MUST emit when the token IDs are removed from the scope.

    <span class="cm">/** @dev MUST emit when a scope URI is set or changes.

        The URI MUST point a JSON file that conforms to the "Scope Metadata JSON Schema".

        @dev MUST emit the ApprovalForScope event on success.

Metadata localization should be standardized to increase presentation uniformity across all languages. As such, a simple overlay method is proposed to enable localization. If the metadata JSON file contains a localization attribute, its content may be used to provide localized values for fields that need it. The localization attribute should be a sub-object with three attributes: uri, default and locales. If the string {locale} exists in any URI, it MUST be replaced with the chosen locale by all client software.

../Dataset/Raw-data/1767.xml
Compatible nodes MUST provide a GraphQL endpoint available over HTTP. This SHOULD be offered on port 8547 by default. The path to the GraphQL endpoint SHOULD be /graphql’.

Nodes MAY offer a superset of this schema, by adding new fields or types. Experimental or client-specific fields MUST be prefixed with <em>client</em>’ (eg, <em>geth</em>’ or <em>parity</em>’). Unprefixed fields MUST be specified in a new EIP that extends this one.

../Dataset/Raw-data/1812.xml
If the issuer is specified in the struct In addition to performing the standard ERC712 verification the verification code MUST also verify that the signing address is a valid veriKey delegate for the address specified in the issuer.

The EIP 712 Domain specifies what kind of message that is to be signed and is used to differentiate between signed data types. The content MUST contain the following:

../Dataset/Raw-data/1820.xml
:warning: <a href="/EIPS/eip-1820">ERC-1820 MUST be used in lieu of <a href="/EIPS/eip-820">ERC-820. :warning:

<span class="c1">/// @dev The interface a contract MUST implement if it is the implementer of

</span>    <span class="c1">//  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling

Below is the raw transaction which MUST be used to deploy the smart contract on any chain.

This transaction MUST NOT use <a href="/EIPS/eip-155">EIP-155 in order to work on any chain.

This transaction MUST have a relatively high gas price to be deployed on any chain. In this case, it is going to be 100 Gwei.

To deploy the registry, 0.08 ether MUST be sent to this account <em>first</em>.

            "content": "/* ERC1820 Pseudo-introspection Registry Contract\n * This standard defines a universal registry smart contract where any address (contract or regular account) can\n * register which interface it supports and which smart contract is responsible for its implementation.\n *\n * Written in 2019 by Jordi Baylina and Jacques Dafflon\n *\n * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to\n * this software to the public domain worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see\n * &lt;http://creativecommons.org/publicdomain/zero/1.0/&gt;.\n *\n *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗\n *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗\n *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║\n *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║\n *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝\n *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝\n *\n *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\n *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\n *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝\n *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝\n *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║\n *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝\n *\n */\npragma solidity 0.5.3;\n// IV is value needed to have a vanity address starting with '0x1820'.\n// IV: 53759\n\n/// @dev The interface a contract MUST implement if it is the implementer of\n/// some (other) interface for any address other than itself.\ninterface ERC1820ImplementerInterface {\n    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.\n    /// @param interfaceHash keccak256 hash of the name of the interface\n    /// @param addr Address for which the contract will implement the interface\n    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);\n}\n\n\n/// @title ERC1820 Pseudo-introspection Registry Contract\n/// @author Jordi Baylina and Jacques Dafflon\n/// @notice This contract is the official implementation of the ERC1820 Registry.\n/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820\ncontract ERC1820Registry {\n    /// @notice ERC165 Invalid ID.\n    bytes4 constant internal INVALID_ID = 0xffffffff;\n    /// @notice Method ID for the ERC165 supportsInterface method (= bytes4(keccak256('supportsInterface(bytes4)'))).\n    bytes4 constant internal ERC165ID = 0x01ffc9a7;\n    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.\n    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n\n    /// @notice mapping from addresses and interface hashes to their implementers.\n    mapping(address =&gt; mapping(bytes32 =&gt; address)) internal interfaces;\n    /// @notice mapping from addresses to their manager.\n    mapping(address =&gt; address) internal managers;\n    /// @notice flag for each address and erc165 interface to indicate if it is cached.\n    mapping(address =&gt; mapping(bytes4 =&gt; bool)) internal erc165Cached;\n\n    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.\n    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);\n    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.\n    event ManagerChanged(address indexed addr, address indexed newManager);\n\n    /// @notice Query if an address implements an interface and through which contract.\n    /// @param _addr Address being queried for the implementer of an interface.\n    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n    /// E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface.\n    /// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'\n    /// or '0' if '_addr' did not register an implementer for this interface.\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {\n        address addr = _addr == address(0) ? msg.sender : _addr;\n        if (isERC165Interface(_interfaceHash)) {\n            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);\n            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);\n        }\n        return interfaces[addr][_interfaceHash];\n    }\n\n    /// @notice Sets the contract which implements a specific interface for an address.\n    /// Only the manager defined for that address can set it.\n    /// (Each address is the manager for itself until it sets a new manager.)\n    /// @param _addr Address for which to set the interface.\n    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n    /// E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface.\n    /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {\n        address addr = _addr == address(0) ? msg.sender : _addr;\n        require(getManager(addr) == msg.sender, \"Not the manager\");\n\n        require(!isERC165Interface(_interfaceHash), \"Must not be an ERC165 hash\");\n        if (_implementer != address(0) &amp;&amp; _implementer != msg.sender) {\n            require(\n                ERC1820ImplementerInterface(_implementer)\n                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,\n                \"Does not implement the interface\"\n            );\n        }\n        interfaces[addr][_interfaceHash] = _implementer;\n        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);\n    }\n\n    /// @notice Sets '_newManager' as manager for '_addr'.\n    /// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.\n    /// @param _addr Address for which to set the new manager.\n    /// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)\n    function setManager(address _addr, address _newManager) external {\n        require(getManager(_addr) == msg.sender, \"Not the manager\");\n        managers[_addr] = _newManager == _addr ? address(0) : _newManager;\n        emit ManagerChanged(_addr, _newManager);\n    }\n\n    /// @notice Get the manager of an address.\n    /// @param _addr Address for which to return the manager.\n    /// @return Address of the manager for a given address.\n    function getManager(address _addr) public view returns(address) {\n        // By default the manager of an address is the same address\n        if (managers[_addr] == address(0)) {\n            return _addr;\n        } else {\n            return managers[_addr];\n        }\n    }\n\n    /// @notice Compute the keccak256 hash of an interface given its name.\n    /// @param _interfaceName Name of the interface.\n    /// @return The keccak256 hash of an interface name.\n    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {\n        return keccak256(abi.encodePacked(_interfaceName));\n    }\n\n    /* --- ERC165 Related Functions --- */\n    /* --- Developed in collaboration with William Entriken. --- */\n\n    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n    /// @param _contract Address of the contract for which to update the cache.\n    /// @param _interfaceId ERC165 interface for which to update the cache.\n    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {\n        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(\n            _contract, _interfaceId) ? _contract : address(0);\n        erc165Cached[_contract][_interfaceId] = true;\n    }\n\n    /// @notice Checks whether a contract implements an ERC165 interface or not.\n    //  If the result is not cached a direct lookup on the contract address is performed.\n    //  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n    //  'updateERC165Cache' with the contract address.\n    /// @param _contract Address of the contract to check.\n    /// @param _interfaceId ERC165 interface to check.\n    /// @return True if '_contract' implements '_interfaceId', false otherwise.\n    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {\n        if (!erc165Cached[_contract][_interfaceId]) {\n            return implementsERC165InterfaceNoCache(_contract, _interfaceId);\n        }\n        return interfaces[_contract][_interfaceId] == _contract;\n    }\n\n    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n    /// @param _contract Address of the contract to check.\n    /// @param _interfaceId ERC165 interface to check.\n    /// @return True if '_contract' implements '_interfaceId', false otherwise.\n    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {\n        uint256 success;\n        uint256 result;\n\n        (success, result) = noThrowCall(_contract, ERC165ID);\n        if (success == 0 || result == 0) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, INVALID_ID);\n        if (success == 0 || result != 0) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, _interfaceId);\n        if (success == 1 &amp;&amp; result == 1) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\n    /// @param _interfaceHash The hash to check.\n    /// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.\n    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {\n        return _interfaceHash &amp; 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;\n    }\n\n    /// @dev Make a call on a contract without throwing if the function does not exist.\n    function noThrowCall(address _contract, bytes4 _interfaceId)\n        internal view returns (uint256 success, uint256 result)\n    {\n        bytes4 erc165ID = ERC165ID;\n\n        assembly {\n            let x := mload(0x40)               // Find empty storage location using \"free memory pointer\"\n            mstore(x, erc165ID)                // Place signature at beginning of empty storage\n            mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature\n\n            success := staticcall(\n                30000,                         // 30k gas\n                _contract,                     // To addr\n                x,                             // Inputs are stored at location x\n                0x24,                          // Inputs are 36 (4 + 32) bytes long\n                x,                             // Store output over input (saves space)\n                0x20                           // Outputs are 32 bytes long\n            )\n\n            result := mload(x)                 // Load the result\n        }\n    }\n}\n",

If the interface is part of an approved ERC, it MUST be named ERC###XXXXX where ### is the number of the ERC and XXXXX should be the name of the interface in CamelCase.

<em>NOTE</em>: If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling updateERC165Cache with the contract address.

If a contract dynamically changes its interface and relies on the <a href="/EIPS/eip-165">ERC-165 cache of the <a href="/EIPS/eip-1820">ERC-1820 registry, the cache MUST be updated manually—there is no automatic cache invalidation or cache update.

The cache update MUST be done using the updateERC165Cache function:

Have fun but please, you MUST not conflict with the reserved designations above.

The _implementer MUST implement the ERC1820ImplementerInterface (detailed below).

Calling canImplementInterfaceForAddress on _implementer with the given _addr and _interfaceHash MUST return the ERC1820_ACCEPT_MAGIC value.

<em>NOTE</em>: The _interfaceHash MUST NOT be an <a href="/EIPS/eip-165">ERC-165 interface—it MUST NOT end with 28 zeroes (0).

Any contract being registered as the implementation of an interface for a given address MUST implement said interface.

In addition if it implements an interface on behalf of a different address, the contract MUST implement the ERC1820ImplementerInterface shown above.

If a contract implements the interface (interfaceHash) for a given address (addr), it MUST return ERC1820_ACCEPT_MAGIC when called with the addr and the interfaceHash.

If it does not implement the interfaceHash for a given address (addr), it MUST NOT return ERC1820_ACCEPT_MAGIC.

../Dataset/Raw-data/1844.xml
The address returned by interfaceImplementer MUST refer to a smart contract.

Resolvers implementing this interface MAY utilise a fallback strategy: If no matching interface was explicitly provided by the user, query the contract returned by addr(), returning its address if the requested interface is supported by that contract, and 0 otherwise. If they do this, they MUST ensure they return 0, rather than reverting, if the target contract reverts.

../Dataset/Raw-data/1901.xml
JSON-RPC APIs can support the OpenRPC specification by implementing a service discovery method that will return the <a href="https://github.com/open-rpc/spec#openrpc-document">OpenRPC document for the JSON-RPC API. The method MUST be named rpc.discover. The rpc. prefix is a reserved method prefix for <a href="https://www.jsonrpc.org/specification">JSON-RPC 2.0 Specification system extensions.

../Dataset/Raw-data/1922.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Verification Key: A trusted setup’ calculation creates both a public Proving Key’ and a public Verification Key’ from an arithmetic circuit. This interface does not provide a method for loading a Verification Key onto the blockchain. An Adhering Contract SHALL be able to accept arguments of knowledge ((proof, inputs) pairs) for at least one Verification Key. We shall call such Verification Keys in-scope’ Verification Keys. An Adhering Contract MUST be able to interpret unambiguously a unique verificationKeyId for each of its in-scope’ Verification Keys.

MUST return true if Proof passes all checks (i.e. the Proof is

MUST return false if the Proof does not pass all checks (i.e. if the

../Dataset/Raw-data/1923.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/1967.xml
Beacons are used for keeping the logic address for multiple proxies in a single location, allowing the upgrade of multiple proxies by modifying a single storage slot. A beacon contract MUST implement the function:

../Dataset/Raw-data/2003.xml
Therefore, the precompiled contracts implementation MUST NOT access the evmc_context.

../Dataset/Raw-data/2304.xml
Resolvers MUST emit this event on each change to the address for a name and coin type.

A checksum format is specified by <a href="/EIPS/eip-55">EIP-55, and extended by <a href="https://github.com/rsksmart/RSKIPs/blob/master/IPs/RSKIP60.md">RSKIP60, which specifies a means of including the chain ID in the checksum. The checksum on a text format address must be checked. Addresses with invalid checksums that are not all uppercase or all lowercase MUST be rejected with an error. Implementations may choose whether to accept non-checksummed addresses, but the authors recommend at least providing a warning to users in this situation.

When encoding an address from binary to text, an EIP55/RSKIP60 checksum MUST be used - so the correct encoding of the above address for Ethereum is 0x314159265dD8dbb310642f98f50C066173C1259b.

If the resolver supports the addr(bytes32) interface defined in EIP137, the resolver MUST treat this as a special case of this new specification in the following ways:

../Dataset/Raw-data/2309.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL

The toTokenId MUST NOT be an indexed parameter

When emitting the ConsecutiveTransfer event the Transfer event MUST NOT be emitted

Contracts that implement the ConsecutiveTransfer event MAY still use the original Transfer event, however when emitting the ConsecutiveTransfer event the Transfer event MUST NOT be emitted.

../Dataset/Raw-data/2315.xml
We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state. In practice, we must test at runtime for conditions 1 and 2 —- sufficient gas and sufficient stack. We don’t know how much gas there will be, we don’t know how deep a recursion may go, and analysis of stack depth even for non-recursive programs is nontrivial. All of the remaining conditions MUST be validated statically, in time and space quasi-linear in the size of the code.

Every instruction MUST be valid.

Every jump MUST be valid:

The RJUMP, RJUMPI, or RJUMPSUB instructions MUST NOT address immediate data.

The stacks MUST always be valid:

The number of items on the data stack MUST always be positive, and at most 1024.

The number of items on the return stackMUST always be positive, and at most 1024.

The data stack MUST be consistently aligned:

The number of items on the data stack between the current stack pointer and the stack pointer on entry to the most recent subroutine MUST be the same for each <em>execution</em> of a <em>byte_code</em>.

../Dataset/Raw-data/2334.xml
The path traversed through the tree of keys is defined by integers (which indicate the sibling index) separated by / which denote ancestor relations. There are 4 levels (plus the master node) in the path and at least 4 (5 including the master node) MUST be used.

The purpose is set to 12381 which is the name of the new curve (BLS12-381). In order to be in compliance with this standard, the <a href="/EIPS/eip-2333">EIP-2333 MUST be implemented as the KDF and therefore, the purpose 12381 MAY NOT be used unless this is the case.

../Dataset/Raw-data/2386.xml
This element MUST be present. It MUST be a string following the syntactic structure as laid out in <a href="https://tools.ietf.org/html/rfc4122#section-3">section 3 of RFC 4122.

The name provided in the walletstore is a UTF-8 string. It is intended to serve as the user-friendly accessor. The only restriction on the name is that it MUST NOT start with the underscore (_) character.

This element MUST be present. It MUST be a string.

This element MUST be present. It MUST be the integer 1.

This element MUST be present. It MUST be the string hierarchical deterministic.

This element MUST be present. It MUST be an object that follows the definition described in <a href="https://eips.ethereum.org/EIPS/eip-2335">EIP-2335.

This element MUST be present if the wallet type requires it. It MUST be a non-negative integer.

../Dataset/Raw-data/2470.xml
Below is the raw transaction which MUST be used to deploy the smart contract on any chain.

This transaction MUST NOT use <a href="/EIPS/eip-155">EIP-155 in order to work on any chain.

This transaction MUST have a relatively high gas price to be deployed on any chain. In this case, it is going to be 100 Gwei.

To deploy the registry, 0.0247 ether MUST be sent to this account <em>first</em>.

Contracts that are constructed by the SingletonFactory MUST not use msg.sender in their constructor, all variables must came through initialization data. This is intentional, as if allowing a callback after creation to aid initialization state would lead to contracts with same address (but different chains) to have the same address but different initial state.

../Dataset/Raw-data/2477.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Smart contracts implementing the ERC-2477 standard MUST implement the ERC2477 interface.

Smart contracts implementing the ERC-2477 standard MUST implement the ERC-165 standard, including the interface identifiers above.

A client implementing the ERC-2477 standard MUST support at least the sha256 hash algorithm and MAY support other algorithms.

../Dataset/Raw-data/2535.xml
In ALL cases any function or code that adds or replaces or removes one or more functions MUST emit the standard DiamondCut event specified below.

Any time one or more functions are added, replaced or removed the DiamondCut event MUST be emitted to record changes.

../Dataset/Raw-data/2539.xml
This precompile performs extensive computations and in case of any errors during execution it MUST consume all gas from the the gas schedule for the corresponding operation.

../Dataset/Raw-data/2544.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

If a resolver implements this function, it MUST return true when supportsInterface() is called on it with the interface’s ID, 0xTBD.

ENS clients will call resolve with the DNS-encoded name to resolve and the encoded calldata for a resolver function (as specified in EIP-137 and elsewhere); the function MUST either return valid return data for that function, or revert if it is not supported.

EIP-2544-compliant ENS clients MUST perform the following procedure when determining the resolver for a given name:

If the procedure above returns null, name resolution MUST terminate unsuccessfully. Otherwise, EIP-2544-compliant ENS clients MUST perform the following procedure when resolving a record:

../Dataset/Raw-data/2569.xml
An EIP-2569 compatible contract MUST have a method with the signature getTokenImageSvg(uint256) view returns (string memory) and a method with the signature setTokenImageSvg(uint256 tokenId, string memory imagesvg) internal.

../Dataset/Raw-data/2678.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,

../Dataset/Raw-data/2680.xml
For other hierarchical stores, for example Amazon S3, the base location MUST be the lower-case hex string representing the <a href="/assets/eip-2680/sha256-384-512.pdf">SHA-256 hash of the string “Ethereum 2 wallet:” appended with the identifier for the hierarchical store. For example, if the account ID for a user’s Amazon S3 account is “AbC0438EB” then:

The wallet container is identified by the wallet’s UUID. It MUST be a string following the syntactic structure as laid out in <a href="https://tools.ietf.org/html/rfc4122#section-3">section 3 of RFC 4122.

The walletstore element contains the walletstore and is held within the wallet container. It is identified by the wallet’s UUID. It MUST be a string following the syntactic structure as laid out in <a href="https://tools.ietf.org/html/rfc4122#section-3">section 3 of RFC 4122.

The keystore element contains the keystore for a given key and is held within the wallet container. It is identified by the key’s UUID. It MUST be a string following the syntactic structure as laid out in <a href="https://tools.ietf.org/html/rfc4122#section-3">section 3 of RFC 4122.

An implementer MAY include an index in the base location. If so then it MUST follow the structure as specified in the following “Index format” section.

An implementer MAY include an index within a wallet container for accounts within that wallet. If so then it MUST follow the structure as specified in the following “Index format” section.

The index MUST use the identifier index’.

../Dataset/Raw-data/2696.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119.

../Dataset/Raw-data/2700.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119.

../Dataset/Raw-data/2718.xml
<a href="#should-instead-of-must-for-the-transactiontype-being-first-byte-of-signed-data">SHOULD instead of MUST for the TransactionType being first byte of signed data

../Dataset/Raw-data/2770.xml
Request struct MUST contain the following fields in this exact order:

Registration MUST be performed in advance by a call to the following method:

../Dataset/Raw-data/2771.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,

and MUST append the address of the Transaction Signer (20 bytes of data) to

The Recipient MUST check that it trusts the Forwarder to prevent it from

To provide this discovery mechanism a Recipient contract MUST implement

That function MUST return true if the forwarder is trusted by the

That function MUST return false if the forwarder is not trusted.

That function MUST NOT throw a revert.

Internally, the Recipient MUST then accept a request from forwarder

../Dataset/Raw-data/2831.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119.

../Dataset/Raw-data/2848.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119 when, and only when, they appear in all capitals as shown here.

Clients MUST assume that invalid MOM transactions don’t exist. If a transaction does not strictly follow the MOM standard, clients MUST ignore it and they MUST NOT consider it a MOM transaction at all.

<td>Clients MUST add the message with motivations to the message list and they MUST NOT consider MOM messages sent by that address to be valid anymore, ever. In other words, MOM clients MUST ignore any other transaction sent by that address while creating the message list. This is useful when users want to change account, for example because the private key seems compromised.</td>

<td>The parameter MUST be at least 1 byte. Content type is not disclosed and it MUST NOT be considered as text/markdown.</td>

<td>Clients MUST add the message to the message list but they MUST NOT try to decode the content. Clients SHOULD allow users to see this message only if explicitly asked for. This operation can be used for <em>blind</em> notarization that general client can ignore.</td>

../Dataset/Raw-data/2876.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The contract MUST revert if sent a transaction where msg.data is null (A pure value transaction).

The contract MUST have a deposit function as follows:

deposit(bytes8) MUST return false when the contract needs to keep the value, but signal to the depositor that the deposit (in terms of the parent application) itself has not yet succeeded. (This can be used for partial payment, ie. the invoice is for 5 ETH, sending 3 ETH returns false, but sending a second tx with 2 ETH will return true.)

deposit(bytes8) MUST revert if the deposit somehow failed and the contract does not need to keep the value sent.

deposit(bytes8) MUST return true if the value will be kept and the payment is logically considered complete by the parent application (exchange/merchant).

The wallet MUST accept the deposit address format anywhere the 20-byte address format is accepted for transaction destination.

The wallet MUST verify the 3 byte checksum and fail if the checksum doesn’t match.

The wallet MUST fail if the destination address is the deposit address format and the data field is set to anything besides null.

The wallet MUST set the to field of the underlying transaction to the first 20 bytes of the deposit address format, and set the data field to 0x3ef8e69aNNNNNNNNNNNNNNNN000000000000000000000000000000000000000000000000 where NNNNNNNNNNNNNNNN is the last 8 bytes of the deposit address format. (ie. if the deposit address format is set to 0x433e064c42e87325fb6ffa9575a34862e0052f26913fd924f056cd15 then the to field is 0x433e064c42e87325fb6ffa9575a34862e0052f26 and the data field is 0x3ef8e69a913fd924f056cd15000000000000000000000000000000000000000000000000)

../Dataset/Raw-data/2976.xml
Clients MUST NOT send new transaction types before they believe the fork block is reached.

Clients MUST NOT send transactions of a new TransactionType until that transaction type’s introductory fork block.

../Dataset/Raw-data/2980.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Every ERC-2980 compliant contract MUST implement the ERC-2980 interface.

The ERC-2980 extends <a href="/EIPS/eip-20">ERC-20. Due to the indivisible nature of asset tokens, the decimals number MUST be zero.

Revoke and Reassign methods allow Issuers to move tokens from addresses, even if they are in the Frozenlist. The Revoke method transfers the entire balance of the target address to the Issuer who invoked the method. The Reassign method transfers the entire balance of the target address to another address. These rights for these operations MUST be allowed only to Issuers.

The token MAY implement decimals() for backward compatibility with ERC-20. If implemented, it MUST always return 0.

../Dataset/Raw-data/2981.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL

The royaltyInfo() function is not aware of the unit of exchange for the sale and royalty payment. With that in mind, implementers MUST NOT return a fixed/constant royaltyAmount, wherein they’re ignoring the _salePrice. For the same reason, implementers MUST NOT determine the royaltyAmount based on comparing the _salePrice with constant numbers. In both cases, the royaltyInfo() function makes assumptions on the unit of exchange, which MUST be avoided.

../Dataset/Raw-data/3000.xml
     * should be a MUST payload.executor.exec(payload.actions)

     * @dev OPTIONAL: implementer might choose not to implement (initial Configured event MUST be emitted)

../Dataset/Raw-data/3005.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The key words “MUST (BUT WE KNOW YOU WON’T)”, “SHOULD CONSIDER”, “REALLY SHOULD NOT”, “OUGHT TO”, “WOULD PROBABLY”, “MAY WISH TO”, “COULD”, “POSSIBLE”, and “MIGHT” in this document are to be interpreted as described in RFC 6919.

In order to successfully validate and transfer tokens, the processMetaBatch() function MUST process the following data about a meta transaction:

The processMetaBatch() function MUST receive the following data:

The created hash MUST then be signed with the sender’s private key.

Nonce of a new transaction MUST always be bigger by exactly 1 from the nonce of the last successfully processed meta transaction of the same sender to the same token contract.

Sending to and from a 0x0 address MUST be prohibited.

A meta transaction MUST be processed before the expiration date.

Each sender’s token balance MUST be equal or greater than the sum of their respective meta transaction token amount and relayer fee.

A transaction where at least one meta transaction in the batch does not satisfy the above requirements MUST not be reverted. Instead, a failed meta transaction MUST be skipped or ignored.

The processMetaBatch() function MUST have the following interface:

Each entry in each of the arrays MUST represent data from one meta transaction. The order of the data is very important. Data from a single meta transaction MUST have the same index in every array.

After a meta transaction is successfully validated, the meta nonce of the meta transaction sender MUST be increased by 1.

Then two token transfers MUST occur:

The specified token amount MUST go to the recipient.

The relayer fee MUST go to the relayer (msg.sender).

../Dataset/Raw-data/3041.xml
Every block returned by this endpoint whose block number is before the <a href="/EIPS/eip-1559">EIP-1559 fork block MUST NOT include a baseFee field.

../Dataset/Raw-data/3044.xml
Every block returned by this endpoint whose block number is before the <a href="/EIPS/eip-1559">EIP-1559 fork block MUST NOT include a baseFee field.

../Dataset/Raw-data/3045.xml
Every block returned by this endpoint whose block number is before the <a href="/EIPS/eip-1559">EIP-1559 fork block MUST NOT include a baseFee field.

../Dataset/Raw-data/3046.xml
Every block returned by this endpoint whose block number is before the <a href="/EIPS/eip-1559">EIP-1559 fork block MUST NOT include a baseFee field.

../Dataset/Raw-data/3074.xml
An important note is that invoker contracts MUST NOT be upgradeable. If an invoker can be redeployed to the same address with different code, it would be possible to redeploy the invoker with code that does not properly verify commit and any account that signed a message over that invoker would be compromised. Although this sounds scary, it is no different than using a smart contract wallet via DELEGATECALL. If the wallet is redeployed with different logic, all wallets using its code could be compromised.

../Dataset/Raw-data/3076.xml
You MUST ensure that, in addition to importing all of the messages from an interchange, all the <a href="#conditions">conditions are enforced. In particular, conditions (2), (4) and (5) may not have been enforced by your implementation before adopting the interchange format. Our recommendation is to enforce these rules at all times, to keep the implementation clean and minimise the attack surface. For example: your slashing protection mechanism should not sign a block with a slot number less than, or equal to, the minimum slot number of a previously signed block, <em>irrespective</em> of whether that minimum-slot block was imported from an interchange file, or inserted as part of your database’s regular operation.

../Dataset/Raw-data/3085.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119.

The wallet MUST NOT allow the same chainId to be added multiple times.

../Dataset/Raw-data/3155.xml
The CUT MUST output a json object for EACH operation.

All array attributes (stack, returnStack, memory) MUST be initialized to empty arrays (“stack”:[],) NOT to null.

The memSize field MUST be present regardless of memory support.

The CUT MUST NOT output a line for the STOP operation if an error occurred:

At the end of execution, the CUT MUST print some summerical info, this info SHOULD have the following fields.

../Dataset/Raw-data/3156.xml
A lender MUST implement the IERC3156FlashLender interface.

The maxFlashLoan function MUST return the maximum loan possible for token. If a token is not currently supported maxFlashLoan MUST return 0, instead of reverting.

The flashFee function MUST return the fee charged for a loan of amount token. If the token is not supported flashFee MUST revert.

The flashLoan function MUST include a callback to the onFlashLoan function in a IERC3156FlashBorrower contract.

The flashLoan function MUST transfer amount of token to receiver before the callback to the receiver.

The flashLoan function MUST include msg.sender as the initiator to onFlashLoan.

The flashLoan function MUST NOT modify the token, amount and data parameter received, and MUST pass them on to onFlashLoan.

The flashLoan function MUST include a fee argument to onFlashLoan with the fee to pay for the loan on top of the principal, ensuring that fee == flashFee(token, amount).

The lender MUST verify that the onFlashLoan callback returns the keccak256 hash of “ERC3156FlashBorrower.onFlashLoan”.

After the callback, the flashLoan function MUST take the amount + fee token from the receiver, or revert if this is not successful.

If successful, flashLoan MUST return true.

A receiver of flash loans MUST implement the IERC3156FlashBorrower interface:

For the transaction to not revert, receiver MUST approve amount + fee of token to be taken by msg.sender before the end of onFlashLoan.

If successful, onFlashLoan MUST return the keccak256 hash of “ERC3156FlashBorrower.onFlashLoan”.

../Dataset/Raw-data/3234.xml
A lender MUST implement the IERC3234BatchFlashLender interface.

The maxFlashLoan function MUST return the maximum loan possible for each token. If a token is not currently supported maxFlashLoan MUST return 0, instead of reverting.

The flashFee function MUST return the fees charged for each loan of amount token. If a token is not supported flashFee MUST revert.

The batchFlashLoan function MUST include a callback to the onBatchFlashLoan function in a IERC3234BatchFlashBorrower contract.

The batchFlashLoan function MUST transfer amounts[i] of each tokens[i] to receiver before the callback to the borrower.

The batchFlashLoan function MUST include msg.sender as the initiator to onBatchFlashLoan.

The batchFlashLoan function MUST NOT modify the tokens, amounts and data parameters received, and MUST pass them on to onBatchFlashLoan.

The lender MUST verify that the onBatchFlashLoan callback returns the keccak256 hash of “ERC3234BatchFlashBorrower.onBatchFlashLoan”.

The batchFlashLoan function MUST include a fees argument to onBatchFlashLoan with the fee to pay for each individual token and amount lent, ensuring that fees[i] == flashFee(tokens[i], amounts[i]).

After the callback, for each token in tokens, the batchFlashLoan function MUST take the amounts[i] + fees[i] of tokens[i] from the receiver, or revert if this is not successful.

If successful, batchFlashLoan MUST return true.

A receiver of flash loans MUST implement the IERC3234BatchFlashBorrower interface:

For the transaction to not revert, for each token in tokens, receiver MUST approve amounts[i] + fees[i] of tokens[i] to be taken by msg.sender before the end of onBatchFlashLoan.

If successful, onBatchFlashLoan MUST return the keccak256 hash of “ERC3156BatchFlashBorrower.onBatchFlashLoan”.

../Dataset/Raw-data/3326.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC-2119.

../Dataset/Raw-data/3386.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in <a href="https://www.ietf.org/rfc/rfc2119.txt">RFC 2119.

    @dev All parameters named _amount, _amounts refer to the value parameters in ERC-1155. When using this interface with ERC-721, _amount MUST be 1, and _amounts MUST be either an empty list or a list of 1 with the same length as _ids.

     * @dev MUST emit when a mint occurs where a single {Base} token is received by the {Pool}.

     * The _from argument MUST be the address of the account that sent the {Base} token.

     * The _to argument MUST be the address of the account that received the {Derivative} token(s).

     * The _id argument MUST be the id of the {Base} token transferred.

     * The _amount argument MUST be the number of {Base} tokens transferred.

     * The _value argument MUST be the number of {Derivative} tokens minted.

     * @dev MUST emit when a mint occurs where multiple {Base} tokens are received by the {Wrapper}.

     * The _from argument MUST be the address of the account that sent the {Base} tokens.

     * The _to argument MUST be the address of the account that received the {Derivative} token(s).

     * The _ids argument MUST be the list ids of the {Base} tokens transferred.

     * The _amounts argument MUST be the list of the numbers of {Base} tokens transferred.

     * The _value argument MUST be the number of {Derivative} tokens minted.

     * @dev MUST emit when a burn occurs where a single {Base} token is sent by the {Wrapper}.

     * The _from argument MUST be the address of the account that sent the {Derivative} token(s).

     * The _to argument MUST be the address of the account that received the {Base} token.

     * The _id argument MUST be the id of the {Base} token transferred.

     * The _amount argument MUST be the number of {Base} tokens transferred.

     * The _value argument MUST be the number of {Derivative} tokens burned.

     * @dev MUST emit when a mint occurs where multiple {Base} tokens are sent by the {Wrapper}.

     * The _from argument MUST be the address of the account that sent the {Derivative} token(s).

     * The _to argument MUST be the address of the account that received the {Base} tokens.

     * The _ids argument MUST be the list of ids of the {Base} tokens transferred.

     * The _amounts argument MUST be the list of the numbers of {Base} tokens transferred.

     * The _value argument MUST be the number of {Derivative} tokens burned.

Minting requires the transfer of the {Base} tokens into the {Pool} in exchange for {Derivative} tokens. The {Base} tokens deposited in this way MUST NOT be transferred again except through the burning functions. This ensures the value of the {Derivative} tokens is representative of the value of the {Base} tokens.

Prices should not be necessarily fixed. therefore, Mint/Burn events MUST include the ERC-20 _value minted/burned.

Due to the variety of pricing implementations, the Mint* and Burn* events MUST include the number {Derivative} tokens minted/burned.

If the {Wrapper} does not inherit from {ERC20}, the {Derivative} contract MUST be limited such that the {Wrapper} has the sole power to mint, burn, and otherwise change the supply of tokens.

If not inheriting from {ERC721Receiver} and/or {ERC1155Receiver}, the pool MUST be limited such that the base tokens can only be transferred via the Wrapper’s mint, burn.

All parameters named _amount, MUST be 1.

All parameters named _amounts MUST be either an empty list or a list of 1 with the same length as _ids.

If the {Wrapper} does not inherit from {ERC721} or {ERC1155}, it MUST include calls to {IERC721} and {IERC1155} in order to transfer {Base} tokens.

Wrapper contracts are RECOMMENDED to inherit from burnable ERC-20 tokens. If they are not, the supply of the {Derivative} tokens MUST be controlled by the Wrapper. Similarly, price implementations MUST ensure that the supply of {Base} tokens is reflected by the {Derivative} tokens.

../Dataset/Raw-data/3440.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Implementations of ERC-3440 MUST designate which token Id is the original NFT (defaulted to Id 0), and which token Id is a unique replica. The original print SHOULD be token Id number 0 but MAY be assigned to a different Id. The original print MUST only be designated once. The implementation MUST designate a maximum number of minted editions, after which new Ids MUST NOT be printed / minted.

Signature messages MUST use the <a href="https://eips.ethereum.org/EIPS/eip-712">EIP-712 standard.

../Dataset/Raw-data/3475.xml
* @dev transferFrom MUST have the isApprovedFor(_from, _to, _transaction[i].classId) approval to transfer _from address to _to address for given classId (for all transaction in the array structure).

* @dev transferAllowanceFrom MUST have the allowance(_from, msg.sender, _transactions[i].classId, _transactions[i].nonceId)

* @dev it MUST be issued by a single entity (for instance, a role-based ownable contract that has integration with the liquidity pool of the deposited collateral by _to address).

* @dev transferAllowanceFrom MUST have the allowance(_from, msg.sender, _transactions[i].classId, _transactions[i].nonceId)

* @dev redeem function for a given class, and nonce category MUST BE done after certain conditions for maturity (can be end time, total active liquidity, etc.) are met.

* @dev burn function for given class and nonce MUST BE called by only the controller contract.

* @dev redeem function for a given class, and nonce category MUST BE done only after certain conditions for maturity (can be end time, total active liquidity, etc).

* @dev contract MUST define internal function regarding the conditions for setting approval and should be callable only by bank or owner.

* @notice Issue MUST trigger when Bonds are issued. This SHOULD not include zero value Issuing.

* @dev Issue MUST be triggered when the operator (i.e Bank address) contract issues bonds to the given entity.

* @notice Redeem MUST trigger when Bonds are redeemed. This SHOULD not include zero value redemption.

* @dev Burn MUST trigger when the bonds are being redeemed via staking (or being invalidated) by the bank contract.

* @dev Burn MUST trigger when Bonds are burned. This SHOULD not include zero value burning.

* @dev Transfer MUST trigger when Bonds are transferred. This SHOULD not include zero value transfers.

* @dev Transfer event with the _from 0x0 MUST not create this event(use event Issued instead).

* @notice Approval MUST trigger when bond-holders are approving an _operator. This SHOULD not include zero value approval.

To ensure the reading of transactions, “Issue”, “Redeem”, “Burn” and “Transfer”, Events cited above MUST be emitted when such transaction is passed.

../Dataset/Raw-data/3525.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

     * @dev MUST emit when value of a token is transferred to another token with the same slot,

     * @dev MUST emit when the approval value of a token is set or changed.

     * @dev MUST emit when the slot of a token is set or changed.

     * @dev MUST revert unless caller is the current owner, an authorized operator, or the approved

     *  MUST emit the ApprovalValue event.

     * @dev Caller MUST be the current owner, an authorized operator or an operator who has been

     *  MUST revert if _fromTokenId or _toTokenId is zero token id or does not exist.

     *  MUST revert if slots of _fromTokenId and _toTokenId do not match.

     *  MUST revert if _value exceeds the balance of _fromTokenId or its allowance to the

     *  MUST emit TransferValue event.

     * @dev This function MUST create a new EIP-3525 token with the same slot for _to,

     *  MUST revert if _fromTokenId is zero token id or does not exist.

     *  MUST revert if _to is zero address.

     *  MUST revert if _value exceeds the balance of _fromTokenId or its allowance to the

     *  MUST emit Transfer and TransferValue events.

     * @dev MUST emit when an operator is approved or disapproved to manage all of _owner's

     *  MUST emit ApprovalSlot event.

     * @dev An EIP-3525 smart contract MUST check whether this function is implemented by the recipient contract, if the

     *  recipient contract implements this function, the EIP-3525 contract MUST call this function after a

     *  MUST return 0x009ce20b (i.e. bytes4(keccak256('onERC3525Received(address,uint256,uint256,

     *  MUST revert or return any value other than 0x009ce20b if the transfer is rejected.

For any approving function, the caller MUST be the owner or has been approved with a higher level of authority.

MUST revert unless msg.sender is the owner of _fromTokenId, an authorized operator or an operator who has been approved the whole token or at least _value of it.

MUST revert if _fromTokenId or _toTokenId is zero token id or does not exist.

MUST revert if slots of _fromTokenId and _toTokenId do not match.

MUST revert if _value exceeds the value of _fromTokenId or its allowance to the operator.

MUST check for the onERC3525Received function if the owner of _toTokenId is a smart contract, if the function exists, MUST call this function after the value transfer, MUST revert if the result is not equal to 0x009ce20b;

MUST emit TransferValue event.

MUST either find a EIP-3525 token owned by the address _to or create a new EIP-3525 token, with the same slot of _fromTokenId, to receive the transferred value.

MUST revert unless msg.sender is the owner of _fromTokenId, an authorized operator or an operator who has been approved the whole token or at least _value of it.

MUST revert if _fromTokenId is zero token id or does not exist.

MUST revert if _to is zero address.

MUST revert if _value exceeds the value of _fromTokenId or its allowance to the operator.

MUST check for the onERC3525Received function if the _to address is a smart contract, if the function exists, MUST call this function after the value transfer, MUST revert if the result is not equal to 0x009ce20b;

MUST emit Transfer and TransferValue events.

All EIP-3525 contracts need to MUST check for the existence of onERC3525Received on the recipient contract and call the function when it exists;

../Dataset/Raw-data/3540.xml
version MUST NOT be 0.[^1](#EOF-version-range-start-with-1)

section_kind MUST NOT be 0. The value 0 is reserved for <em>section headers terminator byte</em>.

section_size MUST NOT be 0. If a section is empty its section header MUST be omitted.

There MUST be at least one section (and therefore section header).

Section data size MUST be equal to section_size declared in its header.

Stray bytes outside of sections MUST NOT be present. This includes trailing bytes after the last section.

Exactly one code section MUST be present.

The code section MUST be the first section.

../Dataset/Raw-data/3569.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

      values MUST be the same.

      been sealed then this function MUST throw.

      - This function MUST emit the Sealed event

      - This function MUST throw if the token ID does not exist, or is not sealed

The sealed metadata JSON file MAY contain metadata for many different tokens. The top level keys of the JSON object MUST be token IDs.

../Dataset/Raw-data/3589.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

mint and safeMint assemble assets into one ERC-721 token. mint SHOULD be implemented for normal ERC-20 tokens whose _transfer is lossless. safeMint MUST takes care for lossy token such as PIG token whose _transfer function is taxed.

_salt of hash function MAY be implemented other way, even provided as user input. But the token id MUST be generated by hash function.

Implementers of this standard MUST have all of the following functions:

../Dataset/Raw-data/3607.xml
Any transaction where tx.sender has a CODEHASH != EMPTYCODEHASH MUST be rejected as invalid, where EMPTYCODEHASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470.

The invalid transaction MUST be rejected by the client and not be included in a block.

A block containing such a transaction MUST be considered invalid.

../Dataset/Raw-data/3668.xml
A CCIP read enabled contract MUST revert with the following error whenever a function that requires offchain data is called:

urls specifies a list of URL templates to services (known as gateways) that implement the CCIP read protocol and can formulate an answer to the query. urls can be the empty list [], in which case the client MUST specify the URL template. The order in which URLs are tried is up to the client, but contracts SHOULD return them in order of priority, with the most important entry first.

extraData is additional data that is required by the callback, and MUST be retained by the client and provided unmodified to the callback function. This value is opaque to the client.

The contract MUST also implement a callback method for decoding and validating the data returned by the gateway. The name of this method is implementation-specific, but it MUST have the signature (bytes response, bytes extraData), and MUST have the same return type as the function that reverted with OffchainLookup.

When a CCIP-aware contract wishes to make a call to another contract, and the possibility exists that the callee may implement CCIP read, the calling contract MUST catch all OffchainLookup errors thrown by the callee, and revert with a different error if the sender field of the error does not match the callee address.

Where the possibility exists that a callee implements CCIP read, a CCIP-aware contract MUST NOT allow the default solidity behaviour of bubbling up reverts from nested calls. This is to prevent the following situation:

If the URL template contains the {data} substitution parameter, the client MUST send a GET request after replacing the substitution parameters as described above.

If the URL template does not contain the {data} substitution parameter, the client MUST send a POST request after replacing the substitution parameters as described above. The POST request MUST be sent with a Content-Type of application/json, and a payload matching the following schema:

Compliant gateways MUST respond with a Content-Type of application/json, with the body adhering to the following JSON schema:

Unsuccessful requests MUST return the appropriate HTTP status code - for example, 404 if the sender address is not supported by this gateway, 400 if the callData is in an invalid format, 500 if the server encountered an internal error, and so forth. If the Content-Type of a 4xx or 5xx response is application/json, it MUST adhere to the following JSON schema:

Clients MUST support both GET and POST requests. Gateways may implement either or both as needed.

A client that supports CCIP read MUST make contract calls using the following process:

Clients MUST handle HTTP status codes appropriately, employing best practices for error reporting and retries.

Clients MUST handle HTTP 4xx and 5xx error responses that have a content type other than application/json appropriately; they MUST NOT attempt to parse the response body as JSON.

This protocol can result in multiple lookups being requested by the same contract. Clients MUST implement a limit on the number of lookups they permit for a single contract call, and this limit SHOULD be at least 4.

In order to prevent a malicious gateway from causing unintended side-effects or faulty results, contracts MUST include sufficient information in the extraData argument to allow them to verify the relevance and validity of the gateway’s response. For example, if the contract is requesting information based on an address supplied to the original call, it MUST include that address in the extraData so that the callback can verify the gateway is not providing the answer to a different query.

In order to prevent a malicious client from causing unintended effects when making transactions using CCIP read, contracts MUST implement appropriate checks on the extraData returned to them in the callback. Any sanity/permission checks performed on input data for the initial call MUST be repeated on the data passed through the extraData field in the callback. For example, if a transaction should only be executable by an authorised account, that authorisation check MUST be done in the callback; it is not sufficient to perform it with the initial call and embed the authorised address in the extraData.

../Dataset/Raw-data/3670.xml
This feature is introduced on the very same block EIP-3540 is enabled, therefore every EOF1-compatible bytecode MUST be validated according to these rules.

../Dataset/Raw-data/3675.xml
<em>Note</em>: If TERMINAL_BLOCK_HASH is stubbed with 0x0000000000000000000000000000000000000000000000000000000000000000 then TERMINAL_BLOCK_HASH and TERMINAL_BLOCK_NUMBER parameters MUST NOT take an effect.

PoW blocks that are descendants of any terminal PoW block MUST NOT be imported. This implies that a terminal PoW block will be the last PoW block in the canonical chain.

<em>Note</em>: This rule MUST be strictly enforced. “Optimistic” updates to the head MUST NOT be made. That is – if a new block is processed on top of the current head block, this new block becomes the new head if and only if an accompanying POS_FORKCHOICE_UPDATED event occurs.

../Dataset/Raw-data/3690.xml
This feature is introduced on the very same block EIP-3540 is enabled, therefore every EOF1-compatible bytecode MUST have a JUMPDEST-table if it uses jumps.

The jumpdests section MUST be present if and only if the code section contains JUMP or JUMPI opcodes.

If the jumpdests section is present it MUST directly precede the code section. In this case a valid EOF bytecode will have the form of format, magic, version, [jumpdests_section_header], code_section_header, [data_section_header], 0, [jumpdests_section_contents], code_section_contents, [data_section_contents].

With an exception of the first entry, the value of jumploc MUST NOT be 0.

Every jumploc MUST point to a valid opcode. They MUST NOT point into PUSH-data or outside of the code section.

When executing JUMP or JUMPI instructions, the jump destination MUST be in the jumpdests table. Otherwise, the execution aborts with <em>bad jump destination</em>. In case of JUMPI, the check is done only when the jump is to be taken (no change to the previous behaviour).

../Dataset/Raw-data/3770.xml
shortName is mandatory and MUST be a valid short name from ethereum-lists/chains

address is mandatory and MUST be a EIP-55 compatible hexadecimal address

../Dataset/Raw-data/4361.xml
The message MUST incorporate an Ethereum address, domain requesting the signing, version of the message, a chain identifier chain-id, uri for scoping, nonce acceptable to the relying party, and issued-at timestamp.

version is the current version of the message, which MUST be 1 for this specification.

chain-id is the <a href="/EIPS/eip-155">EIP-155 Chain ID to which the session is bound, and the network where Contract Accounts MUST be resolved.

The message MUST conform with the following Augmented Backus–Naur Form (ABNF, RFC 5234) expression (note that %s denotes case sensitivity for a string term, as per RFC 7405).

For Externally Owned Accounts (EOAs), the verification method specified in <a href="/EIPS/eip-191">EIP-191 MUST be used.

The verification method specified in <a href="/EIPS/eip-1271">EIP-1271 SHOULD be used, and if it is not, the implementer MUST clearly define the verification method to attain security and interoperability for both wallets and relying parties.

When performing <a href="/EIPS/eip-1271">EIP-1271 signature verification, the contract performing the verification MUST be resolved from the specified chain-id.

The message MUST be checked for conformance to the ABNF above, checked against expected term values after parsing, and its signature MUST be verified.

Sessions MUST be bound to the address and not to further resolved resources that can change.

The listed resources MUST be RFC 3986 URIs, but their interpretation is out of scope of this specification.

The full message MUST be checked for conformance to the ABNF above.

Wallet implementers MUST prevent phishing attacks by matching on the domain term when processing a signing request. For example, when processing the message beginning with "service.invalid wants you to sign in...", the wallet checks that the request actually originated from service.invalid.

Wallet implementers MUST display to the user the following terms from the Sign-In with Ethereum signing request by default and prior to signing, if they are present: domain, address, statement, and resources. Other present terms MUST also be made available to the user prior to signing either by default or through an extended interface.

Both the wallet and relying party have to implement this specification for improved security to the end user. Specifically, the wallet MUST confirm that the message is for the correct domain or provide the user means to do so manually (such as instructions to visually confirming the correct domain in a TLS-protected website prior to connecting via QR code or deeplink), otherwise the user is subject to phishing attacks.

Wallets MUST check that the domain matches the actual signing request source.

../Dataset/Raw-data/4393.xml
Smart contracts implementing this EIP standard MUST implement all of the functions in this EIP interface. MUST also emit the events specified in the interface so that a complete state of the tip token contract can be derived from the events emitted alone.

Smart contracts implementing this EIP standard MUST implement the ERC-165 supportsInterface function and MUST return the constant value true if 0xE47A7022 is passed through the interfaceID argument. Note that revert in this document MAY mean a require, throw (not recommended as depreciated) or revert solidity statement with or without error messages.

        @dev MUST revert if calling nft's supportsInterface does not return

        MUST revert if any of the 'holders' is the zero address.

        MUST revert if 'nft' has not approved the tip token contract address.

        MUST emit the 'ApprovalForNFT' event to reflect approval or not approval

        @dev If 'nft' has not been approved for tipping, MUST revert

        MUST revert if 'nft' is zero address.

        MUST burn the tip 'amount' to the 'holder' and send the reward to

        MUST receive tip amount in proportion of their balance of multi tokens

        MUST emit the 'Tip' event to reflect the amounts that msg.sender tipped

        MUST revert if the input arguments lengths are not all the same

        MUST revert if any of the user addresses are zero

        MUST revert the whole batch if there are any errors

        MUST emit the 'Tip' events so that the state of the amounts sent to

        Each tip token contract MUST handle only one type of ERC-20 compatible

        MUST emit the 'Deposit' event that shows the user, deposited token details

        @dev MUST revert if not enough balance pending available to withdraw.

        MUST send 'amount' to msg.sender account (the holder)

        MUST reduce the balance of reward tokens pending by the 'amount' withdrawn.

        MUST emit the 'WithdrawReward' event to show the holder who withdrew, the reward

        @notice MUST have identical behaviour to ERC-20 balanceOf and is the amount

Whenever a user sends a tip, an equivalent value of deposited ERC-20 MUST be transferred to a pending account for the NFT or multi token holder, and the tip tokens sent MUST be burnt. This equivalent value is calculated using a simple formula:

If not inheriting from ERC-20, then minting the tip tokens MUST emit event Transfer(address indexed from, address indexed to, uint256 value) where sender is the zero address for a mint and to is the zero address for a burn. The Transfer event MUST be the same signature as the Transfer function in the IERC20 interface.

To keep the ITipToken interface simple and general purpose, each tip token contract MUST use one ERC-20 compatible deposit type at a time. If tipping is required to support many ERC-20 deposits then each tip token contract MUST be deployed separately per ERC-20 compatible type required. Thus, if tipping is required from both ETH and BTC wrapper ERC-20 deposits then the tip token contract is deployed twice. The tip token contract’s constructor is REQUIRED to pass in the address of the ERC-20 token supported for the deposits for the particular tip token contract. Or in the case for upgradeable tip token contracts, an initialize method is REQUIRED to pass in the ERC-20 token address.

This EIP does not provide details for where the ERC-20 reward deposits are held. It MUST be available at the time a holder withdraws the rewards that they are owed. A RECOMMENDED implementation would be to keep the deposits locked in the tip token contract address. By keeping a mapping structure that records the balances pending to holders then the

Clever ways to minimise on-chain state updating of the deposit balances for each user and the reward balances of each holder, can help further to minimise the gas costs when sending in a batch if the batch is ordered beforehand. For example, can avoid the checks if the next NFT in the batch is the same. This left to the tip token contract implementer. Whatever optimisation is applied, it MUST still allow information of which account tipped which account and for what NFT to be reconstructed from the Tip and the TipBatch events emitted.

As the Ethereum ecosystem continues to grow, many dapps are relying on traditional databases and explorer API services to retrieve and categorize data. This EIP standard guarantees that event logs emitted by the smart contract MUST provide enough data to create an accurate record of all current tip token and ERC-20 reward balances. A database or explorer can provide indexed and categorized searches of every tip token and reward sent to NFT holders from the events emitted by any tip token contract that implements this standard. Thus, the state of the tip token contract can be reconstructed from the events emitted alone.

A tip token contract can be fully compatible with ERC-20 specification and inherit some functions such as transfer if the tokens are allowed to be sent directly to other users. Note that balanceOf has been adopted and MUST be the number of tips held by a user’s address. If inheriting from, for example, OpenZeppelin’s implementation of ERC-20 token then their contract is responsible for maintaining the balance of tip token. Therefore, tip token balanceOf function SHOULD simply directly call the parent (super) contract’s balanceOf function.

Though it is RECOMMENDED that users’ deposits are kept locked in the tip token contract or external escrow account, and SHOULD NOT be used for anything but the rewards for holders, this cannot be enforced. This standard stipulates that the rewards MUST be available for when holders withdraw their rewards from the pool of deposits.

../Dataset/Raw-data/4400.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Every contract compliant to the EIP721Consumable extension MUST implement the IEIP721Consumable interface. The consumer extension is OPTIONAL for EIP-721 contracts.

Every contract implementing the EIP721Consumable extension is free to define the permissions of a consumer (e.g. what are consumers allowed to do within their system) with only one exception - consumers MUST NOT be considered owners, authorised operators or approved addresses as per the EIP-721 specification. Thus, they MUST NOT be able to execute transfers &amp; approvals.

The ConsumerChanged event MUST be emitted when a consumer is changed.

On every transfer, the consumer MUST be changed to a default address. It is RECOMMENDED for implementors to use address(0) as that default address.

The supportsInterface method MUST return true when called with 0x953c8dfa.

There are numerous use-cases where a distinct role for NFTs is required that MUST NOT have owner permissions. A contract that implements the consumer role and grants ownership permissions to the consumer renders this standard pointless.

../Dataset/Raw-data/4444.xml
Clients MUST use a valid Weak Subjectivity Checkpoint to bootstrap from a more recent view of the chain. For the purpose of syncing, clients treat weak subjectivity checkpoints as the genesis block. We call this method “checkpoint sync”.

../Dataset/Raw-data/4494.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Three new functions MUST be added to <a href="/EIPS/eip-721">ERC-721:

For all addresses spender, uint256s tokenId, deadline, and nonce, and bytes sig, a call to permit(spender, tokenId, deadline, sig) MUST set spender as approved on tokenId as long as the owner of tokenId remains in possession of it, and MUST emit a corresponding Approval event, if and only if the following conditions are met:

where DOMAIN_SEPARATOR MUST be defined according to EIP-712. The DOMAIN_SEPARATOR should be unique to the contract and chain to prevent replay attacks from other domains, and satisfy the requirements of EIP-712, but is otherwise unconstrained. A common choice for DOMAIN_SEPARATOR is:

the nonce of a particular tokenId (nonces[tokenId]) MUST be incremented upon any transfer of the tokenId

the permit function MUST check that the signer is not the zero address

This EIP requires <a href="/EIPS/eip-165">EIP-165. EIP165 is already required in <a href="/EIPS/eip-721">ERC-721, but is further necessary here in order to register the interface of this EIP. Doing so will allow easy verification if an NFT contract has implemented this EIP or not, enabling them to interact accordingly. The interface of this EIP (as defined in EIP-165) is 0x5604e225. Contracts implementing this EIP MUST have the supportsInterface function return true when called with 0x5604e225.

../Dataset/Raw-data/4521.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The interface for ERC-4521 transfer() MUST conform to ERC-20 and resulting transfers MUST fire the Transfer event as described in ERC-721.

../Dataset/Raw-data/4524.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

In order to be compliant with this EIP, and ERC-20-compliant contract MUST also implement the following functions:

safeTransfer and safeTransferFrom MUST transfer as expected to EOA addresses, and to contracts implementing ERC20Receiver and returning the function selector (0x4fc35859) when called, and MUST revert when transferring to a contract which either does not have ERC20Receiver implemented, or does not return the function selector when called.

In addition, a contract accepting safe transfers MUST implement the following if it wishes to accept safe transfers, and MUST return the function selector (0x4fc35859):

../Dataset/Raw-data/4527.xml
; If components is empty, then source-fingerprint MUST be a fingerprint of

        components: [path-component], ; If empty, source-fingerprint MUST be present

; then parent-fingerprint MUST be identical to source-fingerprint or may be omitted.

../Dataset/Raw-data/4546.xml
The wrapped deposit contract SHOULD be deployed at an identifiable address (e.g. 0x1111119a9e30bceadf9f939390293ffacef93fe9). The contract MUST be non-upgradable with no ability for state variables to be changed.

The wrapped deposit contract MUST have the following public functions:

Each of these functions MUST revert if to is an address with a zero code size. Each function MUST attempt to call a method on the to address confirming that it is willing and able to accept the deposit. If this function call does not return a true value execution MUST revert. If the asset transfer is not successful execution MUST revert.

A receiving contract MAY implement any of these functions as desired. If a given function is not implemented deposits MUST not be sent for that asset type.

Receiving contracts MUST verify that msg.sender is equal to the wrapped deposit contract. Failing to do so allows anyone to simulate deposits.

../Dataset/Raw-data/4626.xml
All ERC-4626 tokenized Vaults MUST implement ERC-20 to represent shares.

All ERC-4626 tokenized Vaults MUST implement ERC-20’s optional metadata extensions.

MUST be an ERC-20 token contract.

MUST <em>NOT</em> revert.

MUST be inclusive of any fees that are charged against assets in the Vault.

MUST <em>NOT</em> revert.

MUST NOT be inclusive of any fees that are charged against assets in the Vault.

MUST NOT show any variations depending on the caller.

MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.

MUST NOT revert unless due to integer overflow caused by an unreasonably large input.

MUST round down towards 0.

MUST NOT be inclusive of any fees that are charged against assets in the Vault.

MUST NOT show any variations depending on the caller.

MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.

MUST NOT revert unless due to integer overflow caused by an unreasonably large input.

MUST round down towards 0.

MUST return the maximum amount of assets deposit would allow to be deposited for receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.

MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.

MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.

MUST NOT revert.

MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called in the same transaction.

MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the deposit would be accepted, regardless if the user has enough tokens approved, etc.

MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.

MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause deposit to revert.

MUST emit the Deposit event.

MUST support ERC-20 approve / transferFrom on asset as a deposit flow.

MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).

MUST return the maximum amount of shares mint would allow to be deposited to receiver and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary). This assumes that the user has infinite assets, i.e. MUST NOT rely on balanceOf of asset.

MUST factor in both global and user-specific limits, like if mints are entirely disabled (even temporarily) it MUST return 0.

MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.

MUST NOT revert.

MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the same transaction.

MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint would be accepted, regardless if the user has enough tokens approved, etc.

MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.

MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause mint to revert.

MUST emit the Deposit event.

MUST support ERC-20 approve / transferFrom on asset as a mint flow.

MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).

MUST return the maximum amount of assets that could be transferred from owner through withdraw and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).

MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST return 0.

MUST NOT revert.

MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if called in the same transaction.

MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though the withdrawal would be accepted, regardless if the user has enough shares, etc.

MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.

MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause withdraw to revert.

MUST emit the Withdraw event.

MUST support a withdraw flow where the shares are burned from owner directly where owner is msg.sender.

MUST support a withdraw flow where the shares are burned from owner directly where msg.sender has ERC-20 approval over the shares of owner.

MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).

MUST return the maximum amount of shares that could be transferred from owner through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).

MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.

MUST NOT revert.

MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the same transaction.

MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the redemption would be accepted, regardless if the user has enough shares, etc.

MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.

MUST NOT revert due to vault specific user/global limits. MAY revert due to other conditions that would also cause redeem to revert.

MUST emit the Withdraw event.

MUST support a redeem flow where the shares are burned from owner directly where owner is msg.sender.

MUST support a redeem flow where the shares are burned from owner directly where msg.sender has ERC-20 approval over the shares of owner.

MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).

MUST be emitted when tokens are deposited into the Vault via the mint and deposit methods.

MUST be emitted when shares are withdrawn from the Vault in ERC4626.redeem or ERC4626.withdraw methods.

The only functions where the preferred rounding direction would be ambiguous are the convertTo functions. To ensure consistency across all ERC-4626 Vault implementations it is specified that these functions MUST both always round <em>down</em>. Integrators may wish to mimic rounding up versions of these functions themselves, like by adding 1 wei to the result.

../Dataset/Raw-data/4675.xml
        The _from argument MUST be the address of an account/contract sending the token.

        The _to argument MUST be the address of an account/contract receiving the token.

        The _id argument MUST be the token type being transferred. (represents NFT)

        The _value argument MUST be the number of tokens the holder balance is decrease by and match the recipient balance is increased by.

        The _owner argument MUST be the address of account/contract approving to withdraw.

        The _spender argument MUST be the address of account/contract approved to withdraw from the _owner balance.

        The _id argument MUST be the token type being transferred. (represents NFT)

        The _value argument MUST be the number of tokens the _approved is able to withdraw from _owner balance.

        The _parentToken argument MUST be the address of the Non-Fungible Token contract.

        The _parentTokenId argument MUST be the token ID of the Non-Fungible Token.

        The _id argument MUST be the token type being added. (represents NFT)

        The _totalSupply argument MUST be the number of total token supply of the token type.

        MUST revert if _to is the zero address.

        MUST revert if balance of msg.sender for token _id is lower than the _value being transferred.

        MUST revert on any other error.

        MUST emit the Transfer event to reflect the balance change.

        MUST revert if _spender is the zero address.

        MUST revert on any other error.

        MUST emit the Approval event.

        MUST revert if _to is the zero address.

        MUST revert if balance of holder for token _id is lower than the _value sent.

        MUST revert on any other error.

        MUST emit Transfer event to reflect the balance change.

        MUST revert if the same NFT is already registered.

        MUST revert if _parentNFTContractAddress is address zero.

        MUST revert if _parentNFTContractAddress is not ERC-721 compatible.

        MUST revert if this contract itself is not the owner of the NFT.

        MUST revert on any other error.

        MUST emit TokenAddition event to reflect the token type addition.

../Dataset/Raw-data/4736.xml
The Consensus Layer change withdrawal credentials operation is not yet fully specified, but MUST have at least the following fields:

Note that these restrictions SHALL NOT apply to withdrawal credential change operations found in blocks. If any operation has been included on-chain, it MUST by definition be valid regardless of its contents or protective mechanisms described above.

../Dataset/Raw-data/4747.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/4750.xml
The requirement of EIP-3540 “Exactly one code section MUST be present.” is relaxed to “At least one code section MUST be present.”, i.e. multiple code sections (kind = 1) are allowed.

Total number of code sections MUST NOT exceed 1024.

All code sections MUST precede a data section, if data section is present.

The type section, if present, MUST directly precede all code sections.

Therefore type section size MUST be n * 2 bytes, where n is the number of code sections.

First code section MUST have 0 inputs and 0 outputs.

../Dataset/Raw-data/4799.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The authenticity of designated ownership of an NFT is conferred by the designating ERC-4799 contract’s ownership of the original NFT according to the source contract. This MUST be verified by clients by querying the source contract.

Clients respecting this specification SHALL NOT distribute any utility to the address of the ERC-4799 contract. Instead, they MUST distribute it to the owner of the designated token that the ERC-4799 contract points them to.

../Dataset/Raw-data/4834.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/4881.xml
Consensus clients MAY continue to implement the deposit Merkle tree however they choose. However, when transmitting the tree to newly syncing nodes, clients MUST use the following format:

Where the hashes in the finalized vector are defined in the Deposit Finalization Flow section below, deposits is the number of deposits stored in the snapshot, and execution_block_hash is the hash of the execution block containing the highest index deposit stored in the snapshot. Consensus clients MUST make this structure available via the Beacon Node API endpoint:

Care must be taken not to send a snapshot which includes deposits that haven’t been fully included in the finalized checkpoint. Let state be the BeaconState at a given block in the chain. Under normal operation, the Eth1Data stored in state.eth1_data is replaced every EPOCHS_PER_ETH1_VOTING_PERIOD epochs. Thus, finalization of the deposit tree proceeds in increments of state.eth1_data. Let eth1data be some Eth1Data. Both of the following conditions MUST be met to consider eth1data finalized:

../Dataset/Raw-data/4883.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/4885.xml
Smart contracts implementing this EIP standard MUST implement the <a href="/EIPS/eip-165">ERC-165 supportsInterface function and MUST return the constant value true if 0xC1A48422 is passed through the interfaceID argument. Note that revert in this document MAY mean a require, throw (not recommended as depreciated) or revert solidity statement with or without error messages.

        All tokenIds referred to in this interface MUST be token instances of this nft contract.

        subscriber MUST have received nft of token tokenId in their account.

        @param tokenId MUST be token id of nft sent to subscriber

        @param uri MUST be uri of the nft that was sent to subscriber or empty string

        @notice Subscribes subscriber to nft of 'tokenId'. subscriber MUST receive nft

        @dev MUST revert if subscriber is already subscribed to nft of 'tokenId'

        MUST revert if 'nft' has not approved the subscriptionToken contract address as operator.

        @param subscriber The subscriber account. MUST revert if zero address.

        @param tokenId MUST be token id of nft contract sent to subscriber

        tokenId emitted from event SubscribeToNFT MUST be the same as tokenId except when

        uri emitted from event SubscribeToNFT MUST be the same as uri except when uri is empty.

        @dev MUST revert if subscriber is not subscribed to nft of 'tokenId'

        MUST revert if 'nft' has not approved the subscriptionToken contract address as operator.

        @param subscriber The subscriber account. MUST revert if zero address.

        MUST return zero balance if the subscriber does not hold nft of 'tokenId'

        MUST revert if subscriber is not an approved operator of nft

        MUST revert if subscription has not yet started

        When the balance is zero, the use of nft of tokenId MUST NOT be allowed for subscriber

Use of subscription tokens is in effect an indirect way to control the lifetime of an NFT. As such it is assumed that this arrangement would work best when the NFTs and subscription token contracts subscribing to the NFTs, are deployed by the same platform or decentralised app. It MUST NOT have an impact or dependencies to existing NFTs that have not approved the subscription token as an operator. Indeed in this case, any other parties wouldn’t be aware of and any NFT lifetime dependencies will be ignored, hence should not work anyway. To this end, this proposal specifies that the nft’ MUST have approved the subscriptionToken contract address as operator.

../Dataset/Raw-data/4886.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/4906.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The MetadataUpdate or BatchMetadataUpdate event MUST be emitted when the JSON metadata of a token, or a consecutive range of tokens, is changed.

The supportsInterface method MUST return true when called with 0x49064906.

../Dataset/Raw-data/4907.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The UpdateUser event MUST be emitted when a user address is changed or the user expires is changed.

The supportsInterface method MUST return true when called with 0xad092b5c.

../Dataset/Raw-data/4931.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Returns the current status of the upgrade functionality. Status MUST return true when the upgrade contract is functional and serving upgrades. It MUST return false when the upgrade contract is not currently serving upgrades.

Returns the current status of the downgrade functionality. Status MUST return true when the upgrade contract is functional and serving downgrades. It MUST return false when the upgrade contract is not currently serving downgrades. When the downgrade Optional Ext. is not implemented, this method will always return false to signify downgrades are not available.

Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.

Downgrades the amount of destination token to the source token in the specified ratio. The source tokens will be sent to the _to address. The function MUST unwrap the destination tokens back to the source tokens. The function MUST throw if the caller’s address does not have enough destination token to downgrade or if isDowngradeActive is returning false. The function MUST also fire the Downgrade event. approve MUST be called first on the destination contract.

MUST trigger when tokens are upgraded.

MUST trigger when tokens are downgraded.

../Dataset/Raw-data/4955.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/4972.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

    ///  the current owner. Emits the ApprovalForAll event. The contract MUST allow

../Dataset/Raw-data/4973.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/4974.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Every ERC-4974 compliant contract MUST implement the ERC4974 and ERC165 interfaces:

    ///  MUST emit when operator changes by any mechanism.

    ///  MUST ONLY emit by setOperator.

    ///  MUST emit emit when participation status changes by any mechanism.

    ///  MUST ONLY emit by setParticipation.

    ///  MUST emit when EXP is transferred by any mechanism.

    ///  MUST ONLY emit by transfer.

    /// @dev MUST throw unless msg.sender is operator.

    ///  MUST throw if operator address is either already current operator

    ///  MUST emit an Appointment event.

    /// @dev MUST throw unless msg.sender is participant.

    ///  MUST throw if participant is operator or zero address.

    ///  MUST emit a Participation event for status changes.

    /// @dev MUST throw unless msg.sender is operator.

    ///  MUST throw unless to address is participating.

    ///  MUST throw if to and from are the same address.

    ///  MUST emit a Transfer event with each successful call.

    /// @dev MUST sum EXP tokens of all participant addresses,

    /// @dev MUST register each time Transfer emits.

../Dataset/Raw-data/4987.xml
Smart contracts implementing the ERC20 held token standard MUST implement all of the functions in the IERC20Holder interface.

Smart contracts implementing the ERC20 held token standard MUST also implement ERC165 and return true when the interface ID 0x74c89d54 is passed.

Smart contracts implementing the ERC721 held token standard MUST implement all of the functions in the IERC721Holder interface.

Smart contracts implementing the ERC721 held token standard MUST also implement ERC165 and return true when the interface ID 0x16b900ff is passed.

Smart contracts implementing the ERC1155 held token standard MUST implement all of the functions in the IERC1155Holder interface.

Smart contracts implementing the ERC1155 held token standard MUST also implement ERC165 and return true when the interface ID 0xced24c37 is passed.

../Dataset/Raw-data/5005.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Avatars are programmable Ethereum accounts. Avatars are the address that holds balances, owns systems, executes transaction, is referenced externally, and ultimately represents your DAO. Avatars MUST expose the IAvatar interface.

Modifiers are contracts that sit between modules and avatars to modify the module’s behavior. For example, they might enforce a delay on all functions a module attempts to execute or limit the scope of transactions that can be initiated by the module. Modifiers MUST expose the IAvatar interface.

Guards are contracts that MAY be enabled on modules or modifiers and implement pre- or post-checks on each transaction executed by those modules or modifiers. This allows avatars to do things like limit the scope of addresses and functions that a module or modifier can call or ensure a certain state is never changed by a module or modifier. Guards MUST expose the IGuard interface. Modules, modifiers, and avatars that wish to be guardable MUST inherit Guardable, MUST call checkTransaction() before triggering execution on their target, and MUST call checkAfterExecution() after execution is complete.

../Dataset/Raw-data/5006.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The supportsInterface method MUST return true when called with 0x208994f8.

../Dataset/Raw-data/5007.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/5008.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The nonce(uint256 tokenId) function MUST be implemented as view.

The supportsInterface method MUST return true when called with 0xce03fdab.

../Dataset/Raw-data/5050.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Smart contracts implementing this EIP standard MUST implement the <a href="/EIPS/eip-165">EIP-165 supportsInterface function and MUST return the constant value true if the IERC5050Sender interface ID 0xc8c6c9f3 and/or the IERC5050Receiver interface ID 0x1a3f02f4 is passed through the interfaceID argument (depending on which interface(s) the contract implements).

Emits the ApprovalForAll event. The contract MUST allow

State contracts allow arbitrary senders and receivers to share a user-specified state environment. Each Object MAY define its own action handling, which MAY include reading from the state contract during, but the action MUST be finalized by the state contract. This means the state contract serves as ground truth.

Contracts that support Controllers SHOULD ignore require/revert statements related to action verification, and MUST NOT pass the action to the next contract in the chain.

Emits the ControllerApproval event. The contract MUST allow

Emits the ControllerApproval event. The contract MUST allow

../Dataset/Raw-data/5069.xml

The best available resource to understand the EIP process is <a href="/EIPS/eip-1">EIP-1. Anyone desirous of becoming an EIP editor MUST understand this document. Afterwards, participating in the EIP process by commenting on and suggesting improvements to PRs and issues will familliarize the procedure, and is RECOMMENDED. The contributions of newer editors SHALL be monitored by other EIP editors.

This EIP MUST have the same rules regarding changes as <a href="/EIPS/eip-1">EIP-1.

../Dataset/Raw-data/5081.xml
execute this transaction. Any block with a block number block_num &gt; expire_by MUST NOT execute this transaction.

If current_block_num is available, client MUST drop and stop propagating/broadcasting any transactions that has a

../Dataset/Raw-data/5094.xml
If the <em>key</em> in the parameter is decimals the <em>value</em> MUST be a number.

rpc_url is represented as an array of RPC URLs. A minimum of 1 rpc_url MUST be present, in the format of rpc_url=https%3A%2F%2Fpolygon-rpc.com, or when multiple present rpc_url=https%3A%2F%2Fpolygon-rpc.com&amp;rpc_url=https%3A%2F%2Frpc-mainnet.matic.network.

decimals if provided, MUST be a non-negative integer representing the decimal precision of the native token.

explorer_url if provided, MUST specify one or more URLs pointing to block explorer web sites for the chain.

icon_url if provided, MUST specify one or more URLs pointing to reasonably sized images that can be used to visually identify the chain.

../Dataset/Raw-data/5095.xml
All Principal Tokens (PTs) MUST implement <a href="/EIPS/eip-20">EIP-20 to represent ownership of future underlying redemption.

All Principal Tokens MUST implement <a href="/EIPS/eip-20">EIP-20’s optional metadata extensions.

MUST be an EIP-20 token contract.

MUST <em>NOT</em> revert.

MUST <em>NOT</em> revert.

MUST NOT be inclusive of any fees that are charged against redemptions.

MUST NOT show any variations depending on the caller.

MUST NOT reflect slippage or other on-chain conditions, when performing the actual redemption.

MUST NOT revert unless due to integer overflow caused by an unreasonably large input.

MUST round down towards 0.

MUST NOT be inclusive of any fees.

MUST NOT show any variations depending on the caller.

MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.

MUST NOT revert unless due to integer overflow caused by an unreasonably large input.

MUST round down towards 0.

MUST return the maximum amount of principal tokens that could be transferred from holder through redeem and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).

MUST factor in both global and user-specific limits, like if redemption is entirely disabled (even temporarily) it MUST return 0.

MUST NOT revert.

MUST return as close to and no more than the exact amount of underliyng that would be obtained in a redeem call in the same transaction. I.e. redeem should return the same or more underlyingAmount as previewRedeem if called in the same transaction.

MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the redemption would be accepted, regardless if the user has enough principal tokens, etc.

MUST be inclusive of redemption fees. Integrators should be aware of the existence of redemption fees.

MUST NOT revert due to principal token contract specific user/global limits. MAY revert due to other conditions that would also cause redeem to revert.

Interfaces and other contracts MUST NOT expect fund custody to be present. While custodial redemption of Principal Tokens through the Principal Token contract is extremely useful for integrators, some protocols may find giving the Principal Token itself custody breaks their backwards compatibility.

MUST emit the Redeem event.

MUST support a redeem flow where the Principal Tokens are burned from holder directly where holder is msg.sender or msg.sender has EIP-20 approval over the principal tokens of holder.

MUST revert if all of principalAmount cannot be redeemed (due to withdrawal limit being reached, slippage, the holder not having enough Principal Tokens, etc).

MUST return the maximum amount of underlying tokens that could be redeemed from holder through withdraw and not cause a revert, which MUST NOT be higher than the actual maximum that would be accepted (it should underestimate if necessary).

MUST factor in both global and user-specific limits, like if withdrawals are entirely disabled (even temporarily) it MUST return 0.

MUST NOT revert.

MUST return as close to and no fewer than the exact amount of principal tokens that would be burned in a withdraw call in the same transaction. I.e. withdraw should return the same or fewer principalAmount as previewWithdraw if called in the same transaction.

MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though the withdrawal would be accepted, regardless if the user has enough principal tokens, etc.

MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.

MUST NOT revert due to principal token contract specific user/global limits. MAY revert due to other conditions that would also cause withdraw to revert.

MUST emit the Redeem event.

MUST support a withdraw flow where the principal tokens are burned from holder directly where holder is msg.sender or msg.sender has <a href="/EIPS/eip-20">EIP-20 approval over the principal tokens of holder.

MUST revert if all of underlyingAmount cannot be withdrawn (due to withdrawal limit being reached, slippage, the holder not having enough principal tokens, etc).

MUST be emitted when Principal Tokens are burnt and underlying is withdrawn from the contract in the EIP5095.redeem method.

../Dataset/Raw-data/5114.xml
</span>	<span class="c1">// this event **MUST NOT** be fired twice for the same tokenId

</span>	<span class="c1">// this function **MUST** throw if the token hasn't been minted yet

</span>	<span class="c1">// this function **MUST** always return the same result every time it is called after it has been minted

</span>	<span class="c1">// this function **MUST** return the same value as found in the original Mint event for the token

</span>	<span class="c1">// the collectionUri **MUST** be immutable (e.g., ipfs:// and not http://)

</span>	<span class="c1">// the collectionUri **MUST** be content addressable (e.g., ipfs:// and not http://)

</span>	<span class="c1">// any external links referenced by the content at collectionUri also **MUST** follow all of the above rules

</span>	<span class="c1">// the collectionUri **MUST** be immutable (e.g., ipfs:// and not http://)

</span>	<span class="c1">// the collectionUri **MUST** be content addressable (e.g., ipfs:// and not http://)

</span>	<span class="c1">// any external links referenced by the content at tokenUri also **MUST** follow all of the above rules

../Dataset/Raw-data/5115.xml
MUST NOT include fees that are charged against the underlying yield token in the SCY contract.

MUST NOT include fees that are charged against the underlying yield token in the SCY contract.

MUST NOT revert.

MUST NOT revert.

MUST NOT revert.

MUST NOT revert.

MUST NOT revert.

MUST NOT revert.

This EIP is fully backwards compatible as its implementation extends the functionality of <a href="/EIPS/eip-20">EIP-20, however the optional metadata extensions, namely name, decimals, and symbol semantics MUST be implemented for all SCY token implementations.

../Dataset/Raw-data/5131.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The mainAddress MUST have an ENS resolver record and reverse record configured.

MUST get the reverse ENS record for mainAddress and verify that it matches &lt;mainENS&gt;.

../Dataset/Raw-data/5139.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

List consumers (like wallets) MUST validate lists against the provided schema. List consumers MUST NOT connect to RPC providers present only in an invalid list.

Lists MUST conform to the following JSON Schema:

List versioning MUST follow the <a href="/assets/eip-5139/semver">Semantic Versioning 2.0.0 (SemVer) specification.

The major version MUST be incremented for the following modifications:

If the major version is not incremented, the minor version MUST be incremented if any of the following modifications are made:

If the major and minor versions are unchanged, the patch version MUST be incremented for any change.

Provider lists MAY instead be published using HTTPS. Provider lists published in this way MUST allow reasonable access from other origins (generally by setting the header Access-Control-Allow-Origin: *.)

If present, the uri field MUST use a scheme specified in <a href="#publishing">Publishing.

If present, the ens field MUST specify an ENS name to be resolved using EIP-1577.

The version field SHALL specify a range of compatible versions. List consumers MUST reject extension lists specifying an incompatible parent version.

In the event of an incompatible version, list consumers MAY continue to use a previously saved parent list, but list consumers choosing to do so MUST display a prominent warning that the provider list is out of date.

JSON pointers within the changes field MUST be resolved relative to the providers field of the parent list. For example, see the following lists for a correctly formatted extension.

List consumers MUST follow this algorithm to apply extension lists:

../Dataset/Raw-data/5143.xml
This ERC is an extension of EIP-4626. Any contract implementing it MUST also implement EIP-4626.

MUST emit the Deposit event.

MUST support <a href="/EIPS/eip-20">EIP-20 approve / transferFrom on asset as a deposit flow.

MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).

MUST revert if depositing assets underlying asset mints less then minShares shares.

MUST emit the Deposit event.

MUST support ERC-20 approve / transferFrom on asset as a mint flow.

MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).

MUST revert if minting shares shares cost more then maxAssets underlying tokens.

MUST emit the Withdraw event.

MUST support a withdraw flow where the shares are burned from owner directly where owner is msg.sender or msg.sender has ERC-20 approval over the shares of owner.

MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).

MUST revert if withdrawing assets underlying tokens requires burning more then maxShares shares.

MUST emit the Withdraw event.

MUST support a redeem flow where the shares are burned from owner directly where owner is msg.sender or msg.sender has ERC-20 approval over the shares of owner.

MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).

MUST revert if redeeming shares shares sends less than minAssets underlying tokens to receiver.

../Dataset/Raw-data/5173.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Implementers of this standard MUST have all of the following functions:

An nFR contract MUST implement and update for each Token ID. The data in the FRInfo struct MAY either be stored wholly in a single mapping, or MAY be broken down into several mappings. The struct MUST either be exposed in a public mapping or mappings, or MUST have public functions that access the private data. This is for client-side data fetching and verification.

Additionally, an nFR smart contract MUST store the corresponding ListInfo for each Token ID in a mapping. A method to retrieve a Token ID’s corresponding ListInfo MUST also be accessible publicly.

An nFR smart contract MUST also store and update the amount of Ether allocated to a specific address using the _allotedFR mapping. The _allottedFR mapping MUST either be public or have a function to fetch the FR payment allotted to a specific address.

The allocatedFR MUST be calculated using a percentage fixed point with a scaling factor of 1e18 (X/1e18) - such as “5e16” - for 5%. This is REQUIRED to maintain uniformity across the standard. The max and min values would be - 1e18 - 1.

A default FRInfo MUST be stored in order to be backward compatible with <a href="/EIPS/eip-721">EIP-721 mint functions. It MAY also have a function to update the FRInfo, assuming it has not been hard-coded.

An nFR-compliant smart contract MUST override the <a href="/EIPS/eip-721">EIP-721 _mint, _transfer, and _burn functions. When overriding the _mint function, a default FR model is REQUIRED to be established if the mint is to succeed when calling the <a href="/EIPS/eip-721">EIP-721 _mint function and not the nFR _mint function. It is also to update the owner amount and directly add the recipient address to the FR cycle. When overriding the _transfer function, the smart contract SHALL consider the NFT as sold for 0 ETH, and update the state accordingly after a successful transfer. This is to prevent FR circumvention. Finally, when overriding the _burn function, the smart contract SHALL delete the FRInfo corresponding to that Token ID after a successful burn.

If the wallet/broker/auction application will accept safe transfers, then it MUST implement the <a href="/EIPS/eip-721">EIP-721 wallet interface.

The list, unlist, and buy functions MUST be implemented, as they provide the capability to sell a token.

The buy function accepts a tokenId and MUST be payable. It MUST verify that the msg.value matches the token’s salePrice and that the token is listed, before proceeding and calling the FR _transferFrom function. This is to ensure the values are valid and will also allow for the necessary FR to be held in the contract.

The FR _transferFrom function MUST be called by all nFR-supporting smart contracts, though the accommodations for non-nFR-supporting contracts MAY also be implemented to ensure backwards compatibility.

Based on the stored lastSoldPrice, the smart contract will determine whether the sale was profitable after calling the <a href="/EIPS/eip-721">EIP-721 transfer function and transferring the NFT. If it was not profitable, the smart contract SHALL update the last sold price for the corresponding Token ID, increment the owner amount, shift the generations, and transfer all of the msg.value to the lister depending on the implementation. Otherwise, if the transaction was profitable, the smart contract SHALL call the _distributeFR function, then update the lastSoldPrice, increment the owner amount, and finally shift generations. The _distributeFR function MUST return the difference between the allocated FR that is to be distributed amongst the _addressesInFR and the msg.value to the lister. Once the operations have completed, the function MUST clear the corresponding ListInfo.

When an owner loses money during their holding period, they MUST NOT be obligated to share Future Rewards distributions, since there is no profit to share. However, he SHALL still receive a share of Future Rewards distributions from future generations of owners, if they are profitable.

The _distributeFR function MUST be called in the FR transferFrom function if there is a profitable sale. The function SHALL calculate the difference between the current sale price and the lastSoldPrice, then it SHALL call the _calculateFR function to receive the proper distribution of FR. Then it SHALL distribute the FR accordingly, making order adjustments as necessary. Then, the contract SHALL calculate the total amount of FR that was distributed (allocatedFR), in order to return the difference of the soldPrice and allocatedFR to the lister. Finally, it SHALL emit the FRDistributed event.

The _shiftGenerations function MUST be called regardless of whether the sale was profitable or not. As a result, it will be called in the _transfer <a href="/EIPS/eip-721">EIP-721 override function and the FR transferFrom function. The function SHALL remove the oldest account from the corresponding _addressesInFR array. This calculation will take into account the current length of the array versus the total number of generations for a given token ID.

../Dataset/Raw-data/5185.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/5189.xml
dependencies: a comprehensive list of addresses and storage slots that must be monitored; any state change in these dependencies MUST trigger a re-evaluation of the operation’s readiness.

If another operation exists in the mempool with the exact same dependency set AND the same endorser address, the maxFeePerGas and priorityFeePerGas of the newly received operation MUST be 12% higher than the one on the mempool to replace it. (Similar with how EOA with same nonce work)

If the operation passes these checks, then the client MUST call isOperationReady() on the endorser. If the endorser considers the operation ready, then the client MUST add the operation to the mempool. Otherwise, the operation MUST discarded.

The endorser result MUST be invalidated and its readiness be re-evaluated if any of the values of the provided dependencies change. If the operation readiness changes to false, the operation MUST be discarded.

Before including the operation in a block, a last simulation MUST be performed, this time without calling the endorser, but by constructing the block and probing the result. All transactions in the block listed before the operation must be simulated and the endorser must be queried again there for readiness in-case some dependencies changed.

The bundler MUST NOT drop an operation after successfully including such operation in a block, the operation must remain in the mempool and a last isOperationReady call must be performed.

../Dataset/Raw-data/5192.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/5202.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

A blueprint contract MUST use the preamble 0xFE71&lt;version bits&gt;&lt;length encoding bits&gt;. 6 bits are allocated to the version, and 2 bits to the length encoding. The first version begins at 0 (0b000000), and versions increment by 1. The value 0b11 for &lt;length encoding bits&gt; is reserved. In the case that the length bits are 0b11, the third byte is considered a continuation byte (that is, the version requires multiple bytes to encode). The exact encoding of a multi-byte version is left to a future ERC.

A blueprint contract MUST contain at least one byte of initcode.

../Dataset/Raw-data/5218.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The supportsInterface method MUST return true when called with 0xac7b5ca9.

../Dataset/Raw-data/5219.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

DApp contracts MUST implement the interface defined in the following file: <a href="/assets/eip-5219/IDecentralizedApp.sol">Contract Interface.

../Dataset/Raw-data/5247.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

../Dataset/Raw-data/5267.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Compliant contracts MUST define eip712Domain exactly as declared below. All specified values MUST be returned even if they are not used, to ensure proper decoding on the client side.

The return values of this function MUST describe the domain separator that is used for verification of EIP-712 signatures in the contract. They describe both the form of the EIP712Domain struct (i.e., which of the optional fields and extensions are present) and the value of each field, as follows.

../Dataset/Raw-data/5269.xml
Any compliant smart contract MUST implement the following interface

Any compliant contract that is an IERC5629 MUST return true for the call of supportsErc(5269, 0, (any caller)).

Any compliant contract MUST return true when a behavior defined in that ERC and optional interface extensions is available to a caller.

Similar to <a href="/EIPS/eip-165">EIP-165 callers of the interface MUST assume the smart contract

../Dataset/Raw-data/5289.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

When a signature is requested, wallets MUST call legalDocument and fetch the file off of IPFS, and render that file to the user. If the user agrees, the wallet MUST call signDocument. Using a form of account abstraction is RECOMMENDED.

../Dataset/Raw-data/5313.xml
The key word “MUST” in this document is to be interpreted as described in RFC 2119.

Every contract compliant with this EIP MUST implement the EIP5313 interface.

../Dataset/Raw-data/5375.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

If a contract supports the metadata extension for <a href="/EIPS/eip-721">EIP-721, the JSON document pointed by tokenURI(uint256 _tokenId) MUST include the top-level field authorInfo

If a contract supports the metadata extension for <a href="/EIPS/eip-1155">EIP-1155, the JSON document pointed by uri(uint256 _id) MUST include a top-level field authorInfo

Moreover, if the consent field is present, the consentInfo field of authorInfo MUST be present.

consentData MAY support additional fields as defined by other EIPs. consentData MUST contain all the information (which is not already present in other fields) required to verify the validity of an authorship consent proof.

MUST contain exactly the same fields as the ones listed in metadataFields, in the same order

MUST escape all non-ASCII characters. If the escaped character contains hexadecimal letters, they MUST be uppercase

MUST not contain any whitespace that is not part of a field name or value

If calling tokenURI (for EIP-721) or uri (for EIP-1155) returns the URI of a JSON document D2, all the top-level fields listed in metadataFields MUST exist and have the same value;

Verifiers MUST NOT assume that an NFT with a valid consent proof from address X means that X is the actual author. On the other hand, verifiers MAY assume that if an NFT does not provide a valid consent proof for address X, then X is not the actual author.

A potential attack that exploits this EIP involves tricking authors into signing authorship consent messages against their wishes. For this reason, authors MUST verify that all signature fields match the required ones.

../Dataset/Raw-data/5409.xml
The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY” and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The supportsInterface method MUST return true when called with 0x6352211e.

../Dataset/Raw-data/5485.xml
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Suppose a compliant ContractA is deployed at address 0x&lt;Contract_Address_A&gt; and gains its legitimacy from another contract or External Owned Account (EOA) at 0x&lt;ADDRESS_B&gt;. In this case, it MUST return the 0x&lt;ADDRESS_B&gt; when being queried for sourceOfLegitimacy(). For example. If ContractA gains legitimacy from ContractB, ContractB gains legitimacy from ContractC but ContractC doesn’t gain legitimacy from anyone, ContractC is considered the “jurisdiction” that both ContractB and ContractA observe. Both ContractA and ContractB MUST return the address of ContractC as the result of jurisdiction.

Any compliant contract MUST return its legitimacy sources chain up to the sovereign contract when queried by jurisdiction().

If ContractA gains legitimacy from ContractB, ContractA MUST observe the ContractB’s order to ANY of the following

If ContractA observes jurisdiction of ContractC (a sovereignty), ContractA MUST observe ContractC’s order to ANY the following

https://eips.ethereum.org/EIPS/eip-5489
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
The SlotAuthorizationCreated event MUST be emitted when a slot is authorized to an address.
The SlotAuthorizationRevoked event MUST be emitted when a slot authorization is revoked.
The supportInterface method MUST return true when called with 0x8f65987b.

https://eips.ethereum.org/EIPS/eip-5496
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.
Every contract compliant to the ERC5496 extension MUST implement the IERC5496 interface. The sharable multi-privilege extension is OPTIONAL for EIP-721 contracts.
Every contract implementing the ERC5496 SHOULD set a maximum privilege number before setting any privilege, the privilegeId MUST NOT be greater than the maximum privilege number.
The PrivilegeAssigned event MUST be emitted when setPrivilege is called.
The PrivilegeTransfered event MUST be emitted when transferPrivilege is called.
The supportsInterface method MUST return true when called with 0x076e1bbb.
The PrivilegeCloned event MUST be emitted when clonePrivilege is called.