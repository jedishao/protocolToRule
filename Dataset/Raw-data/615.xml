<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EIP-615: Subroutines and Static Jumps for the EVM</title>
<meta property="og:title" content="EIP-615: Subroutines and Static Jumps for the EVM" />
<meta name="description" content="" />
<meta property="og:description" content="" />
<meta name="twitter:description" content="" />
<meta name="generator" content="Jekyll" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://eips.ethereum.org/EIPS/eip-615" />
<meta property="og:url" content="https://eips.ethereum.org/EIPS/eip-615" />
<meta property="og:site_name" content="Ethereum Improvement Proposals" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "https://eips.ethereum.org",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
<link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="https://eips.ethereum.org/feed.xml" title="Ethereum Improvement Proposals" /><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-nlrDrBTHxJJlDDX22AS33xYI1OJHnGMDhiYMSe2U0e0=" crossorigin="anonymous"></script>
</head>
<body><header class="site-header" role="banner">
<div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav">
<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger">
<span class="menu-icon">
<svg viewBox="0 0 18 15" width="18px" height="15px">
<path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
</svg>
</span>
</label>
<div class="trigger"><a class="page-link" href="/all">All</a><a class="page-link" href="/core">Core</a><a class="page-link" href="/networking">Networking</a><a class="page-link" href="/interface">Interface</a><a class="page-link" href="/erc">ERC</a><a class="page-link" href="/meta">Meta</a><a class="page-link" href="/informational">Informational</a></div>
</nav></div>
</header>
<main class="page-content" aria-label="Content">
<div class="wrapper">
<div class="stagnant">
üöß This EIP had no activity for at least 6 months.
</div>
<div class="home">
<h1 class="page-heading">
EIP-615: Subroutines and Static Jumps for the EVM
<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-615.md"><svg role="img" aria-label="Source" xmlns="https://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><title>Source</title><path fill-rule="evenodd" d="M9.5 3L8 4.5 11.5 8 8 11.5 9.5 13 14 8 9.5 3zm-5 0L0 8l4.5 5L6 11.5 2.5 8 6 4.5 4.5 3z" /></svg></a>
</h1>
<h3></h3>
<table>
<tr><th>Author</th><td><a href="/cdn-cgi/l/email-protection#f097829597b0939f9c86999ede9f8297">Greg Colvin</a>, <a href="https://github.com/expede">Brooklyn Zelenka</a>, <a href="https://github.com/chfast">Pawe≈Ç Bylica</a>, <a href="https://github.com/chriseth">Christian Reitwiessner</a></td></tr>
<tr><th>Discussions-To</th><td><a href="https://ethereum-magicians.org/t/eip-615-subroutines-and-static-jumps-for-the-evm-last-call/3472">https://ethereum-magicians.org/t/eip-615-subroutines-and-static-jumps-for-the-evm-last-call/3472</a></td></tr>
<tr><th>Status</th><td>Stagnant
</td></tr>
<tr><th>Type</th><td>Standards Track</td></tr>
<tr><th>Category</th><td>Core</td></tr>
<tr><th>Created</th><td>2016-12-10</td></tr>
</table>
<div class="toc">
<h2>Table of Contents</h2>
<ul>
<li><a href="#simple-summary">Simple Summary</a></li>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#specification">Specification</a>
<ul>
<li><a href="#dependencies">Dependencies</a></li>
<li><a href="#proposal">Proposal</a></li>
<li><a href="#semantics">Semantics</a></li>
<li><a href="#validity">Validity</a></li>
</ul>
</li>
<li><a href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#appendix-a">Appendix A</a>
<ul>
<li><a href="#validation">Validation</a></li>
</ul>
</li>
<li><a href="#appendix-b">Appendix B</a>
<ul>
<li><a href="#evm-analysis">EVM Analysis</a></li>
</ul>
</li>
<li><a href="#copyright">Copyright</a></li>
</ul>
</div>
<h2 id="simple-summary">
<a href="#simple-summary" class="anchor-link"></a> Simple Summary
</h2>
<p>In the 21st century, on a blockchain circulating billions of ETH, formal specification and verification are an essential tool against loss. Yet the design of the EVM makes this unnecessarily difficult. Further, the design of the EVM makes near-linear-time compilation to machine code difficult. We propose to move forward with proposals to resolve these problems by tightening EVM security guarantees and reducing barriers to performance.</p>
<h2 id="abstract">
<a href="#abstract" class="anchor-link"></a> Abstract
</h2>
<p>EVM code is currently difficult to statically analyze, hobbling critical tools for preventing the many expensive bugs our blockchain has experienced. Further, none of the current implementations of the Ethereum Virtual Machine‚Äîincluding the compilers‚Äîare sufficiently performant to reduce the need for precompiles and otherwise meet the network‚Äôs long-term demands. This proposal identifies dynamic jumps as a major reason for these issues, and proposes changes to the EVM specification to address the problem, making further efforts towards a safer and more performant the EVM possible.</p>
<p>We also propose to validate‚Äîin near-linear time‚Äîthat EVM contracts correctly use subroutines, avoid misuse of the stack, and meet other safety conditions <em>before</em> placing them on the blockchain. Validated code precludes most runtime exceptions and the need to test for them. And well-behaved control flow and use of the stack makes life easier for interpreters, compilers, formal analysis, and other tools.</p>
<h2 id="motivation">
<a href="#motivation" class="anchor-link"></a> Motivation
</h2>
<p>Currently the EVM supports only dynamic jumps, where the address to jump to is an argument on the stack. Worse, the EVM fails to provide ordinary, alternative control flow facilities like subroutines and switches provided by Wasm and most CPUs. So dynamic jumps cannot be avoided, yet they obscure the structure of the code and thus mostly inhibit control- and data-flow analysis. This puts the quality and speed of optimized compilation fundamentally at odds. Further, since many jumps can potentially be to any jump destination in the code, the number of possible paths through the code can go up as the product of the number of jumps by the number of destinations, as does the time complexity of static analysis. Many of these cases are undecidable at deployment time, further inhibiting static and formal analyses.</p>
<p>However, given Ethereum‚Äôs security requirements, <strong>near-linear</strong> <strong><code class="language-plaintext highlighter-rouge">n log n</code></strong> <strong>time complexity</strong> is essential. Otherwise, Contracts can be crafted or discovered with quadratic complexity to use as denial of service attack vectors against validations and optimizations.</p>
<p>But absent dynamic jumps code can be statically analyzed in linear time. That allows for <em>linear time validation</em>. It also allows for code generation and such optimizations as can be done in <code class="language-plaintext highlighter-rouge">log n</code> time to comprise an <em><code class="language-plaintext highlighter-rouge">n log n</code></em> <em>time compiler</em>.</p>
<p>And absent dynamic jumps, and with proper subroutines the EVM is a better target for code generation from other languages, including</p>
<ul>
<li>Solidity</li>
<li>Vyper</li>
<li>LLVM IR
<ul>
<li>front ends include C, C++, Common Lisp, D, Fortran, Haskell, Java, Javascript, Kotlin, Lua, Objective-C, Pony, Pure, Python, Ruby, Rust, Scala, Scheme, and Swift</li>
</ul>
</li>
</ul>
<p>The result is that all of the following validations and optimizations can be done at deployment time with near-linear <code class="language-plaintext highlighter-rouge">(n log n)</code> time complexity.</p>
<ul>
<li>The absence of most exceptional halting states can be validated.</li>
<li>The maximum use of resources can be sometimes be calculated.</li>
<li>Bytecode can be compiled to machine code in near-linear time.</li>
<li>Compilation can more effectively optimize use of smaller registers.</li>
<li>Compilation can more effectively optimize injection of gas metering.</li>
</ul>
<h2 id="specification">
<a href="#specification" class="anchor-link"></a> Specification
</h2>
<h3 id="dependencies">
<a href="#dependencies" class="anchor-link"></a> Dependencies
</h3>
<blockquote>
<p><strong><a href="/EIPS/eip-1702">EIP-1702</a>. Generalized Account Versioning Scheme.</strong> This proposal needs a versioning scheme to allow for its bytecode (and eventually eWasm bytecode) to be deployed with existing bytecode on the same blockchain.</p>
</blockquote>
<h3 id="proposal">
<a href="#proposal" class="anchor-link"></a> Proposal
</h3>
<p>We propose to deprecate two existing instructions‚Äî<code class="language-plaintext highlighter-rouge">JUMP</code> and <code class="language-plaintext highlighter-rouge">JUMPI</code>‚Äîand propose new instructions to support their legitimate uses. In particular, it must remain possible to compile Solidity and Vyper code to EVM bytecode, with no significant loss of performance or increase in gas price.</p>
<p>Especially important is efficient translation to and from <a href="https://github.com/ewasm/design">eWasm</a> and to machine code. To that end we maintain a close correspondence between <a href="https://webassembly.github.io/spec/core/_download/WebAssembly.pdf">Wasm</a>, <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf">x86</a>, <a href="https://static.docs.arm.com/100076/0100/arm_instruction_set_reference_guide_100076_0100_00_en.pdf">ARM</a> and proposed EVM instructions.</p>
<table>
<thead>
<tr>
<th>EIP-615</th>
<th>Wasm</th>
<th>x86</th>
<th>ARM</th>
</tr>
</thead>
<tbody>
<tr>
<td>JUMPTO</td>
<td>br</td>
<td>JMP</td>
<td>B</td>
</tr>
<tr>
<td>JUMPIF</td>
<td>br_if</td>
<td>JE</td>
<td>BEQ</td>
</tr>
<tr>
<td>JUMPV</td>
<td>br_table</td>
<td>JMP</td>
<td>TBH</td>
</tr>
<tr>
<td>JUMPSUB</td>
<td>call</td>
<td>CALL</td>
<td>BL</td>
</tr>
<tr>
<td>JUMPSUBV</td>
<td>call_indirect</td>
<td>CALL</td>
<td>BL</td>
</tr>
<tr>
<td>RETURN</td>
<td>return</td>
<td>RET</td>
<td>RET</td>
</tr>
<tr>
<td>GETLOCAL</td>
<td>local.get</td>
<td>POP</td>
<td>POP</td>
</tr>
<tr>
<td>PUTLOCAL</td>
<td>local.put</td>
<td>PUSH</td>
<td>PUSH</td>
</tr>
<tr>
<td>BEGINSUB</td>
<td>func</td>
<td>¬†</td>
<td>¬†</td>
</tr>
<tr>
<td>BEGINDATA</td>
<td>tables</td>
<td>¬†</td>
<td>¬†</td>
</tr>
</tbody>
</table>
<h4 id="preliminaries">
<a href="#preliminaries" class="anchor-link"></a> Preliminaries
</h4>
<p>These forms</p>
<blockquote>
<p><em><code class="language-plaintext highlighter-rouge">INSTRUCTION</code></em></p>
<p><em><code class="language-plaintext highlighter-rouge">INSTRUCTION x</code></em></p>
<p><em><code class="language-plaintext highlighter-rouge">INSTRUCTION x, y</code></em></p>
</blockquote>
<p>name an <em><code class="language-plaintext highlighter-rouge">INSTRUCTION</code></em> with no, one and two arguments, respectively. An instruction is represented in the bytecode as a single-byte opcode. Any arguments are laid out as immediate data bytes following the opcode inline, interpreted as fixed length, MSB-first, two‚Äôs-complement, two-byte positive integers. (Negative values are reserved for extensions.)</p>
<h4 id="branches-and-subroutines">
<a href="#branches-and-subroutines" class="anchor-link"></a> Branches and Subroutines
</h4>
<p>The two most important uses of <code class="language-plaintext highlighter-rouge">JUMP</code> and <code class="language-plaintext highlighter-rouge">JUMPI</code> are static jumps and return jumps. Conditional and unconditional static jumps are the mainstay of control flow. Return jumps are implemented as a dynamic jump to a return address pushed on the stack. With the combination of a static jump and a dynamic return jump you can‚Äîand Solidity does‚Äîimplement subroutines. The problem is that static analysis cannot tell the one place the return jump is going, so it must analyze every possibility (a heavy analysis).</p>
<p>Static jumps are provided by</p>
<blockquote>
<p><code class="language-plaintext highlighter-rouge">JUMPTO jump_target</code></p>
<p><code class="language-plaintext highlighter-rouge">JUMPIF jump_target</code></p>
<p>which are the same as <code class="language-plaintext highlighter-rouge">JUMP</code> and <code class="language-plaintext highlighter-rouge">JUMPI</code> except that they jump to an immediate <code class="language-plaintext highlighter-rouge">jump_target</code> rather than an address on the stack.</p>
</blockquote>
<p>To support subroutines, <code class="language-plaintext highlighter-rouge">BEGINSUB</code>, <code class="language-plaintext highlighter-rouge">JUMPSUB</code>, and <code class="language-plaintext highlighter-rouge">RETURNSUB</code> are provided. Brief descriptions follow, and full semantics are given below.</p>
<blockquote>
<p><code class="language-plaintext highlighter-rouge">BEGINSUB n_args, n_results</code></p>
<p>marks the <strong>single</strong> entry to a subroutine. <code class="language-plaintext highlighter-rouge">n_args</code> items are taken off of the stack at entry to, and <code class="language-plaintext highlighter-rouge">n_results</code> items are placed on the stack at return from the subroutine. The subroutine ends at the next <code class="language-plaintext highlighter-rouge">BEGINSUB</code> instruction (or <code class="language-plaintext highlighter-rouge">BEGINDATA</code>, below) or at the end of the bytecode.</p>
</blockquote>
<blockquote>
<p><code class="language-plaintext highlighter-rouge">JUMPSUB jump_target</code></p>
<p>jumps to an immediate subroutine address.</p>
</blockquote>
<blockquote>
<p><code class="language-plaintext highlighter-rouge">RETURNSUB</code></p>
<p>returns from the current subroutine to the instruction following the JUMPSUB that entered it.</p>
</blockquote>
<h4 id="switches-callbacks-and-virtual-functions">
<a href="#switches-callbacks-and-virtual-functions" class="anchor-link"></a> Switches, Callbacks, and Virtual Functions
</h4>
<p>Dynamic jumps are also used for <code class="language-plaintext highlighter-rouge">O(1)</code> indirection: an address to jump to is selected to push on the stack and be jumped to. So we also propose two more instructions to provide for constrained indirection. We support these with vectors of <code class="language-plaintext highlighter-rouge">JUMPDEST</code> or <code class="language-plaintext highlighter-rouge">BEGINSUB</code> offsets stored inline, which can be selected with an index on the stack. That constrains validation to a specified subset of all possible destinations. The danger of quadratic blow up is avoided because it takes as much space to store the jump vectors as it does to code the worst case exploit.</p>
<p>Dynamic jumps to a <code class="language-plaintext highlighter-rouge">JUMPDEST</code> are used to implement <code class="language-plaintext highlighter-rouge">O(1)</code> jumptables, which are useful for dense switch statements. Wasm and most CPUs provide similar instructions.</p>
<blockquote>
<p><code class="language-plaintext highlighter-rouge">JUMPV n, jump_targets</code></p>
<p>jumps to one of a vector of <code class="language-plaintext highlighter-rouge">n</code> <code class="language-plaintext highlighter-rouge">JUMPDEST</code> offsets via a zero-based index on the stack. The vector is stored inline at the <code class="language-plaintext highlighter-rouge">jump_targets</code> offset after the BEGINDATA bytecode as MSB-first, two‚Äôs-complement, two-byte positive integers. If the index is greater than or equal to <code class="language-plaintext highlighter-rouge">n - 1</code> the last (default) offset is used.</p>
</blockquote>
<p>Dynamic jumps to a <code class="language-plaintext highlighter-rouge">BEGINSUB</code> are used to implement <code class="language-plaintext highlighter-rouge">O(1)</code> virtual functions and callbacks, which take at most two pointer dereferences on most CPUs. Wasm provides a similar instruction.</p>
<blockquote>
<p><code class="language-plaintext highlighter-rouge">JUMPSUBV n, jump_targets</code></p>
<p>jumps to one of a vector of <code class="language-plaintext highlighter-rouge">n</code> <code class="language-plaintext highlighter-rouge">BEGINSUB</code> offsets via a zero-based index on the stack. The vector is stored inline at the <code class="language-plaintext highlighter-rouge">jump_targets</code> offset after the DATA bytecode, as MSB-first, two‚Äôs-complement, two-byte positive integers. If the index is greater than or equal to <code class="language-plaintext highlighter-rouge">n - 1</code> the last (default) offset is used.</p>
</blockquote>
<h4 id="variable-access">
<a href="#variable-access" class="anchor-link"></a> Variable Access
</h4>
<p>These operations provide convenient access to subroutine parameters and local variables at fixed stack offsets within a subroutine. Otherwise only sixteen variables can be directly addressed.</p>
<blockquote>
<p><code class="language-plaintext highlighter-rouge">PUTLOCAL n</code></p>
<p>Pops the stack to the local variable <code class="language-plaintext highlighter-rouge">n</code>.</p>
</blockquote>
<blockquote>
<p><code class="language-plaintext highlighter-rouge">GETLOCAL n</code></p>
<p>Pushes the local variable <code class="language-plaintext highlighter-rouge">n</code> onto the stack.</p>
</blockquote>
<p>Local variable <code class="language-plaintext highlighter-rouge">n</code> is the nth stack item below the frame pointer, <code class="language-plaintext highlighter-rouge">FP[-n]</code>, as defined below.</p>
<h4 id="data">
<a href="#data" class="anchor-link"></a> Data
</h4>
<p>There needs to be a way to place unreachable data into the bytecode that will be skipped over and not validated. Indirect jump vectors will not be valid code. Initialization code must create runtime code from data that might not be valid code. And unreachable data might prove useful to programs for other purposes.</p>
<blockquote>
<p><code class="language-plaintext highlighter-rouge">BEGINDATA</code></p>
<p>specifies that all of the following bytes to the end of the bytecode are data, and not reachable code.</p>
</blockquote>
<h4 id="structure">
<a href="#structure" class="anchor-link"></a> Structure
</h4>
<p>Valid EIP-615 EVM bytecode begins with a valid header. This is the magic number ‚Äò\0evm‚Äô followed by the semantic versioning number ‚Äò\1\5\0‚Äô. (For Wasm the header is ‚Äò\0asm\1‚Äô).</p>
<p>Following the header is the BEGINSUB opcode for the <em>main</em> routine. It takes no arguments and returns no values. Other subroutines may follow the <em>main</em> routine, and an optional BEGINDATA opcode may mark the start of a data section.</p>
<h3 id="semantics">
<a href="#semantics" class="anchor-link"></a> Semantics
</h3>
<p>Jumps to and returns from subroutines are described here in terms of</p>
<ul>
<li>The EVM data stack, (as defined in the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Yellow Paper</a>) usually just called ‚Äúthe stack.‚Äù</li>
<li>A return stack of <code class="language-plaintext highlighter-rouge">JUMPSUB</code> and <code class="language-plaintext highlighter-rouge">JUMPSUBV</code> offsets.</li>
<li>A frame stack of frame pointers.</li>
</ul>
<p>We will adopt the following conventions to describe the machine state:</p>
<ul>
<li>The <em>program counter</em> <code class="language-plaintext highlighter-rouge">PC</code> is (as usual) the byte offset of the currently executing instruction.</li>
<li>The <em>stack pointer</em> <code class="language-plaintext highlighter-rouge">SP</code> corresponds to the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Yellow Paper</a>‚Äôs substate <code class="language-plaintext highlighter-rouge">s</code> of the machine state.
<ul>
<li><code class="language-plaintext highlighter-rouge">SP[0]</code> is where a new item is can be pushed on the stack.</li>
<li><code class="language-plaintext highlighter-rouge">SP[1]</code> is the first item on the stack, which can be popped off the stack.</li>
<li>The stack grows towards lower addresses.</li>
</ul>
</li>
<li>The <em>frame pointer</em> <code class="language-plaintext highlighter-rouge">FP</code> is set to <code class="language-plaintext highlighter-rouge">SP + n_args</code> at entry to the currently executing subroutine.
<ul>
<li>The <em>stack items</em> between the frame pointer and the current stack pointer are called the <em>frame</em>.</li>
<li>The current number of items in the frame, <code class="language-plaintext highlighter-rouge">FP - SP</code>, is the <em>frame size</em>.</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Defining the frame pointer so as to include the arguments is unconventional, but better fits our stack semantics and simplifies the remainder of the proposal.</p>
</blockquote>
<p>The frame pointer and return stacks are internal to the subroutine mechanism, and not directly accessible to the program. This is necessary to prevent the program from modifying its own state in ways that could be invalid.</p>
<p>Execution of EVM bytecode begins with the <em>main</em> routine with no arguments, <code class="language-plaintext highlighter-rouge">SP</code> and <code class="language-plaintext highlighter-rouge">FP</code> set to 0, and with one value on the return stack‚Äî<code class="language-plaintext highlighter-rouge">code_size - 1</code>. (Executing the virtual byte of 0 after this offset causes an EVM to stop. Thus executing a <code class="language-plaintext highlighter-rouge">RETURNSUB</code> with no prior <code class="language-plaintext highlighter-rouge">JUMPSUB</code> or <code class="language-plaintext highlighter-rouge">JUMBSUBV</code>‚Äîthat is, in the <em>main</em> routine‚Äîexecutes a <code class="language-plaintext highlighter-rouge">STOP</code>.)</p>
<p>Execution of a subroutine begins with <code class="language-plaintext highlighter-rouge">JUMPSUB</code> or <code class="language-plaintext highlighter-rouge">JUMPSUBV</code>, which</p>
<ul>
<li>pushes <code class="language-plaintext highlighter-rouge">PC</code> on the return stack,</li>
<li>pushes <code class="language-plaintext highlighter-rouge">FP</code> on the frame stack
<ul>
<li>thus suspending execution of the current subroutine,</li>
</ul>
</li>
<li>sets <code class="language-plaintext highlighter-rouge">FP</code> to <code class="language-plaintext highlighter-rouge">SP + n_args</code>, and</li>
<li>sets <code class="language-plaintext highlighter-rouge">PC</code> to the specified <code class="language-plaintext highlighter-rouge">BEGINSUB</code> address
<ul>
<li>thus beginning execution of the new subroutine.</li>
</ul>
</li>
</ul>
<p>Execution of a subroutine is suspended during and resumed after execution of nested subroutines, and ends upon encountering a <code class="language-plaintext highlighter-rouge">RETURNSUB</code>, which</p>
<ul>
<li>sets <code class="language-plaintext highlighter-rouge">FP</code> to the top of the virtual frame stack and pops the stack,</li>
<li>sets <code class="language-plaintext highlighter-rouge">SP</code> to <code class="language-plaintext highlighter-rouge">FP + n_results</code>,</li>
<li>sets <code class="language-plaintext highlighter-rouge">PC</code> to top of the return stack and pops the stack, and</li>
<li>advances <code class="language-plaintext highlighter-rouge">PC</code> to the next instruction</li>
</ul>
<p>thus resuming execution of the enclosing subroutine or <em>main</em> routine. A <code class="language-plaintext highlighter-rouge">STOP</code> or <code class="language-plaintext highlighter-rouge">RETURN</code> also ends the execution of a subroutine.</p>
<p>For example, starting from this stack,</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_________________
      | locals      20 &lt;- FP
frame |             21
______|___________  22
                       &lt;- SP
</code></pre></div></div>
<p>and after pushing two arguments and branching with <code class="language-plaintext highlighter-rouge">JUMPSUB</code> to a <code class="language-plaintext highlighter-rouge">BEGINSUB 2, 3</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PUSH 10
PUSH 11
JUMPSUB beginsub
</code></pre></div></div>
<p>and initializing three local variables</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PUSH 99
PUSH 98
PUSH 97
</code></pre></div></div>
<p>the stack looks like this</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    20
                    21
__________________  22
      | arguments   10 &lt;- FP
frame |___________  11
      | locals      99
      |             98
______|___________  97
                       &lt;- SP
</code></pre></div></div>
<p>After some amount of computation the stack could look like this</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    20
                    21
__________________  22
      | returns     44 &lt;- FP
      |             43
frame |___________  42
      | locals      13
______|___________  14
                       &lt;- SP
</code></pre></div></div>
<p>and after <code class="language-plaintext highlighter-rouge">RETURNSUB</code> would look like this</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_________________
      | locals      20 &lt;- FP
      |             21
frame |___________  22
      | returns     44
      |             43
______|___________  42
                       &lt;- SP
</code></pre></div></div>
<h3 id="validity">
<a href="#validity" class="anchor-link"></a> Validity
</h3>
<p>We would like to consider EVM code valid iff no execution of the program can lead to an exceptional halting state, but we must validate code in linear time. So our validation does not consider the code‚Äôs data and computations, only its control flow and stack use. This means we will reject programs with invalid code paths, even if those paths are not reachable. Most conditions can be validated, and will not need to be checked at runtime; the exceptions are sufficient gas and sufficient stack. As such, static analysis may yield false negatives belonging to well-understood classes of code requiring runtime checks. Aside from those cases, we can validate large classes at validation time and with linear complexity.</p>
<p><em>Execution</em> is as defined in the <a href="https://ethereum.github.io/yellowpaper/paper.pdf">Yellow Paper</a>‚Äîa sequence of changes in the EVM state. The conditions on valid code are preserved by state changes. At runtime, if execution of an instruction would violate a condition the execution is in an exceptional halting state. The Yellow Paper defines five such states.</p>
<blockquote>
<p><strong>1</strong> Insufficient gas</p>
</blockquote>
<blockquote>
<p><strong>2</strong> More than 1024 stack items</p>
</blockquote>
<blockquote>
<p><strong>3</strong> Insufficient stack items</p>
</blockquote>
<blockquote>
<p><strong>4</strong> Invalid jump destination</p>
</blockquote>
<blockquote>
<p><strong>5</strong> Invalid instruction</p>
</blockquote>
<p>We propose to expand and extend the Yellow Paper conditions to handle the new instructions we propose.</p>
<p>To handle the return stack we expand the conditions on stack size:</p>
<blockquote>
<p><strong>2a</strong> The size of the data stack does not exceed 1024.</p>
</blockquote>
<blockquote>
<p><strong>2b</strong> The size of the return stack does not exceed 1024.</p>
</blockquote>
<p>Given our more detailed description of the data stack we restate condition 3‚Äîstack underflow‚Äîas</p>
<blockquote>
<p><strong>3</strong> <code class="language-plaintext highlighter-rouge">SP</code> must be less than or equal to <code class="language-plaintext highlighter-rouge">FP</code></p>
</blockquote>
<p>Since the various <code class="language-plaintext highlighter-rouge">DUP</code> and <code class="language-plaintext highlighter-rouge">SWAP</code> operations‚Äîas well as <code class="language-plaintext highlighter-rouge">PUTLOCAL</code> and <code class="language-plaintext highlighter-rouge">GETLOCAL</code>‚Äîare defined as taking items off the stack and putting them back on, this prevents them from accessing data below the frame pointer, since taking too many items off of the stack would mean that <code class="language-plaintext highlighter-rouge">SP</code> is less than <code class="language-plaintext highlighter-rouge">FP</code>.</p>
<p>To handle the new jump instructions and subroutine boundaries, we expand the conditions on jumps and jump destinations.</p>
<blockquote>
<p><strong>4a</strong> <code class="language-plaintext highlighter-rouge">JUMPTO</code>, <code class="language-plaintext highlighter-rouge">JUMPIF</code>, and <code class="language-plaintext highlighter-rouge">JUMPV</code> address only <code class="language-plaintext highlighter-rouge">JUMPDEST</code> instructions.</p>
</blockquote>
<blockquote>
<p><strong>4b</strong> <code class="language-plaintext highlighter-rouge">JUMPSUB</code> and <code class="language-plaintext highlighter-rouge">JUMPSUBV</code> address only <code class="language-plaintext highlighter-rouge">BEGINSUB</code> instructions.</p>
</blockquote>
<blockquote>
<p><strong>4c</strong> <code class="language-plaintext highlighter-rouge">JUMP</code> instructions do not address instructions outside of the subroutine they occur in.</p>
</blockquote>
<p>We have two new conditions on execution to ensure consistent use of the stack by subroutines:</p>
<blockquote>
<p><strong>6</strong> For <code class="language-plaintext highlighter-rouge">JUMPSUB</code> and <code class="language-plaintext highlighter-rouge">JUMPSUBV</code> the frame size is at least the <code class="language-plaintext highlighter-rouge">n_args</code> of the <code class="language-plaintext highlighter-rouge">BEGINSUB</code>(s) to jump to.</p>
</blockquote>
<blockquote>
<p><strong>7</strong> For <code class="language-plaintext highlighter-rouge">RETURNSUB</code> the frame size is equal to the <code class="language-plaintext highlighter-rouge">n_results</code> of the enclosing <code class="language-plaintext highlighter-rouge">BEGINSUB</code>.</p>
</blockquote>
<p>Finally, we have one condition that prevents pathological uses of the stack:</p>
<blockquote>
<p><strong>8</strong> For every instruction in the code the frame size is constant.</p>
</blockquote>
<p>In practice, we must test at runtime for conditions 1 and 2‚Äîsufficient gas and sufficient stack. We don‚Äôt know how much gas there will be, we don‚Äôt know how deep a recursion may go, and analysis of stack depth even for non-recursive programs is nontrivial.</p>
<p>All of the remaining conditions we validate statically.</p>
<h4 id="costs--codes">
<a href="#costs--codes" class="anchor-link"></a> Costs &amp; Codes
</h4>
<p>All of the instructions are <code class="language-plaintext highlighter-rouge">O(1)</code> with a small constant, requiring just a few machine operations each, whereas a <code class="language-plaintext highlighter-rouge">JUMP</code> or <code class="language-plaintext highlighter-rouge">JUMPI</code> typically does an <code class="language-plaintext highlighter-rouge">O(log n)</code> binary search of an array of <code class="language-plaintext highlighter-rouge">JUMPDEST</code> offsets before every jump. With the cost of <code class="language-plaintext highlighter-rouge">JUMPI</code> being <em>high</em> and the cost of <code class="language-plaintext highlighter-rouge">JUMP</code> being <em>mid</em>, we suggest the cost of <code class="language-plaintext highlighter-rouge">JUMPV</code> and <code class="language-plaintext highlighter-rouge">JUMPSUBV</code> should be <em>mid</em>, <code class="language-plaintext highlighter-rouge">JUMPSUB</code> and <code class="language-plaintext highlighter-rouge">JUMPIF</code> should be <em>low</em>, and<code class="language-plaintext highlighter-rouge">JUMPTO</code> and the rest should be <em>verylow</em>. Measurement will tell.</p>
<p>We suggest the following opcodes:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0xb0 JUMPTO
0xb1 JUMPIF
0xb2 JUMPV
0xb3 JUMPSUB
0xb4 JUMPSUBV
0xb5 BEGINSUB
0xb6 BEGINDATA
0xb7 RETURNSUB
0xb8 PUTLOCAL
0xb9 GETLOCAL
</code></pre></div></div>
<h2 id="backwards-compatibility">
<a href="#backwards-compatibility" class="anchor-link"></a> Backwards Compatibility
</h2>
<p>These changes would need to be implemented in phases at decent intervals:</p>
<blockquote>
<p><strong>1.</strong> If this EIP is accepted, invalid code should be deprecated. Tools should stop generating invalid code, users should stop writing it, and clients should warn about loading it.</p>
</blockquote>
<blockquote>
<p><strong>2.</strong> A later hard fork would require clients to place only valid code on the block chain. Note that despite the fork old EVM code will still need to be supported indefinitely; older contracts will continue to run, and to create new contracts.</p>
</blockquote>
<p>If desired, the period of deprecation can be extended indefinitely by continuing to accept code not versioned as new‚Äîbut without validation. That is, by delaying or canceling phase 2.</p>
<p>Regardless, we will need a versioning scheme like <a href="/EIPS/eip-1702">EIP-1702</a> to allow current code and EIP-615 code to coexist on the same blockchain.</p>
<h2 id="rationale">
<a href="#rationale" class="anchor-link"></a> Rationale
</h2>
<p>This design was highly constrained by the existing EVM semantics, the requirement for eWasm compatibility, and the security demands of the Ethereum environment. It was also informed by the lead author‚Äôs previous work implementing Java and Scheme interpreters. As such there was very little room for alternative designs.</p>
<p>As described above, the approach was simply to deprecate the problematic dynamic jumps, then ask what opcodes were necessary to provide for the features they supported. These needed to include those provided by eWasm, which themselves were modeled after typical hardware. The only real innovation was to move the frame pointer and the return pointer to their own stacks, so as to prevent any possibility of overwriting them. (Although Forth also uses a return stack.) This allowed for treating subroutine arguments as local variables, and facilitated the return of multiple values.</p>
<h2 id="implementation">
<a href="#implementation" class="anchor-link"></a> Implementation
</h2>
<p>Implementation of this proposal need not be difficult. At the least, interpreters can simply be extended with the new opcodes and run unchanged otherwise. The new opcodes require only stacks for the frame pointers and return offsets and the few pushes, pops, and assignments described above. The bulk of the effort is the validator, which in most languages can almost be transcribed from the pseudocode above.</p>
<p>A lightly tested C++ reference implementation is available in <a href="https://github.com/gcolvin/aleth/tree/master/libaleth-interpreter">Greg Colvin‚Äôs Aleth fork.</a> This version required circa 110 lines of new interpreter code and a well-commented, 178-line validator.</p>
<h2 id="appendix-a">
<a href="#appendix-a" class="anchor-link"></a> Appendix A
</h2>
<h3 id="validation">
<a href="#validation" class="anchor-link"></a> Validation
</h3>
<p>Validation comprises two tasks:</p>
<ul>
<li>Check that jump destinations are correct and instructions valid.</li>
<li>Check that subroutines satisfy the conditions on control flow and stack use.</li>
</ul>
<p>We sketch out these two validation functions in pseudo-C below. To simplify the presentation only the five primitives are handled (<code class="language-plaintext highlighter-rouge">JUMPV</code> and <code class="language-plaintext highlighter-rouge">JUMPSUBV</code> would just add more complexity to loop over their vectors), we assume helper functions for extracting instruction arguments from immediate data and managing the stack pointer and program counter, and some optimizations are forgone.</p>
<h4 id="validating-jumps">
<a href="#validating-jumps" class="anchor-link"></a> Validating Jumps
</h4>
<p>Validating that jumps are to valid addresses takes two sequential passes over the bytecode‚Äîone to build sets of jump destinations and subroutine entry points, another to check that addresses jumped to are in the appropriate sets.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    bytecode[code_size]   // contains EVM bytecode to validate
    is_sub[code_size]     // is there a BEGINSUB at PC?
    is_dest[code_size]    // is there a JUMPDEST at PC?
    sub_for_pc[code_size] // which BEGINSUB is PC in?

    bool validate_jumps(PC)
    {
        current_sub = PC

        // build sets of BEGINSUBs and JUMPDESTs
        for (PC = 0; instruction = bytecode[PC]; PC = advance_pc(PC))
        {
            if instruction is invalid
                return false
            if instruction is BEGINDATA
                break;
            if instruction is BEGINSUB
                is_sub[PC] = true
                current_sub = PC
                sub_for_pc[PC] = current_sub
            if instruction is JUMPDEST
                is_dest[PC] = true
            sub_for_pc[PC] = current_sub
        }

        // check that targets are in subroutine
        for (PC = 0; instruction = bytecode[PC]; PC = advance_pc(PC))
        {
            if instruction is BEGINDATA
                break;
            if instruction is BEGINSUB
                current_sub = PC
            if instruction is JUMPSUB
                if is_sub[jump_target(PC)] is false
                    return false
            if instruction is JUMPTO or JUMPIF
                if is_dest[jump_target(PC)] is false
                    return false
            if sub_for_pc[PC] is not current_sub
                return false
       }
       return true
    }
</code></pre></div></div>
<p>Note that code like this is already run by EVMs to check dynamic jumps, including building the jump destination set every time a contract is run, and doing a lookup in the jump destination set before every jump.</p>
<h4 id="subroutine-validation">
<a href="#subroutine-validation" class="anchor-link"></a> Subroutine Validation
</h4>
<p>This function can be seen as a symbolic execution of a subroutine in the EVM code, where only the effect of the instructions on the state being validated is computed. Thus the structure of this function is very similar to an EVM interpreter. This function can also be seen as an acyclic traversal of the directed graph formed by taking instructions as vertices and sequential and branching connections as edges, checking conditions along the way. The traversal is accomplished via recursion, and cycles are broken by returning when a vertex which has already been visited is reached. The time complexity of this traversal is <code class="language-plaintext highlighter-rouge">O(|E|+|V|)</code>: The sum of the number of edges and number of vertices in the graph.</p>
<p>The basic approach is to call <code class="language-plaintext highlighter-rouge">validate_subroutine(i, 0, 0)</code>, for <code class="language-plaintext highlighter-rouge">i</code> equal to the first instruction in the EVM code through each <code class="language-plaintext highlighter-rouge">BEGINDATA</code> offset. <code class="language-plaintext highlighter-rouge">validate_subroutine()</code> traverses instructions sequentially, recursing when <code class="language-plaintext highlighter-rouge">JUMP</code> and <code class="language-plaintext highlighter-rouge">JUMPI</code> instructions are encountered. When a destination is reached that has been visited before it returns, thus breaking cycles. It returns true if the subroutine is valid, false otherwise.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    bytecode[code_size]     // contains EVM bytecode to validate
    frame_size[code_size ]  // is filled with -1

    // we validate each subroutine individually, as if at top level
    // * PC is the offset in the code to start validating at
    // * return_pc is the top PC on return stack that RETURNSUB returns to
    // * at top level FP = SP = 0 is both the frame size and the stack size
    // * as items are pushed SP get more negative, so the stack size is -SP
    validate_subroutine(PC, return_pc, SP)
    {
        // traverse code sequentially, recurse for jumps
        while true
        {
            instruction = bytecode[PC]

            // if frame size set we have been here before
            if frame_size[PC] &gt;= 0
            {
                // check for constant frame size
                if instruction is JUMPDEST
                    if -SP != frame_size[PC]
                        return false

                // return to break cycle
                return true
            }
            frame_size[PC] = -SP

            // effect of instruction on stack
            n_removed = removed_items(instructions)
            n_added = added_items(instruction)

            // check for stack underflow
            if -SP &lt; n_removed
                return false

            // net effect of removing and adding stack items
            SP += n_removed
            SP -= n_added

            // check for stack overflow
            if -SP &gt; 1024
                return false

            if instruction is STOP, RETURN, or SUICIDE
                return true

            // violates single entry
            if instruction is BEGINSUB
                 return false

            // return to top or from recursion to JUMPSUB
            if instruction is RETURNSUB
                return true;;

            if instruction is JUMPSUB
            {
                // check for enough arguments
                sub_pc = jump_target(PC)
                if -SP &lt; n_args(sub_pc)
                    return false
                return true
            }

            // reset PC to destination of jump
            if instruction is JUMPTO
            {
                PC = jump_target(PC)
                continue
            }

            // recurse to jump to code to validate
            if instruction is JUMPIF
            {
                if not validate_subroutine(jump_target(PC), return_pc, SP)
                    return false
            }

            // advance PC according to instruction
            PC = advance_pc(PC)
        }

        // check for right number of results
        if (-SP != n_results(return_pc)
            return false
        return true
    }
</code></pre></div></div>
<h2 id="appendix-b">
<a href="#appendix-b" class="anchor-link"></a> Appendix B
</h2>
<h3 id="evm-analysis">
<a href="#evm-analysis" class="anchor-link"></a> EVM Analysis
</h3>
<p>There is a large and growing ecosystem of researchers, authors, teachers, auditors, and analytic tools‚Äìproviding software and services focused on the correctness and security of EVM code. A small sample is given here.</p>
<h4 id="some-tools">
<a href="#some-tools" class="anchor-link"></a> Some Tools
</h4>
<ul>
<li><a href="https://contract-library.com/">Contract Library</a></li>
<li><a href="https://github.com/ethereum/ethereumj">EthereumJ</a></li>
<li><a href="https://github.com/exthereum/blockchain">Exthereum</a></li>
<li><a href="https://github.com/ether-camp/ethereum-harmony">Harmony</a></li>
<li><a href="https://www.pnfsoftware.com/blog/ethereum-smart-contract-decompiler/">JEB</a></li>
<li><a href="https://github.com/ConsenSys/mythril">Mythril</a></li>
<li><a href="https://github.com/eth-sri/securify">Securify</a></li>
<li><a href="https://www.skalelabs.com/">Skale</a></li>
<li><a href="https://status.im/">Status</a></li>
</ul>
<h4 id="some-papers">
<a href="#some-papers" class="anchor-link"></a> Some Papers
</h4>
<ul>
<li><a href="https://www.google.com/url?q=http://fsl.cs.illinois.edu/FSL/papers/2018/park-zhang-saxena-daian-rosu-2018-fse/park-zhang-saxena-daian-rosu-2018-fse-public.pdf">A Formal Verification Tool for Ethereum VM Bytecode</a></li>
<li><a href="https://github.com/pirapira/eth-isabelle">A Lem formalization of EVM and some Isabelle/HOL proofs</a></li>
<li><a href="https://eprint.iacr.org/2016/1007.pdf">A survey of attacks on Ethereum smart contracts</a></li>
<li><a href="https://www.google.com/url?q=http://fc17.ifca.ai/wtsc/Defining%2520the%2520Ethereum%2520Virtual%2520Machine%2520for%2520Interactive%2520Theorem%2520Provers.pdf">Defining the Ethereum Virtual Machine for Interactive Theorem Provers</a></li>
<li><a href="https://github.com/ethereum/eth2.0-specs">Ethereum 2.0 Specifications</a></li>
<li><a href="https://www.cs.umd.edu/~aseem/solidetherplas.pdf">Formal Verification of Smart Contracts</a></li>
<li><a href="https://jellopaper.org/">JelloPaper: Human Readable Semantics of EVM in K</a></li>
<li><a href="https://www.ideals.illinois.edu/bitstream/handle/2142/97207/hildenbrandt-saxena-zhu-rodrigues-guth-daian-rosu-2017-tr.pdf">KEVM: A Complete Semantics of the Ethereum Virtual Machine.</a></li>
<li><a href="https://eprint.iacr.org/2016/633.pdf">Making Smart Contracts Smarter</a></li>
<li><a href="https://arxiv.org/pdf/1806.01143.pdf">Securify: Practical Security Analysis of Smart Contracts</a></li>
<li><a href="https://docs.thundercore.com/thunder-whitepaper.pdf">The Thunder Protocol</a></li>
<li><a href="https://ts.data61.csiro.au/publications/csiro_full_text//Amani_BBS_18.pdf">Towards Verifying Ethereum Smart Contract Bytecode in Isabelle/HOL</a>
*<a href="https://github.com/seed/eth-isabelle/tree/evm15">A Lem formalization of EVM 1.5</a></li>
</ul>
<h2 id="copyright">
<a href="#copyright" class="anchor-link"></a> Copyright
</h2>
<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>
<h2>Citation</h2>
<p>Please cite this document as:</p>
<p><a href="/cdn-cgi/l/email-protection#1f786d7a785f7c707369767131706d78">Greg Colvin</a>, <a href="https://github.com/expede">Brooklyn Zelenka</a>, <a href="https://github.com/chfast">Pawe≈Ç Bylica</a>, <a href="https://github.com/chriseth">Christian Reitwiessner</a>, "EIP-615: Subroutines and Static Jumps for the EVM [DRAFT]," <em>Ethereum Improvement Proposals</em>, no. 615, December 2016. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-615.</p>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "TechArticle",
    "headline": "EIP-615: Subroutines and Static Jumps for the EVM [DRAFT]",
    "author": "Greg Colvin <greg@colvin.org>, Brooklyn Zelenka (@expede), Pawe≈Ç Bylica (@chfast), Christian Reitwiessner (@chriseth)",
    "name": "EIP-615: Subroutines and Static Jumps for the EVM [DRAFT]",
    "dateCreated": "2016-12-10",
    "datePublished": "2016-12-10",

    "discussionUrl": "https://ethereum-magicians.org/t/eip-615-subroutines-and-static-jumps-for-the-evm-last-call/3472",
    
    "inLanguage": "en-US",
    "license": "#copyright",
    "copyrightYear": "2016"
  }
</script>
</div>
</main><footer class="site-footer h-card">
<data class="u-url" href="/"></data>
<div class="wrapper">
<h2 class="footer-heading">Ethereum Improvement Proposals</h2>
<div class="footer-col-wrapper">
<div class="footer-col footer-col-1">
<ul class="contact-list">
<li class="p-name">Ethereum Improvement Proposals</li></ul>
</div>
<div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>
<div class="footer-col footer-col-3">
<p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
</div>
</div>
</div>
</footer>
</body>
</html>
