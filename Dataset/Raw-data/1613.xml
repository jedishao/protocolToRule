<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EIP-1613: Gas stations network</title>
<meta property="og:title" content="EIP-1613: Gas stations network" />
<meta name="description" content="" />
<meta property="og:description" content="" />
<meta name="twitter:description" content="" />
<meta name="generator" content="Jekyll" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://eips.ethereum.org/EIPS/eip-1613" />
<meta property="og:url" content="https://eips.ethereum.org/EIPS/eip-1613" />
<meta property="og:site_name" content="Ethereum Improvement Proposals" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "https://eips.ethereum.org",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
<link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="https://eips.ethereum.org/feed.xml" title="Ethereum Improvement Proposals" /><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-nlrDrBTHxJJlDDX22AS33xYI1OJHnGMDhiYMSe2U0e0=" crossorigin="anonymous"></script>
</head>
<body><header class="site-header" role="banner">
<div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav">
<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger">
<span class="menu-icon">
<svg viewBox="0 0 18 15" width="18px" height="15px">
<path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
</svg>
</span>
</label>
<div class="trigger"><a class="page-link" href="/all">All</a><a class="page-link" href="/core">Core</a><a class="page-link" href="/networking">Networking</a><a class="page-link" href="/interface">Interface</a><a class="page-link" href="/erc">ERC</a><a class="page-link" href="/meta">Meta</a><a class="page-link" href="/informational">Informational</a></div>
</nav></div>
</header>
<main class="page-content" aria-label="Content">
<div class="wrapper">
<div class="stagnant">
üöß This EIP had no activity for at least 6 months.
</div>
<div class="home">
<h1 class="page-heading">
EIP-1613: Gas stations network
<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1613.md"><svg role="img" aria-label="Source" xmlns="https://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><title>Source</title><path fill-rule="evenodd" d="M9.5 3L8 4.5 11.5 8 8 11.5 9.5 13 14 8 9.5 3zm-5 0L0 8l4.5 5L6 11.5 2.5 8 6 4.5 4.5 3z" /></svg></a>
</h1>
<h3></h3>
<table>
<tr><th>Author</th><td><a href="/cdn-cgi/l/email-protection#eb92848a9dab9f8a898484808e92c5888486">Yoav Weiss</a>, <a href="/cdn-cgi/l/email-protection#5c382e332e1c283d3e3333373925723f3331">Dror Tirosh</a>, <a href="/cdn-cgi/l/email-protection#f7969b928fb783969598989c928ed994989a">Alex Forshtat</a></td></tr>
<tr><th>Discussions-To</th><td><a href="https://github.com/yoav-tabookey/EIPs/issues/1">https://github.com/yoav-tabookey/EIPs/issues/1</a></td></tr>
<tr><th>Status</th><td>Stagnant
</td></tr>
<tr><th>Type</th><td>Standards Track</td></tr>
<tr><th>Category</th><td>ERC</td></tr>
<tr><th>Created</th><td>2018-11-18</td></tr>
<tr><th>Requires</th><td>
<a href="eip-1077">1077</a>
</td></tr>
</table>
<div class="toc">
<h2>Table of Contents</h2>
<ul>
<li><a href="#simple-summary">Simple Summary</a></li>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#specification">Specification</a></li>
<li><a href="#rationale">Rationale</a></li>
<li><a href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#copyright">Copyright</a></li>
</ul>
</div>
<h2 id="simple-summary">
<a href="#simple-summary" class="anchor-link"></a> Simple Summary
</h2>
<p>Make smart contracts (e.g. dapps) accessible to non-ether users by allowing contracts to accept ‚Äú<a href="https://en.wikipedia.org/wiki/Collect_call">collect-calls</a>‚Äù, paying for incoming calls.
Let contracts ‚Äúlisten‚Äù on publicly accessible channels (e.g. web URL or a whisper address).
Incentivize nodes to run ‚Äúgas stations‚Äù to facilitate this.
Require no network changes, and minimal contract changes.</p>
<h2 id="abstract">
<a href="#abstract" class="anchor-link"></a> Abstract
</h2>
<p>Communicating with dapps currently requires paying ETH for gas, which limits dapp adoption to ether users.
Therefore, contract owners may wish to pay for the gas to increase user acquisition, or let their users pay for gas with fiat money.
Alternatively, a 3rd party may wish to subsidize the gas costs of certain contracts.
Solutions such as described in <a href="/EIPS/eip-1077">EIP-1077</a> could allow transactions from addresses that hold no ETH.</p>
<p>The gas stations network is an <a href="/EIPS/eip-1077">EIP-1077</a> compliant effort to solve the problem by creating an incentive for nodes to run gas stations, where gasless transactions can be ‚Äúfueled up‚Äù.
It abstracts the implementation details from both the dapp maintainer and the user, making it easy to convert existing dapps to accept ‚Äúcollect-calls‚Äù.</p>
<p>The network consists of a single public contract trusted by all participating dapp contracts, and a decentralized network of relay nodes (gas stations) incentivized to listen on non-ether interfaces such as web or whisper,
pay for transactions and get compensated by that contract. The trusted contract can be verified by anyone, and the system is otherwise trustless.
Gas stations cannot censor transactions as long as there‚Äôs at least one honest gas station. Attempts to undermine the system can be proven on-chain and offenders can be penalized.</p>
<h2 id="motivation">
<a href="#motivation" class="anchor-link"></a> Motivation
</h2>
<ul>
<li>Increase user adoption of smart contracts by:
<ul>
<li>Removing the user hassle of acquiring ETH. Transactions are still paid by ETH but costs can be borne by the dapp or paid by the user through other means.</li>
<li>Removing the need to interact directly with the blockchain, while maintaining decentralization and censorship-resistance.
Contracts can ‚Äúlisten‚Äù on multiple public channels, and users can interact with the contracts through common protocols that are generally permitted even in restrictive environments.</li>
</ul>
</li>
<li>Ethereum nodes get a revenue source without requiring mining equipment. The entire network benefits from having more nodes.</li>
<li>No protocol changes required. The gas station network is self-organized via a smart contract, and dapps interact with the network by implementing an interface.</li>
</ul>
<h2 id="specification">
<a href="#specification" class="anchor-link"></a> Specification
</h2>
<p>The system consists of a <code class="language-plaintext highlighter-rouge">RelayHub</code> singleton contract, participating contracts inheriting the <code class="language-plaintext highlighter-rouge">RelayRecipient</code> contract, a decentralized network of <code class="language-plaintext highlighter-rouge">Relay</code> nodes, a.k.a. Gas Stations,
and user applications (e.g. mobile or web) interacting with contracts via relays.</p>
<p>Roles of the <code class="language-plaintext highlighter-rouge">RelayHub</code>:</p>
<ul>
<li>Maintain a list of active relays. Senders select a <code class="language-plaintext highlighter-rouge">Relay</code> from this list for each transaction. The selection process is discussed below.</li>
<li>Mediate all communication between relays and contracts.</li>
<li>Provide contracts with trusted versions of the real msg.sender and msg.data.</li>
<li>Hold ETH stakes placed by relays. A minimum stake size is enforced. Stake can be withdrawn after a relay unregisters and waits for a cooldown period.</li>
<li>Hold ETH prepayments made by contracts and use them to compensate relays.</li>
<li>Penalize provably-offensive relays by giving their stakes to an address providing the proof, thus keeping relays honest.</li>
<li>Provide a free way for relays to know whether they‚Äôll be compensated for a future transaction.</li>
</ul>
<p>Roles of a <code class="language-plaintext highlighter-rouge">Relay</code> node:</p>
<ul>
<li>Maintain a hot wallet with a small amount of ETH, to pay for gas.</li>
<li>Provide a public interface for user apps to send gasless transactions via channels such as https or whisper.</li>
<li>Publish it‚Äôs public interfaces and its price (as a multiplier of the actual transaction gas cost) in <code class="language-plaintext highlighter-rouge">RelayHub</code>.</li>
<li>Optionally monitor reverted transactions of other relays through RelayHub, catching offending relays and claiming their stakes. This can be done by anyone, not just a relay.</li>
</ul>
<p>Implementing a <code class="language-plaintext highlighter-rouge">RelayRecipient</code> contract:</p>
<ul>
<li>Know the address of <code class="language-plaintext highlighter-rouge">RelayHub</code> and trust it to provide information about the transaction.</li>
<li>Maintain a small balance of ETH gas prepayment deposit in <code class="language-plaintext highlighter-rouge">RelayHub</code>. Can be paid directly by the <code class="language-plaintext highlighter-rouge">RelayRecipient</code> contract, or by the dapp‚Äôs owner on behalf of the <code class="language-plaintext highlighter-rouge">RelayRecipient</code> address.
The dapp owner is responsible for ensuring sufficient balance for the next transactions, and can stop depositing if something goes wrong, thus limiting the potential for abuse of system bugs. In DAO usecases it will be up to the DAO logic to maintain a sufficient deposit.</li>
<li>Use <code class="language-plaintext highlighter-rouge">getSender()</code> and <code class="language-plaintext highlighter-rouge">getMessageData()</code> instead of <code class="language-plaintext highlighter-rouge">msg.sender</code> and <code class="language-plaintext highlighter-rouge">msg.data</code>, everywhere. <code class="language-plaintext highlighter-rouge">RelayRecipient</code> provides these functions and gets the information from <code class="language-plaintext highlighter-rouge">RelayHub</code>.</li>
<li>Implement a <code class="language-plaintext highlighter-rouge">acceptRelayedCall(address relay, address from, bytes memory encodedFunction, uint gasPrice, uint transactionFee, bytes memory approval)</code> view function that returns <strong>zero</strong> if and only if it is willing to accept a transaction and pay for it.
<code class="language-plaintext highlighter-rouge">acceptRelayedCall</code> is called by <code class="language-plaintext highlighter-rouge">RelayHub</code> as a view function when a <code class="language-plaintext highlighter-rouge">Relay</code> inquires it, and also during the actual transaction. Transactions are reverted if <strong>non-zero</strong>, and <code class="language-plaintext highlighter-rouge">Relay</code> only gets compensated for transactions (whether successful or reverted) if <code class="language-plaintext highlighter-rouge">acceptRelayedCall</code> returns <strong>zero</strong>. Some examples of <code class="language-plaintext highlighter-rouge">acceptRelayedCall()</code> implementations:
<ul>
<li>Whitelist of trusted dapp members.</li>
<li>Balance sheet of registered users, maintained by the dapp owner. Users pay the dapp with a credit card or other non-ETH means, and are credited in the <code class="language-plaintext highlighter-rouge">RelayRecipient</code> balance sheet.
Users can never cost the dapp more than they were credited for.</li>
<li>A dapp can provide off-chain a signed message called <code class="language-plaintext highlighter-rouge">approval</code> to a transaction sender and validate it.</li>
<li>Whitelist of known transactions used for onboarding new users. This allows certain anonymous calls and is subject to Sybil attacks.
Therefore it should be combined with a restricted gasPrice, and a whitelist of trusted relays, to reduce the incentive for relays to create bogus transactions and rob the dapp‚Äôs prepaid gas deposit.
Dapps allowing anonymous onboarding transactions might benefit from registering their own <code class="language-plaintext highlighter-rouge">Relay</code> and accepting anonymous transactions only from that <code class="language-plaintext highlighter-rouge">Relay</code>, whereas other transactions can be accepted from any relay.
Alternatively, dapps may use the balance sheet method for onboarding as well, by applying the methods suggested in the attacks/mitigations section below.</li>
</ul>
</li>
<li>
<p>Implement <code class="language-plaintext highlighter-rouge">preRelayedCall(address relay, address from, bytes memory encodedFunction, uint transactionFee) returns (bytes32)</code>. This method is called before a transaction is relayed. By default, it does nothing.</p>
</li>
<li>
<p>Implement <code class="language-plaintext highlighter-rouge">postRelayedCall(ddress relay, address from, bytes memory encodedFunction, bool success, uint usedGas, uint transactionFee, bytes32 preRetVal)</code>. This method is called after a transaction is relayed. By default, it does nothing.</p>
<p>These two methods can be used to charge the user in dapp-specific manner.</p>
</li>
</ul>
<p>Glossary of terms used in the processes below:</p>
<ul>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> - the RelayHub singleton contract, used by everyone.</li>
<li><code class="language-plaintext highlighter-rouge">Recipient</code> - a contract implementing <code class="language-plaintext highlighter-rouge">RelayRecipient</code>, accepting relayed transactions from the RelayHub contract and paying for the incoming transactions.</li>
<li><code class="language-plaintext highlighter-rouge">Sender</code> - an external address with a valid key pair but no ETH to pay for gas.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> - a node holding ETH in an external address, listed in RelayHub and relaying transactions from Senders to RelayHub for a fee.</li>
</ul>
<p><img src="/assets/eip-1613/sequence.png" alt="Sequence Diagram" /></p>
<p>The process of registering/refreshing a <code class="language-plaintext highlighter-rouge">Relay</code>:</p>
<ul>
<li>Relay starts listening as a web app (or on some other communication channel).</li>
<li>If starting for the first time (no key yet), generate a key pair for Relay‚Äôs address.</li>
<li>If Relay‚Äôs address doesn‚Äôt hold sufficient funds for gas (e.g. because it was just generated), Relay stays inactive until its owner funds it.</li>
<li>Relay‚Äôs owner funds it.</li>
<li>Relay‚Äôs owner sends the required stake to <code class="language-plaintext highlighter-rouge">RelayHub</code> by calling <code class="language-plaintext highlighter-rouge">RelayHub.stake(address relay, uint unstakeDelay)</code>.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> puts the <code class="language-plaintext highlighter-rouge">owner</code> and <code class="language-plaintext highlighter-rouge">unstake delay</code> in the relays map, indexed by <code class="language-plaintext highlighter-rouge">relay</code> address.</li>
<li>Relay calls <code class="language-plaintext highlighter-rouge">RelayHub.registerRelay(uint transactionFee, string memory url)</code> with the relay‚Äôs <code class="language-plaintext highlighter-rouge">transaction fee</code> (as a multiplier on transaction gas cost), and a URL for incoming transactions.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> ensures that Relay has a sufficient stake.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> puts the <code class="language-plaintext highlighter-rouge">transaction fee</code> in the relays map.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> emits an event, <code class="language-plaintext highlighter-rouge">RelayAdded(Relay, owner, transactionFee, relayStake, unstakeDelay, url)</code>.</li>
<li>Relay starts a timer to perform a <code class="language-plaintext highlighter-rouge">keepalive</code> transaction every 6000 blocks.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> goes to sleep and waits for signing requests.</li>
</ul>
<p>The process of sending a relayed transaction:</p>
<ul>
<li><code class="language-plaintext highlighter-rouge">Sender</code> selects a live <code class="language-plaintext highlighter-rouge">Relay</code> from RelayHub‚Äôs list by looking at <code class="language-plaintext highlighter-rouge">RelayAdded</code> events from <code class="language-plaintext highlighter-rouge">RelayHub</code>, and sorting based on its own criteria. Selection may be based on a mix of:
<ul>
<li>Relay published transaction fees.</li>
<li>Relay stake size and lock-up time.</li>
<li>Recent relay transactions (visible through <code class="language-plaintext highlighter-rouge">TransactionRelayed</code> events from <code class="language-plaintext highlighter-rouge">RelayHub</code>).</li>
<li>Optionally, reputation/blacklist/whitelist held by the sender app itself, or its backend, on per-app basis (not part of the gas stations network).</li>
</ul>
</li>
<li>Sender prepares the transaction with Sender‚Äôs address, the recipient address, the actual transaction data, Relay‚Äôs transaction fee, gas price, gas limit, its current nonce from <code class="language-plaintext highlighter-rouge">RelayHub.nonces</code>, RelayHub‚Äôs address, and Relay‚Äôs address, and then signs it.</li>
<li>Sender verifies that <code class="language-plaintext highlighter-rouge">RelayHub.balances[recipient]</code> holds enough ETH to pay Relay‚Äôs fee.</li>
<li>Sender verifies that <code class="language-plaintext highlighter-rouge">Relay.balance</code> has enough eth to send the transaction</li>
<li>Sender reads the Relay‚Äôs current <code class="language-plaintext highlighter-rouge">nonce</code> value and decides on the <code class="language-plaintext highlighter-rouge">max_nonce</code> parameter.</li>
<li>Sender sends the signed transaction amd metadata to Relay‚Äôs web interface.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> wraps the transaction with a transaction to <code class="language-plaintext highlighter-rouge">RelayHub</code>, with zero ETH value.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> signs the wrapper transaction with its key in order to pay for gas.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> verifies that:
<ul>
<li>The transaction‚Äôs recipient contract will accept this transaction when submitted, by calling <code class="language-plaintext highlighter-rouge">RelayHub.canRelay()</code>, a view function,
which checks the recipient‚Äôs <code class="language-plaintext highlighter-rouge">acceptRelayedCall</code>, also a view function, stating whether it‚Äôs willing to accept the charges).</li>
<li>The transaction nonce matches <code class="language-plaintext highlighter-rouge">RelayHub.nonces[sender]</code>.</li>
<li>The relay address in the transaction matches Relay‚Äôs address.</li>
<li>The transaction‚Äôs recipient has enough ETH deposited in <code class="language-plaintext highlighter-rouge">RelayHub</code> to pay the transaction fee.</li>
<li>Relay has enough ETH to pay for the gas required by the transaction.</li>
<li>Value of <code class="language-plaintext highlighter-rouge">max_nonce</code> is higher than current Relay‚Äôs <code class="language-plaintext highlighter-rouge">nonce</code></li>
</ul>
</li>
<li>If any of Relay‚Äôs checks fail, it returns an error to sender, and doesn‚Äôt proceed.</li>
<li>Relay submits the signed wrapped transaction to the blockchain.</li>
<li>Relay immediately returns the signed wrapped transaction to the sender. This step is discussed below, in attacks/mitigations.</li>
<li><code class="language-plaintext highlighter-rouge">Sender</code> receives the wrapped transaction and verifies that:
<ul>
<li>It‚Äôs a valid relay call to <code class="language-plaintext highlighter-rouge">RelayHub</code>. from Relay‚Äôs address.</li>
<li>The transaction‚Äôs ethereum nonce matches Relay‚Äôs current nonce.</li>
<li>The transaction‚Äôs ethereum nonce is lower than or equal to <code class="language-plaintext highlighter-rouge">max_nonce</code>.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> is sufficiently funded to pay for it.</li>
<li>The wrapped transaction is valid and signed by <code class="language-plaintext highlighter-rouge">sender</code>.</li>
<li>Recipient contract has sufficient funds in <code class="language-plaintext highlighter-rouge">RelayHub.balances</code> to pay for Relay‚Äôs fee as stated in the transaction.</li>
</ul>
</li>
<li>If any of sender‚Äôs checks fails, it goes back to selecting a new Relay. Sender may also file a report on the unresponsive relay to its backend or save it locally, to down-sort this relay in future transactions.</li>
<li><code class="language-plaintext highlighter-rouge">Sender</code> may also submit the raw wrapped transaction to the blockchain without paying for gas, through any Ethereum node.
This submission is likely ignored because an identical transaction is already in the network‚Äôs pending transactions, but no harm in putting it twice, to ensure that it happens.
This step is not strictly necessary, for reasons discussed below in attacks/mitigations, but may speed things up.</li>
<li><code class="language-plaintext highlighter-rouge">Sender</code> monitors the blockchain, waiting for the transaction to be mined.
The transaction was verified, with Relay‚Äôs current nonce, so mining must be successful unless Relay submitted another (different) transaction with the same nonce.
If mining fails due to such attack, sender may call <code class="language-plaintext highlighter-rouge">RelayHub.penalizeRepeatedNonce</code> through another relay, to collect his reward and burn the remainder of the offending relay‚Äôs stake, and then go back to selecting a new Relay for the transaction.
See discussion in the attacks/mitigations section below.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> receives the transaction:
<ul>
<li>Records <code class="language-plaintext highlighter-rouge">gasleft()</code> as <code class="language-plaintext highlighter-rouge">initialGas</code> for later payment.</li>
<li>Verifies the transaction is sent from a registered relay.</li>
<li>Verifies that the signature of the internal transaction matches its stated origin (sender‚Äôs key).</li>
<li>Verifies that the relay address written in the transaction matches msg.sender.</li>
<li>Verifies that the transaction‚Äôs <code class="language-plaintext highlighter-rouge">nonce</code> matches the stated origin‚Äôs nonce in <code class="language-plaintext highlighter-rouge">RelayHub.nonces</code>.</li>
<li>Calls recipient‚Äôs <code class="language-plaintext highlighter-rouge">acceptRelayedCall</code> function, asking whether it‚Äôs going to accept the transaction. If not, the <code class="language-plaintext highlighter-rouge">TransactionRelayed</code> will be emitted with status <code class="language-plaintext highlighter-rouge">CanRelayFailed</code>, and <code class="language-plaintext highlighter-rouge">chargeOrCanRelayStatus</code> will contain the return value of <code class="language-plaintext highlighter-rouge">acceptRelayedCall</code>. In this case, Relay doesn‚Äôt get paid, as it was its responsibility to check <code class="language-plaintext highlighter-rouge">RelayHub.canRelay</code> before releasing the transaction.</li>
<li>Calls recipient‚Äôs <code class="language-plaintext highlighter-rouge">preRelayedCall</code> function. If this call reverts the <code class="language-plaintext highlighter-rouge">TransactionRelayed</code> will be emitted with status <code class="language-plaintext highlighter-rouge">PreRelayedFailed</code>.</li>
<li>Sends the transaction to the recipient. If this call reverts the <code class="language-plaintext highlighter-rouge">TransactionRelayed</code> will be emitted with status <code class="language-plaintext highlighter-rouge">RelayedCallFailed</code>.
When passing gas to <code class="language-plaintext highlighter-rouge">call()</code>, enough gas is preserved by <code class="language-plaintext highlighter-rouge">RelayHub</code>, for post-call handling. Recipient may run out of gas, but <code class="language-plaintext highlighter-rouge">RelayHub</code> never does.
<code class="language-plaintext highlighter-rouge">RelayHub</code> also sends sender‚Äôs address at the end of <code class="language-plaintext highlighter-rouge">msg.data</code>, so <code class="language-plaintext highlighter-rouge">RelayRecipient.getSender()</code> will be able to extract the real sender, and trust it because the transaction came from the known <code class="language-plaintext highlighter-rouge">RelayHub</code> address.</li>
</ul>
</li>
<li>Recipient contract handles the transaction.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> calls recipient‚Äôs <code class="language-plaintext highlighter-rouge">postRelayedCall</code>.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> checks call‚Äôs return value of call, and emits <code class="language-plaintext highlighter-rouge">TransactionRelayed(address relay, address from, address to, bytes4 selector, uint256 status, uint256 chargeOrCanRelayStatus)</code>.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> increases <code class="language-plaintext highlighter-rouge">RelayHub.nonces[sender]</code>.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> transfers ETH balance from recipient to <code class="language-plaintext highlighter-rouge">Relay.owner</code>, to pay the transaction fee, based on the measured transaction cost.
Note on relay payment: The relay gets paid for actual gas used, regardless of whether the recipient reverted.
The only case where the relay sustains a loss, is if <code class="language-plaintext highlighter-rouge">canRelay</code> returns non-zero, since the relay was responsible to verify this view function prior to submitting.
Any other revert is caught and paid for. See attacks/mitigations below.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> keeps track of transactions it sent, and waits for <code class="language-plaintext highlighter-rouge">TransactionRelayed</code> events to see the charge.
If a transaction reverts and goes unpaid, which means the recipient‚Äôs <code class="language-plaintext highlighter-rouge">acceptRelayedCall()</code> function was inconsistent, <code class="language-plaintext highlighter-rouge">Relay</code> refuses service to that recipient for a while (or blacklists it indefinitely, if it happens often).
See attacks/mitigations below.</li>
</ul>
<p>The process of winding a <code class="language-plaintext highlighter-rouge">Relay</code> down:</p>
<ul>
<li>Relay‚Äôs owner (the address that initially funded it) calls <code class="language-plaintext highlighter-rouge">RelayHub.removeRelayByOwner(Relay)</code>.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> ensures that the sender is indeed Relay‚Äôs owner, then removes <code class="language-plaintext highlighter-rouge">Relay</code>, and emits <code class="language-plaintext highlighter-rouge">RelayRemoved(Relay)</code>.</li>
<li><code class="language-plaintext highlighter-rouge">RelayHub</code> starts the countdown towards releasing the owner‚Äôs stake.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> receives its <code class="language-plaintext highlighter-rouge">RelayRemoved</code> event.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> sends all its remaining ETH to its owner.</li>
<li><code class="language-plaintext highlighter-rouge">Relay</code> shuts down.</li>
<li>Once the owner‚Äôs unstake delay is over, owner calls <code class="language-plaintext highlighter-rouge">RelayHub.unstake()</code>, and withdraws the stake.</li>
</ul>
<h2 id="rationale">
<a href="#rationale" class="anchor-link"></a> Rationale
</h2>
<p>The rationale for the gas stations network design is a combination of two sets of requirements: Easy adoption, and robustness.</p>
<p>For easy adoption, the design goals are:</p>
<ul>
<li>No network changes.</li>
<li>Minimal changes to contracts, apps and frameworks.</li>
</ul>
<p>The robustness requirement translates to decentralization and attack resistance. The gas stations network is decentralized, and we have to assume that any entity may attack other entities in the system.</p>
<p>Specifically we‚Äôve considered the following types of attacks:</p>
<ul>
<li>Denial-of-service attacks against individual senders, i.e. transactions censorship.</li>
<li>Denial-of-service and financial attacks against individual relays.</li>
<li>Denial-of-service and financial attacks against individual contracts.</li>
<li>Denial-of-service attacks against the entire network, either by attacking existing entities, or by introducing any number of malicious entities.</li>
</ul>
<h4 id="attacks-and-mitigations">
<a href="#attacks-and-mitigations" class="anchor-link"></a> Attacks and mitigations
</h4>
<h5 id="attack-relay-attempts-to-censor-a-transaction-by-not-signing-it-or-otherwise-ignoring-a-user-request">
<a href="#attack-relay-attempts-to-censor-a-transaction-by-not-signing-it-or-otherwise-ignoring-a-user-request" class="anchor-link"></a> Attack: Relay attempts to censor a transaction by not signing it, or otherwise ignoring a user request.
</h5>
<p>Relay is expected to return the signed transaction to the sender, immediately.
Sender doesn‚Äôt need to wait for the transaction to be mined, and knows immediately whether it‚Äôs request has been served.
If a relay doesn‚Äôt return a signed transaction within a couple of seconds, sender cancels the operation, drops the connection, and switches to another relay.
It also marks Relay as unresponsive in its private storage to avoid using it in the near future.</p>
<p>Therefore, the maximal damage a relay can cause with such attack, is a one-time delay of a couple of seconds. After a while, senders will avoid it altogether.</p>
<h5 id="attack-relay-attempts-to-censor-a-transaction-by-signing-it-returning-it-to-the-sender-but-never-putting-it-on-the-blockchain">
<a href="#attack-relay-attempts-to-censor-a-transaction-by-signing-it-returning-it-to-the-sender-but-never-putting-it-on-the-blockchain" class="anchor-link"></a> Attack: Relay attempts to censor a transaction by signing it, returning it to the sender, but never putting it on the blockchain.
</h5>
<p>This attack will backfire and not censor the transaction.
The sender can submit the transaction signed by Relay to the blockchain as a raw transaction through any node, so the transaction does happen,
but Relay may be unaware and therefore be stuck with a bad nonce which will break its next transaction.</p>
<h5 id="attack-relay-attempts-to-censor-a-transaction-by-signing-it-but-publishing-a-different-transaction-with-the-same-nonce">
<a href="#attack-relay-attempts-to-censor-a-transaction-by-signing-it-but-publishing-a-different-transaction-with-the-same-nonce" class="anchor-link"></a> Attack: Relay attempts to censor a transaction by signing it, but publishing a different transaction with the same nonce.
</h5>
<p>Reusing the nonce is the only DoS performed by a Relay, that cannot be detected within a couple of seconds during the http request.
It will only be detected when the malicious transaction with the same nonce gets mined and triggers the <code class="language-plaintext highlighter-rouge">RelayHub.TransactionRelayed</code> event.
However, the attack will backfire and cost Relay its entire stake.</p>
<p>Sender has a signed transaction from Relay with nonce N, and also gets a mined transaction from the blockchain with nonce N, also signed by Relay.
This proves that Relay performed a DoS attack against the sender.
The sender calls <code class="language-plaintext highlighter-rouge">RelayHub.penalizeRepeatedNonce(bytes transaction1, bytes transaction2)</code>, which verifies the attack, confiscates Relay‚Äôs stake,
and sends half of it to the sender who delivered the <code class="language-plaintext highlighter-rouge">penalizeRepeatedNonce</code> call. The other half of the stake is burned by sending it to <code class="language-plaintext highlighter-rouge">address(0)</code>. Burning is done to prevent cheating relays from effectively penalizing themselves and getting away without any loss.
The sender then proceeds to select a new relay and send the original transaction.</p>
<p>The result of such attack is a delay of a few blocks in sending the transaction (until the attack is detected) but the relay gets removed and loses its entire stake.
Scaling such attack would be prohibitively expensive, and actually quite profitable for senders and honest relays.</p>
<h5 id="attack-relay-attempts-to-censor-a-transaction-by-signing-it-but-using-a-nonce-higher-than-its-current-nonce">
<a href="#attack-relay-attempts-to-censor-a-transaction-by-signing-it-but-using-a-nonce-higher-than-its-current-nonce" class="anchor-link"></a> Attack: Relay attempts to censor a transaction by signing it, but using a nonce higher than it‚Äôs current nonce.
</h5>
<p>In this attack, the Relay did create and return a perfectly valid transaction, but it will not be mined until this Relay fills the gap in the nonce with ‚Äòmissing‚Äô transactions.
This may delay the relaying of some transactions indefinitely. In order to mitigate that, the sender includes a <code class="language-plaintext highlighter-rouge">max_nonce</code> parameter with it‚Äôs signing request.
It is suggested to be higher by 2-3 from current nonce, to allow the relay process several transactions.</p>
<p>When the sender receives a transaction signed by a Relay he validates that the nonce used is valid, and if it is not, the client will ignore the given relay and use other relays to relay given transaction. Therefore, there will be no actual delay introduced by such attack.</p>
<h5 id="attack-dapp-attempts-to-burn-relays-funds-by-implementing-an-inconsistent-acceptrelayedcall-and-using-multiple-sender-addresses-to-generate-expensive-transactions-thus-performing-a-dos-attack-on-relays-and-reducing-their-profitability">
<a href="#attack-dapp-attempts-to-burn-relays-funds-by-implementing-an-inconsistent-acceptrelayedcall-and-using-multiple-sender-addresses-to-generate-expensive-transactions-thus-performing-a-dos-attack-on-relays-and-reducing-their-profitability" class="anchor-link"></a> Attack: Dapp attempts to burn relays funds by implementing an inconsistent acceptRelayedCall() and using multiple sender addresses to generate expensive transactions, thus performing a DoS attack on relays and reducing their profitability.
</h5>
<p>In this attack, a contract sets an inconsistent acceptRelayedCall (e.g. return zero for even blocks, nonzero for odd blocks), and uses it to exhaust relay resources through unpaid transactions.
Relays can easily detect it after the fact.
If a transaction goes unpaid, the relay knows that the recipient contract‚Äôs acceptRelayedCall has acted inconsistently, because the relay has verified its view function before sending the transaction.
It might be the result of a rare race condition where the contract‚Äôs state has changed between the view call and the transaction, but if it happens too frequently, relays will blacklist this contract and refuse to serve transactions to it.
Each offending contract can only cause a small damage (e.g. the cost of 2-3 transactions) to a relay, before getting blacklisted.</p>
<p>Relays may also look at recipients‚Äô history on the blockchain, looking for past unpaid transactions (reverted by RelayHub without pay), and denying service to contracts with a high failure rate.
If a contract caused this minor loss to a few relays, all relays will stop serving it, so it can‚Äôt cause further damage.</p>
<p>This attack doesn‚Äôt scale because the cost of creating a malicious contract is in the same order of magnitude as the damage it can cause to the network.
Causing enough damage to exhaust the resources of all relays, would be prohibitively expensive.</p>
<p>The attack can be made even more impractical by setting RelayHub to require a stake from dapps before they can be served, and enforcing an unstaking delay,
so that attackers will have to raise a vast amount of ETH in order to simultaneously create enough malicious contracts and attack relays.
This protection is probably an overkill, since the attack doesn‚Äôt scale regardless.</p>
<h5 id="attack-user-attempts-to-rob-dapps-by-registering-its-own-relay-and-sending-expensive-transactions-to-dapps">
<a href="#attack-user-attempts-to-rob-dapps-by-registering-its-own-relay-and-sending-expensive-transactions-to-dapps" class="anchor-link"></a> Attack: User attempts to rob dapps by registering its own relay and sending expensive transactions to dapps.
</h5>
<p>If a malicious sender repeatedly abuses a recipient by sending meaningless/reverted transactions and causing the recipient to pay a relay for nothing,
it is the recipient‚Äôs responsibility to blacklist that sender and have its acceptRelayedCall function return nonzero for that sender.
Collect calls are generally not meant for anonymous senders unknown to the recipient.
Dapps that utilize the gas station networks should have a way to blacklist malicious users in their system and prevent Sybil attacks.</p>
<p>A simple method that mitigates such Sybil attack, is that the dapp lets users buy credit with a credit card, and credit their account in the dapp contract,
so acceptRelayedCall() only returns zero for users that have enough credit, and deduct the amount paid to the relay from the user‚Äôs balance, whenever a transaction is relayed for the user.
With this method, the attacker can only burn its own resources, not the dapp‚Äôs.</p>
<p>A variation of this method, for free dapps (that don‚Äôt charge the user, and prefer to pay for their users transactions) is to require a captcha during user creation in their web interface,
or to login with a Google/Facebook account, which limits the rate of the attack to the attacker‚Äôs ability to open many Google/Facebook accounts.
Only a user that passed that process is given credit in RelayRecipient. The rate of such Sybil attack would be too low to cause any real damage.</p>
<h5 id="attack-attacker-attempts-to-reduce-network-availability-by-registering-many-unreliable-relays">
<a href="#attack-attacker-attempts-to-reduce-network-availability-by-registering-many-unreliable-relays" class="anchor-link"></a> Attack: Attacker attempts to reduce network availability by registering many unreliable relays.
</h5>
<p>Registering a relay requires placing a stake in RelayHub, and the stake can only be withdrawn after the relay is unregistered and a long cooldown period has passed, e.g. a month.</p>
<p>Each unreliable relay can only cause a couple of seconds delay to senders, once, and then it gets blacklisted by them, as described in the first attack above.
After it caused this minor delay and got blacklisted, the attacker must wait a month before reusing the funds to launch another unreliable relay.
Simultaneously bringing up a number of unreliable relays, large enough to cause a noticeable network delay, would be prohibitively expensive due to the required stake,
and even then, all those relays will get blacklisted within a short time.</p>
<h5 id="attack-attacker-attempts-to-replay-a-relayed-transaction">
<a href="#attack-attacker-attempts-to-replay-a-relayed-transaction" class="anchor-link"></a> Attack: Attacker attempts to replay a relayed transaction.
</h5>
<p>Transactions include a nonce. RelayHub maintains a nonce (counter) for each sender. Transactions with bad nonces get reverted by RelayHub. Each transaction can only be relayed once.</p>
<h5 id="attack-user-does-not-execute-the-raw-transaction-received-from-the-relayer-therefore-blocking-the-execution-of-all-further-transactions-signed-by-this-relayer">
<a href="#attack-user-does-not-execute-the-raw-transaction-received-from-the-relayer-therefore-blocking-the-execution-of-all-further-transactions-signed-by-this-relayer" class="anchor-link"></a> Attack: User does not execute the raw transaction received from the Relayer, therefore blocking the execution of all further transactions signed by this relayer
</h5>
<p>The user doesn‚Äôt really have to execute the raw transaction. It‚Äôs enough that the user can. The relationship between relay and sender is mutual distrust. The process described above incentivizes the relay to execute the transaction, so the user doesn‚Äôt need to wait for actual mining to know that the transaction has been executed.</p>
<p>Once relay returns the signed transaction, which should happen immediately, the relay is incentivized to also execute it on chain, so that it can advance its nonce and serve the next transaction. The user can (but doesn‚Äôt have to) also execute the transaction. To understand why the attack isn‚Äôt viable, consider the four possible scenarios after the signed transaction was returned to the sender:</p>
<ol>
<li>Relay executes the transaction, and the user doesn‚Äôt. In this scenario the transaction is executed, so no problem. This is the case described in this attack.</li>
<li>Relay doesn‚Äôt execute the transaction, but the user does. Similarly to 1, the transaction is executed, so no problem.</li>
<li>Both of them execute the transaction. The transactions are identical in the pending transactions pool, so the transaction gets executed once. No problem.</li>
<li>None of them execute the transaction. In this case the transaction doesn‚Äôt get executed, but the relay is stuck. It can‚Äôt serve the next transaction with the next nonce, because its nonce hasn‚Äôt been advanced on-chain. It also can‚Äôt serve the next transaction with the current nonce, as this can be proven by the user, having two different transactions signed by the same relay, with the same nonce. The user could use this to take the relay‚Äôs nonce. So the relay is stuck unless it executes the transaction.</li>
</ol>
<p>As this matrix shows, the relay is <strong>always</strong> incentivized to execute the transaction, once it returned it to the user, in order to end up in #1 or #3, and avoid the risk of #4. It‚Äôs just a way to commit the relay to do its work, without requiring the user to wait for on-chain confirmation.</p>
<h2 id="backwards-compatibility">
<a href="#backwards-compatibility" class="anchor-link"></a> Backwards Compatibility
</h2>
<p>The gas stations network is implemented as smart contracts and external entities, and does not require any network changes.</p>
<p>Dapps adding gas station network support remain backwards compatible with their existing apps/users. The added methods apply on top of the existing ones, so no changes are required for existing apps.</p>
<h2 id="implementation">
<a href="#implementation" class="anchor-link"></a> Implementation
</h2>
<p>A working implementation of the <a href="https://github.com/tabookey-dev/tabookey-gasless"><strong>gas stations network</strong></a> is being developed by <strong>TabooKey</strong>. It consists of <code class="language-plaintext highlighter-rouge">RelayHub</code>, <code class="language-plaintext highlighter-rouge">RelayRecipient</code>, <code class="language-plaintext highlighter-rouge">web3 hooks</code>, an implementation of a gas station inside <code class="language-plaintext highlighter-rouge">geth</code>, and sample dapps using the gas stations network.</p>
<h2 id="copyright">
<a href="#copyright" class="anchor-link"></a> Copyright
</h2>
<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>
<h2>Citation</h2>
<p>Please cite this document as:</p>
<p><a href="/cdn-cgi/l/email-protection#661f0907102612070409090d031f4805090b">Yoav Weiss</a>, <a href="/cdn-cgi/l/email-protection#1571677a67556174777a7a7e706c3b767a78">Dror Tirosh</a>, <a href="/cdn-cgi/l/email-protection#640508011c241005060b0b0f011d4a070b09">Alex Forshtat</a>, "EIP-1613: Gas stations network [DRAFT]," <em>Ethereum Improvement Proposals</em>, no. 1613, November 2018. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-1613.</p>
</div>
<script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "TechArticle",
    "headline": "EIP-1613: Gas stations network [DRAFT]",
    "author": "Yoav Weiss <yoav@tabookey.com>, Dror Tirosh <dror@tabookey.com>, Alex Forshtat <alex@tabookey.com>",
    "name": "EIP-1613: Gas stations network [DRAFT]",
    "dateCreated": "2018-11-18",
    "datePublished": "2018-11-18",

    "discussionUrl": "https://github.com/yoav-tabookey/EIPs/issues/1",
    
    "inLanguage": "en-US",
    "license": "#copyright",
    "copyrightYear": "2018"
  }
</script>
</div>
</main><footer class="site-footer h-card">
<data class="u-url" href="/"></data>
<div class="wrapper">
<h2 class="footer-heading">Ethereum Improvement Proposals</h2>
<div class="footer-col-wrapper">
<div class="footer-col footer-col-1">
<ul class="contact-list">
<li class="p-name">Ethereum Improvement Proposals</li></ul>
</div>
<div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>
<div class="footer-col footer-col-3">
<p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
</div>
</div>
</div>
</footer>
</body>
</html>
