Transfers _value amount of tokens to address _to, and MUST fire the Transfer event.
Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.
MUST trigger when tokens are transferred, including zero value transfers.
MUST trigger on any successful call to approve(address _spender, uint256 _value).
Changes to an address MUST trigger the following event:
MUST be triggered when execute creates a new call using the operationType 0, 3, 4.
MUST be triggered when execute creates a new contract using the operationType 1, 2.
MUST be triggered when setData was successfully called.
When an address becomes an operator for a holder, an AuthorizedOperator event MUST be emitted.
When an address becomes an operator for a holder, an AuthorizedOperator event MUST be emitted.
When a holder revokes an operator, a RevokedOperator event MUST be emitted.
When a holder revokes an operator, a RevokedOperator event MUST be emitted.
AuthorizedOperator events MUST NOT be emitted when defining the default operators.
An AuthorizedOperator MUST be emitted each time.
A RevokedOperator MUST be emitted each time.
NOTE: This event MUST NOT be emitted outside of an operator authorization process.
NOTE: This event MUST NOT be emitted outside of an operator revocation process.
NOTE: This event MUST NOT be emitted outside of a send or an ERC-20 transfer process
While a Sent event MUST NOT be emitted when minting,
NOTE: This event MUST NOT be emitted outside of a mint process.
While a Sent event MUST NOT be emitted when burning;
NOTE: This event MUST NOT be emitted outside of a burn process.
During a send, mint and burn, the respective Sent, Minted and Burned events MUST be emitted.
and MUST emit a Transfer event for sending (as specified in the ERC-20 standard).
During an ERC-20’s transfer or transferFrom functions, a valid Sent event MUST be emitted.
During a send, mint and burn, the respective Sent, Minted and Burned events MUST be emitted.
and MUST emit a Transfer event for sending (as specified in the ERC-20 standard).
During an ERC-20’s transfer or transferFrom functions, a valid Sent event MUST be emitted.
During a send, mint and burn, the respective Sent, Minted and Burned events MUST be emitted.
and MUST emit a Transfer event for sending (as specified in the ERC-20 standard).
During an ERC-20’s transfer or transferFrom functions, a valid Sent event MUST be emitted.
MUST trigger when the contract is called the first time after the canary died.
MUST trigger Staked event.
MUST trigger Staked event.
MUST trigger Unstaked event.
This event MUST be fired on return from a call to a TokenValidator.check/2.
This event MUST be fired on return from a call to a TokenValidator.check/4.
This function transfers an amount of tokens from a user address to an ERC721 token. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address. This function MUST emit the TransferToParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the _from account balance does not have enough tokens to spend.
This function transfers an amount of tokens from a user address to an ERC721 token. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address. This function MUST emit the TransferToParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the _from account balance does not have enough tokens to spend.
This function transfers an amount of tokens from a user address to an ERC721 token. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address. This function MUST emit the TransferToParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the _from account balance does not have enough tokens to spend.
This function transfers an amount of tokens from an ERC721 token to an address. This function MUST emit the TransferFromParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise.
This function transfers an amount of tokens from an ERC721 token to an address. This function MUST emit the TransferFromParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise.
This function transfers an amount of tokens from an ERC721 token to an address. This function MUST emit the TransferFromParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise.
This function transfers an amount of tokens from an ERC721 token to an address. This function MUST emit the TransferFromParent event upon a successful transfer (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
This function transfers an amount of tokens from an ERC721 token to another ERC721 token. This function MUST emit BOTH the TransferFromParent and TransferToParent events (in addition to the standard ERC20 Transfer event!). This function MUST throw if the balance of the sender ERC721 token is less than the _amount specified. This function MUST verify that the msg.sender owns the sender ERC721 token, and MUST throw otherwise. This function MUST ensure that the recipient contract implements ERC721 using the ERC165 supportsInterface function. This function SHOULD ensure that the recipient token actually exists, by calling ownerOf on the recipient token’s contract, and ensuring it neither throws nor returns the zero address.
For backwards-compatibility, implementations MUST emit the standard ERC20 Transfer event when a transfer occurs, regardless of whether the sender and recipient are addresses or ERC721 tokens. In the case that either sender or recipient are tokens, the corresponding parameter in the Transfer event SHOULD be the contract address of the token.
MUST be triggered when changeOwner or changeOwnerSigned was successfully called.
MUST be triggered when a change to a delegate was successfully made.
MUST be triggered when a change to an attribute was successfully made.
Reports the lostAccount address as being lost. MUST trigger the AccountClaimedLost event.
Reports the msg.sender’s account as being not being lost. MUST trigger the AccountClaimedLostCanceled event.
Reports the current address as being stolen. MUST trigger the AccountFrozen event.
Reports the current address as being stolen. MUST trigger the AccountFrozen event.
A record of an account being frozen. MUST trigger when an account is frozen.
MUST trigger when new announcement is created.
MUST trigger when an announcement is removed.
The requirement to emit TransferSingle or TransferBatch on balance change implies that a valid implementation of ERC-1155 redeploying to a new contract address MUST emit events from the new contract address to replicate the deprecated contract final state. It is valid to only emit a minimal number of events to reflect only the final balance and omit all the transactions that led to that state. The event emit requirement is to ensure that the current state of the contract can always be traced only through events. To alleviate the need to emit events when changing contract address, consider using the proxy pattern, such as described in EIP-2535. This will also have the added benefit of providing a stable contract address for users.
An important consideration is that even if the tokens are sent with another standard’s rules the ERC-1155 transfer events MUST still be emitted. This is so the balances can still be determined via events alone as per ERC-1155 standard rules.
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Successful completion of this method MUST emit an Approval event (defined below) unless the caller is attempting to clear approval when there is no pending approval. In particular, an Approval event MUST be fired if the _to address is zero and there is some outstanding approval. Additionally, an Approval event MUST be fired if _to is already the currently approved address and this call otherwise has no effect. (i.e. An approve() call that “reaffirms” an existing approval MUST fire an event.)
Assigns the ownership of quantity MCFT’s with ID _classId to _to if and only if quantity == balanceOf(msg.sender, _classId). A successful transfer MUST fire the Transfer event (defined below).
A conforming contract MUST allow the current owner to “transfer” a token to themselves, as a way of affirming ownership in the event stream. (i.e. it is valid for _to == msg.sender if balanceOf(msg.sender, _classId) >= balance.) This “no-op transfer” MUST be considered a successful transfer, and therefore MUST fire a Transfer event (with the same address for _from and _to).
A conforming contract MUST allow the current owner to “transfer” a token to themselves, as a way of affirming ownership in the event stream. (i.e. it is valid for _to == msg.sender if balanceOf(msg.sender, _classId) >= balance.) This “no-op transfer” MUST be considered a successful transfer, and therefore MUST fire a Transfer event (with the same address for _from and _to).
A conforming contract MUST allow the current owner to “transfer” a token to themselves, as a way of affirming ownership in the event stream. (i.e. it is valid for _to == msg.sender if balanceOf(msg.sender, _classId) >= balance.) This “no-op transfer” MUST be considered a successful transfer, and therefore MUST fire a Transfer event (with the same address for _from and _to).
This event MUST trigger when MCFT ownership is transferred via any mechanism.
Additionally, the creation of new MCFTs MUST trigger a Transfer event for each newly created MCFTs, with a _from address of 0 and a _to address matching the owner of the new MCFT (possibly the smart contract itself). The deletion (or burn) of any MCFT MUST trigger a Transfer event with a _to address of 0 and a _from address of the owner of the MCFT (now former owner!).
Additionally, the creation of new MCFTs MUST trigger a Transfer event for each newly created MCFTs, with a _from address of 0 and a _to address matching the owner of the new MCFT (possibly the smart contract itself). The deletion (or burn) of any MCFT MUST trigger a Transfer event with a _to address of 0 and a _from address of the owner of the MCFT (now former owner!).
Additionally, the creation of new MCFTs MUST trigger a Transfer event for each newly created MCFTs, with a _from address of 0 and a _to address matching the owner of the new MCFT (possibly the smart contract itself). The deletion (or burn) of any MCFT MUST trigger a Transfer event with a _to address of 0 and a _from address of the owner of the MCFT (now former owner!).
Additionally, the creation of new MCFTs MUST trigger a Transfer event for each newly created MCFTs, with a _from address of 0 and a _to address matching the owner of the new MCFT (possibly the smart contract itself). The deletion (or burn) of any MCFT MUST trigger a Transfer event with a _to address of 0 and a _from address of the owner of the MCFT (now former owner!).
This event MUST trigger on any successful call to approve(_to, _classId, quantity) (unless the caller is attempting to clear approval when there is no pending approval).
When emitted, the message event MUST be emitted with an object argument of the following form:
If the Provider supports Ethereum RPC subscriptions, e.g. eth_subscribe, the Provider MUST emit the message event when it receives a subscription notification.
If the Provider receives a subscription message from e.g. an eth_subscribe subscription, the Provider MUST emit a message event with a ProviderMessage object of the following form:
If the Provider becomes connected, the Provider MUST emit the event named connect.
This event MUST be emitted with an object of the following form:
If the Provider becomes disconnected from all chains, the Provider MUST emit the event named disconnect with value error: ProviderRpcError, per the interfaced defined in the RPC Errors section. The value of the error’s code property MUST follow the status codes for CloseEvent.
If the Provider becomes disconnected from all chains, the Provider MUST emit the event named disconnect with value error: ProviderRpcError, per the interfaced defined in the RPC Errors section. The value of the error’s code property MUST follow the status codes for CloseEvent.
If the chain the Provider is connected to changes, the Provider MUST emit the event named chainChanged with value chainId: string, specifying the integer ID of the new chain as a hexadecimal string, per the eth_chainId Ethereum RPC method.
If the accounts available to the Provider change, the Provider MUST emit the event named accountsChanged with value accounts: string[], containing the account addresses per the eth_accounts Ethereum RPC method.
MUST be triggered when release is successfully called.
MUST be triggered when an Identity is created.
MUST be triggered when an address is added to an Identity.
MUST be triggered when an address is removed from an Identity.
MUST be triggered when a provider is added to an Identity.
MUST be triggered when a provider is removed.
MUST be triggered when a resolver is added.
MUST be triggered when a resolver is removed.
MUST be triggered when a recovery address change is triggered.
MUST be triggered when recovery is triggered.
MUST be triggered when an Identity is destroyed.
MUST be triggered when create is successfully called.
MUST be triggered when withdraw is successfully called.
MUST be triggered when redeem is successfully called.
MUST be triggered when confirmUpdate is successfully called.
MUST be triggered when revokeUpdate is successfully called.
MUST be triggered when an update is approved by all involved parties.
Resolvers MUST emit this event on each change to the address for a name and coin type.
When emitting the ConsecutiveTransfer event the Transfer event MUST NOT be emitted
Contracts that implement the ConsecutiveTransfer event MAY still use the original Transfer event, however when emitting the ConsecutiveTransfer event the Transfer event MUST NOT be emitted.
In ALL cases any function or code that adds or replaces or removes one or more functions MUST emit the standard DiamondCut event specified below.
Any time one or more functions are added, replaced or removed the DiamondCut event MUST be emitted to record changes.
The Provider MUST emit a connect event to all attached EIP-2700 listeners if it transitions from a disconnected state to a connected state.
The Provider MUST emit a connect event to all attached EIP-2700 listeners if it transitions from a disconnected state to a connected state.
The Provider MUST emit a connect event to all attached EIP-2700 listeners if it transitions from a disconnected state to a connected state.
The Provider MUST emit a connect event to all attached EIP-2700 listeners if it transitions from a disconnected state to a connected state.
To ensure the indexing of transactions throughout the bond lifecycle (i.e “Issue”, “Redeem” and “Transfer” functions), events cited in specification section MUST be emitted when such transaction is passed.
Smart contracts implementing this EIP standard MUST implement all of the functions in this EIP interface. MUST also emit the events specified in the interface so that a complete state of the tip token contract can be derived from the events emitted alone.
Smart contracts implementing this EIP standard MUST implement all of the functions in this EIP interface. MUST also emit the events specified in the interface so that a complete state of the tip token contract can be derived from the events emitted alone.
If not inheriting from ERC-20, then minting the tip tokens MUST emit event Transfer(address indexed from, address indexed to, uint256 value) where sender is the zero address for a mint and to is the zero address for a burn. The Transfer event MUST be the same signature as the Transfer function in the IERC20 interface.
If not inheriting from ERC-20, then minting the tip tokens MUST emit event Transfer(address indexed from, address indexed to, uint256 value) where sender is the zero address for a mint and to is the zero address for a burn. The Transfer event MUST be the same signature as the Transfer function in the IERC20 interface.
The ConsumerChanged event MUST be emitted when a consumer is changed.
For all addresses spender, uint256s tokenId, deadline, and nonce, and bytes sig, a call to permit(spender, tokenId, deadline, sig) MUST set spender as approved on tokenId as long as the owner of tokenId remains in possession of it, and MUST emit a corresponding Approval event, if and only if the following conditions are met:
For all addresses spender, uint256s tokenId, deadline, and nonce, and bytes sig, a call to permit(spender, tokenId, deadline, sig) MUST set spender as approved on tokenId as long as the owner of tokenId remains in possession of it, and MUST emit a corresponding Approval event, if and only if the following conditions are met:
The interface for ERC-4521 transfer() MUST conform to ERC-20 and resulting transfers MUST fire the Transfer event as described in ERC-721.
The interface for ERC-4521 transfer() MUST conform to ERC-20 and resulting transfers MUST fire the Transfer event as described in ERC-721.
MUST emit the Deposit event.
MUST emit the Deposit event.
MUST emit the Withdraw event.
MUST emit the Withdraw event.
MUST be emitted when tokens are deposited into the Vault via the mint and deposit methods.
MUST be emitted when shares are withdrawn from the Vault in EIP-4626.redeem or EIP-4626.withdraw methods.
The MetadataUpdate or BatchMetadataUpdate event MUST be emitted when the JSON metadata of a token, or a consecutive range of tokens, is changed.
The UpdateUser event MUST be emitted when a user address is changed or the user expires is changed.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Upgrades the amount of source token to the destination token in the specified ratio. The destination tokens will be sent to the _to address. The function MUST lock the source tokens in the upgrade contract or burn them. If the downgrade Optional Ext. is implemented, the source tokens MUST be locked instead of burning. The function MUST throw if the caller’s address does not have enough source token to upgrade or if isUpgradeActive is returning false. The function MUST also fire the Upgrade event. approve MUST be called first on the source contract.
Downgrades the amount of destination token to the source token in the specified ratio. The source tokens will be sent to the _to address. The function MUST unwrap the destination tokens back to the source tokens. The function MUST throw if the caller’s address does not have enough destination token to downgrade or if isDowngradeActive is returning false. The function MUST also fire the Downgrade event. approve MUST be called first on the destination contract.
Downgrades the amount of destination token to the source token in the specified ratio. The source tokens will be sent to the _to address. The function MUST unwrap the destination tokens back to the source tokens. The function MUST throw if the caller’s address does not have enough destination token to downgrade or if isDowngradeActive is returning false. The function MUST also fire the Downgrade event. approve MUST be called first on the destination contract.
Downgrades the amount of destination token to the source token in the specified ratio. The source tokens will be sent to the _to address. The function MUST unwrap the destination tokens back to the source tokens. The function MUST throw if the caller’s address does not have enough destination token to downgrade or if isDowngradeActive is returning false. The function MUST also fire the Downgrade event. approve MUST be called first on the destination contract.
Downgrades the amount of destination token to the source token in the specified ratio. The source tokens will be sent to the _to address. The function MUST unwrap the destination tokens back to the source tokens. The function MUST throw if the caller’s address does not have enough destination token to downgrade or if isDowngradeActive is returning false. The function MUST also fire the Downgrade event. approve MUST be called first on the destination contract.
MUST trigger when tokens are upgraded.
MUST trigger when tokens are downgraded.
MUST emit the Redeem event.
MUST emit the Redeem event.
MUST be emitted when Principal Tokens are burnt and underlying is withdrawn from the contract in the EIP5095.redeem method.
MUST emit the Deposit event.
MUST emit the Deposit event.
MUST emit the Withdraw event.
MUST emit the Withdraw event.
The ApprovalByAmount event MUST be emitted when a certain number of tokens are approved.
The UpdateUser event MUST be emitted when a user address is changed or the user expires is changed or the user level is changed.
The SlotAuthorizationCreated event MUST be emitted when a slot is authorized to an address.
The SlotAuthorizationRevoked event MUST be emitted when a slot authorization is revoked.
The PrivilegeAssigned event MUST be emitted when setPrivilege is called.
The PrivilegeTransfered event MUST be emitted when transferPrivilege is called.
The PrivilegeCloned event MUST be emitted when clonePrivilege is called.