<!DOCTYPE html>
<html lang="en"><head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>EIP-4881: Deposit Contract Snapshot Interface</title>
<meta property="og:title" content="EIP-4881: Deposit Contract Snapshot Interface" />
<meta name="description" content="Standardizing the format and endpoint for transmitting a snapshot of the deposit Merkle tree" />
<meta property="og:description" content="Standardizing the format and endpoint for transmitting a snapshot of the deposit Merkle tree" />
<meta name="twitter:description" content="Standardizing the format and endpoint for transmitting a snapshot of the deposit Merkle tree" />
<meta name="generator" content="Jekyll" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="https://eips.ethereum.org/EIPS/eip-4881" />
<meta property="og:url" content="https://eips.ethereum.org/EIPS/eip-4881" />
<meta property="og:site_name" content="Ethereum Improvement Proposals" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@" />
<script type="application/ld+json">
    {
      "@type": "WebSite",
      "url": "https://eips.ethereum.org",
      "name": "Ethereum Improvement Proposals",
      "description": "Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.",
      "@context": "https://schema.org"
    }
  </script>
<link rel="stylesheet" href="/assets/css/style.css" /><link type="application/atom+xml" rel="alternate" href="https://eips.ethereum.org/feed.xml" title="Ethereum Improvement Proposals" /><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha256-nlrDrBTHxJJlDDX22AS33xYI1OJHnGMDhiYMSe2U0e0=" crossorigin="anonymous"></script>
</head>
<body><header class="site-header" role="banner">
<div class="wrapper"><a class="site-title" rel="author" href="/">Ethereum Improvement Proposals</a><nav class="site-nav">
<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger">
<span class="menu-icon">
<svg viewBox="0 0 18 15" width="18px" height="15px">
<path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
</svg>
</span>
</label>
<div class="trigger"><a class="page-link" href="/all">All</a><a class="page-link" href="/core">Core</a><a class="page-link" href="/networking">Networking</a><a class="page-link" href="/interface">Interface</a><a class="page-link" href="/erc">ERC</a><a class="page-link" href="/meta">Meta</a><a class="page-link" href="/informational">Informational</a></div>
</nav></div>
</header>
<main class="page-content" aria-label="Content">
<div class="wrapper">
<div class="draft">
⚠️ This EIP is not recommended for general use or implementation as it is likely to change.
</div>
<div class="home">
<h1 class="page-heading">
EIP-4881: Deposit Contract Snapshot Interface
<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4881.md"><svg role="img" aria-label="Source" xmlns="https://www.w3.org/2000/svg" width="14" height="16" viewBox="0 0 14 16"><title>Source</title><path fill-rule="evenodd" d="M9.5 3L8 4.5 11.5 8 8 11.5 9.5 13 14 8 9.5 3zm-5 0L0 8l4.5 5L6 11.5 2.5 8 6 4.5 4.5 3z" /></svg></a>
</h1>
<h3>Standardizing the format and endpoint for transmitting a snapshot of the deposit Merkle tree</h3>
<table>
 <tr><th>Author</th><td><a href="https://github.com/ethDreamer">Mark Mackey</a></td></tr>
<tr><th>Discussions-To</th><td><a href="https://ethereum-magicians.org/t/eip-4881-deposit-contract-snapshot-interface/">https://ethereum-magicians.org/t/eip-4881-deposit-contract-snapshot-interface/</a></td></tr>
<tr><th>Status</th><td>Draft
</td></tr>
<tr><th>Type</th><td>Standards Track</td></tr>
<tr><th>Category</th><td>Interface</td></tr>
<tr><th>Created</th><td>2021-01-29</td></tr>
</table>
<div class="toc">
<h2>Table of Contents</h2>
<ul>
<li><a href="#abstract">Abstract</a></li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#specification">Specification</a>
<ul>
<li><a href="#deposit-finalization-flow">Deposit Finalization Flow</a></li>
</ul>
</li>
<li><a href="#rationale">Rationale</a>
<ul>
<li><a href="#why-not-reconstruct-the-tree-directly-from-the-deposit-contract">Why not Reconstruct the Tree Directly from the Deposit Contract?</a></li>
<li><a href="#why-not-reconstruct-the-tree-from-a-deposit-in-the-beacon-chain">Why not Reconstruct the Tree from a Deposit in the Beacon Chain?</a></li>
</ul>
</li>
<li><a href="#backwards-compatibility">Backwards Compatibility</a></li>
<li><a href="#reference-implementation">Reference Implementation</a></li>
<li><a href="#test-cases">Test Cases</a></li>
<li><a href="#security-considerations">Security Considerations</a>
<ul>
<li><a href="#relying-on-weak-subjectivity-sync">Relying on Weak Subjectivity Sync</a></li>
<li><a href="#deposit-finalization-conditions">Deposit Finalization Conditions</a></li>
<li><a href="#deposit-queue-exceeds-eip-4444-pruning-period">Deposit Queue Exceeds EIP-4444 Pruning Period</a></li>
</ul>
</li>
<li><a href="#copyright">Copyright</a></li>
</ul>
</div>
<h2 id="abstract">
<a href="#abstract" class="anchor-link"></a> Abstract
</h2>
<p>This EIP defines a standard format for transmitting the deposit contract Merkle tree in a compressed form during weak subjectivity sync. This allows newly syncing consensus clients to reconstruct the deposit tree much faster than downloading all historical deposits. The format proposed also allows clients to prune deposits that are no longer needed to participate fully in consensus (see <a href="#deposit-finalization-flow">Deposit Finalization Flow</a>).</p>
<h2 id="motivation">
<a href="#motivation" class="anchor-link"></a> Motivation
</h2>
<p>Most client implementations require beacon nodes to download and store every deposit log since the launch of the deposit contract in order to reconstruct the deposit Merkle tree. This approach requires nodes to store far more deposits than necessary to fully participate in consensus. It also needlessly increases the time it takes for new nodes to fully sync, which is especially noticeable during weak subjectivity sync. Furthermore, if <a href="/EIPS/eip-4444">EIP-4444</a> is adopted, it will not always be possible to download all historical deposit logs from full nodes.</p>
<h2 id="specification">
<a href="#specification" class="anchor-link"></a> Specification
</h2>
<p>Consensus clients MAY continue to implement the deposit Merkle tree however they choose. However, when transmitting the tree to newly syncing nodes, clients MUST use the following format:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DepositTreeSnapshot {
    finalized: Vector[Hash32],
    deposits: uint64,
    execution_block_hash: Hash32,
}
</code></pre></div></div>
<p>Where the hashes in the <code class="language-plaintext highlighter-rouge">finalized</code> vector are defined in the <a href="#deposit-finalization-flow">Deposit Finalization Flow</a> section below, <code class="language-plaintext highlighter-rouge">deposits</code> is the number of deposits stored in the snapshot, and <code class="language-plaintext highlighter-rouge">execution_block_hash</code> is the hash of the execution block containing the highest index deposit stored in the snapshot. Consensus clients MUST make this structure available via the Beacon Node API endpoint:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/eth/v1/beacon/deposit_snapshot
</code></pre></div></div>
<h3 id="deposit-finalization-flow">
<a href="#deposit-finalization-flow" class="anchor-link"></a> Deposit Finalization Flow
</h3>
<p>During deposit processing, the beacon chain requires deposits to be submitted along with a Merkle path to the deposit root. This is required exactly once for each deposit. When a deposit has been processed by the beacon chain and the <a href="#deposit-finalization-conditions">deposit finalization conditions</a> have been met, many of the hashes along the path to the deposit root will never be required again to construct Merkle proofs on chain. These unnecessary hashes MAY be pruned to save space. The image below illustrates the evolution of the deposit Merkle tree under this process alongside the corresponding <code class="language-plaintext highlighter-rouge">DepositTreeSnapshot</code> as new deposits are added and older deposits become finalized:</p>
<p><img src="../assets/eip-4881/deposit_tree_evolution.png" style="max-width: 1200px;" /></p>
<h2 id="rationale">
<a href="#rationale" class="anchor-link"></a> Rationale
</h2>
<p>The format in this specification was chosen to achieve several goals simultaneously:</p>
<ol>
<li>Enable reconstruction of the deposit contract Merkle tree under the adoption of <a href="/EIPS/eip-4444">EIP-4444</a></li>
<li>Avoid requiring consensus nodes to retain more deposits than necessary to fully participate in consensus</li>
<li>Simplicity of implementation (see <a href="#reference-implementation">Reference Implementation</a> section)</li>
<li>Increase speed of weak subjectivity sync</li>
<li>Compatibility with existing implementations of this mechanism (see <a href="https://ethereum-magicians.org/t/eip-4881-deposit-contract-snapshot-interface/">discussion</a>)</li>
</ol>
<h3 id="why-not-reconstruct-the-tree-directly-from-the-deposit-contract">
<a href="#why-not-reconstruct-the-tree-directly-from-the-deposit-contract" class="anchor-link"></a> Why not Reconstruct the Tree Directly from the Deposit Contract?
</h3>
<p>The deposit contract can only provide the tree at the head of the chain. Because the beacon chain’s view of the deposit contract lags behind the execution chain by <code class="language-plaintext highlighter-rouge">ETH1_FOLLOW_DISTANCE</code>, there are almost always deposits which haven’t yet been included in the chain that need proofs constructed from an earlier version of the tree than exists at the head.</p>
<h3 id="why-not-reconstruct-the-tree-from-a-deposit-in-the-beacon-chain">
<a href="#why-not-reconstruct-the-tree-from-a-deposit-in-the-beacon-chain" class="anchor-link"></a> Why not Reconstruct the Tree from a Deposit in the Beacon Chain?
</h3>
<p>In principle, a node could scan backwards through the chain starting from the weak subjectivity checkpoint to locate a suitable <a href="https://github.com/ethereum/consensus-specs/blob/v1.1.9/specs/phase0/beacon-chain.md#deposit"><code class="language-plaintext highlighter-rouge">Deposit</code></a>, and then extract the rightmost branch of the tree from that. The node would also need to extract the <code class="language-plaintext highlighter-rouge">execution_block_hash</code> from which to start syncing new deposits from the <code class="language-plaintext highlighter-rouge">Eth1Data</code> in the corresponding <code class="language-plaintext highlighter-rouge">BeaconState</code>. This approach is less desirable for a few reasons:</p>
<ul>
<li>More difficult to implement due to the edge cases involved in finding a suitable deposit to anchor to (the rightmost branch of the latest not-yet-included deposit is required)</li>
<li>This would make backfilling beacon blocks a requirement for reconstructing the deposit tree and therefore a requirement for block production</li>
<li>This is inherently slower than getting this information from the weak subjectivity checkpoint</li>
</ul>
<h2 id="backwards-compatibility">
<a href="#backwards-compatibility" class="anchor-link"></a> Backwards Compatibility
</h2>
<p>This proposal is fully backwards compatible.</p>
<h2 id="reference-implementation">
<a href="#reference-implementation" class="anchor-link"></a> Reference Implementation
</h2>
<p>This implementation lacks error checking and is optimized for readability over efficiency. If <code class="language-plaintext highlighter-rouge">tree</code> is a <code class="language-plaintext highlighter-rouge">DepositTree</code>, then the <code class="language-plaintext highlighter-rouge">DepositTreeSnapshot</code> can be obtained by calling <code class="language-plaintext highlighter-rouge">tree.get_snapshot()</code> and a new instance of the tree can be recovered from the snapshot by calling <code class="language-plaintext highlighter-rouge">DepositTree.from_snapshot()</code>. See the <a href="#deposit-finalization-conditions">Deposit Finalization Conditions</a> section for discussion on when the tree can be pruned by calling <code class="language-plaintext highlighter-rouge">tree.finalize()</code>.</p>
<p>Generating proofs for deposits against an earlier version of the tree is relatively fast in this implementation; just create a copy of the finalized tree with <code class="language-plaintext highlighter-rouge">copy = DepositTree.from_snapshot(tree.get_snapshot())</code> and then append the remaining deposits to the desired count with <code class="language-plaintext highlighter-rouge">copy.push_leaf(deposit)</code>. Proofs can then be obtained with <code class="language-plaintext highlighter-rouge">copy.get_proof(index)</code>.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span><span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">eip4881</span> <span class="kn">import</span> <span class="n">DEPOSIT_CONTRACT_DEPTH</span><span class="p">,</span><span class="n">Hash32</span><span class="p">,</span><span class="n">sha256</span><span class="p">,</span><span class="n">to_le_bytes</span><span class="p">,</span><span class="n">zerohashes</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">DepositTreeSnapshot</span><span class="p">:</span>
    <span class="n">finalized</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">]</span>
    <span class="n">deposits</span><span class="p">:</span> <span class="n">uint64</span>
    <span class="n">execution_block_hash</span><span class="p">:</span> <span class="n">Hash32</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">DepositTree</span><span class="p">:</span>
    <span class="n">tree</span><span class="p">:</span> <span class="n">MerkleTree</span>
    <span class="n">mix_in_length</span><span class="p">:</span> <span class="n">uint</span>
    <span class="n">finalized_execution_block</span><span class="p">:</span> <span class="n">Hash32</span>
    <span class="k">def</span> <span class="nf">new</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">DepositTree</span><span class="p">:</span>
        <span class="n">merkle</span> <span class="o">=</span> <span class="n">MerkleTree</span><span class="p">.</span><span class="n">create</span><span class="p">([],</span> <span class="n">DEPOSIT_CONTRACT_DEPTH</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DepositTree</span><span class="p">(</span><span class="n">merkle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zerohashes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">get_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DepositTreeSnapshot</span><span class="p">:</span>
        <span class="c1"># omitted check to ensure this DepositTree has been finalized before
</span>        <span class="n">finalized</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deposits</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tree</span><span class="p">.</span><span class="n">get_finalized</span><span class="p">(</span><span class="n">finalized</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DepositTreeSnapshot</span><span class="p">(</span><span class="n">finalized</span><span class="p">,</span> <span class="n">deposits</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">finalized_execution_block</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_snapshot</span><span class="p">(</span><span class="n">snapshot</span><span class="p">:</span> <span class="n">DepositTreeSnapshot</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DepositTree</span><span class="p">:</span>
        <span class="c1"># omitted snapshot validation checks
</span>        <span class="n">tree</span> <span class="o">=</span> <span class="n">MerkleTree</span><span class="p">.</span><span class="n">from_snapshot_parts</span><span class="p">(</span>
            <span class="n">snapshot</span><span class="p">.</span><span class="n">finalized</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">.</span><span class="n">deposits</span><span class="p">,</span> <span class="n">DEPOSIT_CONTRACT_DEPTH</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DepositTree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">.</span><span class="n">deposits</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">.</span><span class="n">execution_block_hash</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eth1_data</span><span class="p">:</span> <span class="n">Eth1Data</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">finalized_execution_block</span> <span class="o">=</span> <span class="n">eth1_data</span><span class="p">.</span><span class="n">block_hash</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tree</span><span class="p">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">eth1_data</span><span class="p">.</span><span class="n">deposit_count</span><span class="p">,</span> <span class="n">DEPOSIT_CONTRACT_DEPTH</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_proof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hash32</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">]]:</span>
        <span class="c1"># omitted check to ensure index &gt; finalized deposit index
</span>        <span class="n">leaf</span><span class="p">,</span> <span class="n">proof</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tree</span><span class="p">.</span><span class="n">generate_proof</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">DEPOSIT_CONTRACT_DEPTH</span><span class="p">)</span>
        <span class="n">proof</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_le_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mix_in_length</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">proof</span>
    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hash32</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sha256</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">tree</span><span class="p">.</span><span class="n">get_root</span><span class="p">()</span> <span class="o">+</span> <span class="n">to_le_bytes</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">mix_in_length</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">push_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">:</span> <span class="n">Hash32</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">mix_in_length</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tree</span><span class="p">.</span><span class="n">push_leaf</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">DEPOSIT_CONTRACT_DEPTH</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MerkleTree</span><span class="p">():</span>
    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hash32</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">is_full</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">push_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">:</span> <span class="n">Hash32</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MerkleTree</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deposits_to_finalize</span><span class="p">:</span> <span class="n">uint</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MerkleTree</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uint</span><span class="p">:</span>
        <span class="c1"># returns the number of finalized deposits in the tree
</span>        <span class="c1"># while populating result with the finalized hashes
</span>        <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">leaves</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">],</span> <span class="n">depth</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MerkleTree</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">leaves</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">depth</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Leaf</span><span class="p">(</span><span class="n">leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">split</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">))</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">MerkleTree</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">leaves</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">split</span><span class="p">],</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">MerkleTree</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">leaves</span><span class="p">[</span><span class="n">split</span><span class="p">:],</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">from_snapshot_parts</span><span class="p">(</span><span class="n">finalized</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">],</span> <span class="n">deposits</span><span class="p">:</span> <span class="n">uint</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MerkleTree</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">finalized</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span><span class="p">(</span><span class="n">deposits</span><span class="p">):</span>
            <span class="c1"># empty tree
</span>            <span class="k">return</span> <span class="n">Zero</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deposits</span> <span class="o">==</span> <span class="mi">2</span><span class="o">**</span><span class="n">level</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Finalized</span><span class="p">(</span><span class="n">deposits</span><span class="p">,</span> <span class="n">finalized</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">left_subtree</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deposits</span> <span class="o">&lt;=</span> <span class="n">left_subtree</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">MerkleTree</span><span class="p">.</span><span class="n">from_snapshot_parts</span><span class="p">(</span><span class="n">finalized</span><span class="p">,</span> <span class="n">deposits</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">Zero</span><span class="p">(</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">Finalized</span><span class="p">(</span><span class="n">left_subtree</span><span class="p">,</span> <span class="n">finalized</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">MerkleTree</span><span class="p">.</span><span class="n">from_snapshot_parts</span><span class="p">(</span><span class="n">finalized</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">deposits</span> <span class="o">-</span> <span class="n">left_subtree</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Node</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">generate_proof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">uint</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Hash32</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">]]:</span>
        <span class="n">proof</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ith_bit</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0x1</span>
            <span class="k">if</span> <span class="n">ith_bit</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">proof</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">get_root</span><span class="p">())</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">proof</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">get_root</span><span class="p">())</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="n">left</span>
            <span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">proof</span><span class="p">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">get_root</span><span class="p">(),</span> <span class="n">proof</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">Finalized</span><span class="p">(</span><span class="n">MerkleTree</span><span class="p">):</span>
    <span class="n">deposits</span><span class="p">:</span> <span class="n">uint</span>
    <span class="nb">hash</span><span class="p">:</span> <span class="n">Hash32</span>
    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hash32</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="nb">hash</span>
    <span class="k">def</span> <span class="nf">is_full</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deposits_to_finalize</span><span class="p">:</span> <span class="n">uint</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MerkleTree</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">get_finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uint</span><span class="p">:</span>
        <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="nb">hash</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">deposits</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">Leaf</span><span class="p">(</span><span class="n">MerkleTree</span><span class="p">):</span>
    <span class="nb">hash</span><span class="p">:</span> <span class="n">Hash32</span>
    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hash32</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="nb">hash</span>
    <span class="k">def</span> <span class="nf">is_full</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deposits_to_finalize</span><span class="p">:</span> <span class="n">uint</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MerkleTree</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Finalized</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="nb">hash</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uint</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="n">MerkleTree</span><span class="p">):</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">MerkleTree</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">MerkleTree</span>
    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hash32</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sha256</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">get_root</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">get_root</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">is_full</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">is_full</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">push_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">:</span> <span class="n">Hash32</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MerkleTree</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">is_full</span><span class="p">()):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">push_leaf</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">push_leaf</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deposits_to_finalize</span><span class="p">:</span> <span class="n">uint</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MerkleTree</span><span class="p">:</span>
        <span class="n">deposits</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">level</span>
        <span class="k">if</span> <span class="n">deposits</span> <span class="o">&lt;=</span> <span class="n">deposits_to_finalize</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Finalized</span><span class="p">(</span><span class="n">deposits</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_root</span><span class="p">())</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">deposits_to_finalize</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deposits_to_finalize</span> <span class="o">&gt;</span> <span class="n">deposits</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">remaining</span> <span class="o">=</span> <span class="n">deposits_to_finalize</span> <span class="o">-</span> <span class="n">deposits</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="k">def</span> <span class="nf">get_finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uint</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">get_finalized</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">get_finalized</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">Zero</span><span class="p">(</span><span class="n">MerkleTree</span><span class="p">):</span>
    <span class="n">n</span><span class="p">:</span> <span class="n">uint64</span>
    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hash32</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">==</span> <span class="n">DEPOSIT_CONTRACT_DEPTH</span><span class="p">:</span>
            <span class="c1"># Handle the entirely empty tree case. This is included for
</span>            <span class="c1"># consistency/clarity as the zerohashes array is typically
</span>            <span class="c1"># only defined from 0 to DEPOSIT_CONTRACT_DEPTH - 1.
</span>            <span class="k">return</span> <span class="n">sha256</span><span class="p">(</span><span class="n">zerohashes</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">zerohashes</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">zerohashes</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">n</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">is_full</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">def</span> <span class="nf">push_leaf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf</span><span class="p">:</span> <span class="n">Hash32</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">uint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MerkleTree</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MerkleTree</span><span class="p">.</span><span class="n">create</span><span class="p">([</span><span class="n">leaf</span><span class="p">],</span> <span class="n">level</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">get_finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Hash32</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">uint</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
</code></pre></div></div>
<h2 id="test-cases">
<a href="#test-cases" class="anchor-link"></a> Test Cases
</h2>
<p>Test cases are included in <a href="/assets/eip-4881/test_cases.yaml">test_cases.yaml</a>. Each case is structured as follows:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DepositTestCase</span><span class="p">:</span>
    <span class="n">deposit_data</span><span class="p">:</span> <span class="n">DepositData</span>     <span class="c1"># These are all the inputs to the deposit contract's deposit() function
</span>    <span class="n">deposit_data_root</span><span class="p">:</span> <span class="n">Hash32</span>     <span class="c1"># The tree hash root of this deposit (calculated for convenience)
</span>    <span class="n">eth1_data</span><span class="p">:</span> <span class="n">Eth1Data</span>           <span class="c1"># An Eth1Data object that can be used to finalize the tree after pushing this deposit
</span>    <span class="n">snapshot</span><span class="p">:</span> <span class="n">DepositTreeSnapshot</span> <span class="c1"># The resulting DepositTreeSnapshot object if the tree were finalized after this deposit
</span></code></pre></div></div>
<p>This EIP also includes other files for testing:</p>
<ul>
<li><a href="/assets/eip-4881/deposit_snapshot.py">deposit_snapshot.py</a> contains the same code as the <a href="#reference-implementation">Reference Implementation</a></li>
<li><a href="/assets/eip-4881/eip4881.py">eip4881.py</a> contains boilerplate declarations</li>
<li><a href="/assets/eip-4881/test_deposit_snapshot.py">test_deposit_snapshot.py</a> includes code for running test cases against the reference implementation</li>
</ul>
<p>If these files are downloaded to the same directory, the test cases can be run by executing <code class="language-plaintext highlighter-rouge">pytest</code> in that directory.</p>
<h2 id="security-considerations">
<a href="#security-considerations" class="anchor-link"></a> Security Considerations
</h2>
<h3 id="relying-on-weak-subjectivity-sync">
<a href="#relying-on-weak-subjectivity-sync" class="anchor-link"></a> Relying on Weak Subjectivity Sync
</h3>
<p>The upcoming switch to PoS will require newly synced nodes to rely on valid weak subjectivity checkpoints because of long-range attacks. This proposal relies on the weak subjectivity assumption that clients will not bootstrap with an invalid WS checkpoint.</p>
<h3 id="deposit-finalization-conditions">
<a href="#deposit-finalization-conditions" class="anchor-link"></a> Deposit Finalization Conditions
</h3>
<p>Care must be taken not to send a snapshot which includes deposits that haven’t been fully included in the finalized checkpoint. Let <code class="language-plaintext highlighter-rouge">state</code> be the <a href="https://github.com/ethereum/consensus-specs/blob/v1.1.9/specs/phase0/beacon-chain.md#beaconstate"><code class="language-plaintext highlighter-rouge">BeaconState</code></a> at a given block in the chain. Under normal operation, the <a href="https://github.com/ethereum/consensus-specs/blob/v1.1.9/specs/phase0/beacon-chain.md#eth1data"><code class="language-plaintext highlighter-rouge">Eth1Data</code></a> stored in <code class="language-plaintext highlighter-rouge">state.eth1_data</code> is replaced every <code class="language-plaintext highlighter-rouge">EPOCHS_PER_ETH1_VOTING_PERIOD</code> epochs. Thus, finalization of the deposit tree proceeds in increments of <code class="language-plaintext highlighter-rouge">state.eth1_data</code>. Let <code class="language-plaintext highlighter-rouge">eth1data</code> be some <code class="language-plaintext highlighter-rouge">Eth1Data</code>. Both of the following conditions MUST be met to consider <code class="language-plaintext highlighter-rouge">eth1data</code> finalized:</p>
<ol>
<li>A finalized checkpoint exists where the corresponding <code class="language-plaintext highlighter-rouge">state</code> has <code class="language-plaintext highlighter-rouge">state.eth1_data == eth1data</code></li>
<li>A finalized checkpoint exists where the corresponding <code class="language-plaintext highlighter-rouge">state</code> has <code class="language-plaintext highlighter-rouge">state.eth1_deposit_index &gt;= eth1data.deposit_count</code></li>
</ol>
<p>When these conditions are met, the tree can be pruned in the <a href="#reference-implementation">reference implementation</a> by calling <code class="language-plaintext highlighter-rouge">tree.finalize(eth1data)</code></p>
<h3 id="deposit-queue-exceeds-eip-4444-pruning-period">
<a href="#deposit-queue-exceeds-eip-4444-pruning-period" class="anchor-link"></a> Deposit Queue Exceeds EIP-4444 Pruning Period
</h3>
<p>The proposed design could fail if the deposit queue becomes so large that deposits cannot be processed within the <a href="/EIPS/eip-4444">EIP-4444 Pruning Period</a> (currently set to 1 year). The beacon chain can process <code class="language-plaintext highlighter-rouge">MAX_DEPOSITS/SECONDS_PER_SLOT</code> deposits/second without skipped slots. Even under extreme conditions where 25% of slots are skipped, the deposit queue would need to be &gt;31.5 million to hit this limit. This is more than 8x the total supply of ether assuming each deposit is a full validator. The minimum deposit is 1 ETH so an attacker would need to burn &gt;30 Million ETH to create these conditions.</p>
<h2 id="copyright">
<a href="#copyright" class="anchor-link"></a> Copyright
</h2>
<p>Copyright and related rights waived via <a href="/LICENSE">CC0</a>.</p>
<h2>Citation</h2>
<p>Please cite this document as:</p>
<p><a href="https://github.com/ethDreamer">Mark Mackey</a>, "EIP-4881: Deposit Contract Snapshot Interface [DRAFT]," <em>Ethereum Improvement Proposals</em>, no. 4881, January 2021. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-4881.</p>
</div>
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "TechArticle",
    "headline": "EIP-4881: Deposit Contract Snapshot Interface [DRAFT]",
    "author": "Mark Mackey (@ethDreamer)",
    "name": "EIP-4881: Deposit Contract Snapshot Interface [DRAFT]",
    "dateCreated": "2021-01-29",
    "datePublished": "2021-01-29",

    "discussionUrl": "https://ethereum-magicians.org/t/eip-4881-deposit-contract-snapshot-interface/",
    
    "inLanguage": "en-US",
    "license": "#copyright",
    "copyrightYear": "2021"
  }
</script>
</div>
</main><footer class="site-footer h-card">
<data class="u-url" href="/"></data>
<div class="wrapper">
<h2 class="footer-heading">Ethereum Improvement Proposals</h2>
<div class="footer-col-wrapper">
<div class="footer-col footer-col-1">
<ul class="contact-list">
<li class="p-name">Ethereum Improvement Proposals</li></ul>
</div>
<div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ethereum/EIPs"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ethereum/EIPs</span></a></li></ul>
</div>
<div class="footer-col footer-col-3">
<p>Ethereum Improvement Proposals (EIPs) describe standards for the Ethereum platform, including core protocol specifications, client APIs, and contract standards.</p>
</div>
</div>
</div>
</footer>
</body>
</html>
